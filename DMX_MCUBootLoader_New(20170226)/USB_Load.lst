Interrupt Vectors

Program Code (text area)
__text_start|__start:
    0F07B E001      LDI	R16,1
    0F07C BF05      OUT	0x35,R16
    0F07D E002      LDI	R16,2
    0F07E BF05      OUT	0x35,R16
    0F07F EFCF      LDI	R28,0xFF
    0F080 E1D0      LDI	R29,0x10
    0F081 BFCD      OUT	0x3D,R28
    0F082 BFDE      OUT	0x3E,R29
    0F083 58C0      SUBI	R28,0x80
    0F084 40D0      SBCI	R29,0
    0F085 EA0A      LDI	R16,0xAA
    0F086 8308      ST	Y,R16
    0F087 2400      CLR	R0
    0F088 E6E5      LDI	R30,0x65
    0F089 E0F1      LDI	R31,1
    0F08A E012      LDI	R17,2
    0F08B 3FE5      CPI	R30,0xF5
    0F08C 07F1      CPC	R31,R17
    0F08D F011      BEQ	0xF090
    0F08E 9201      ST	Z+,R0
    0F08F CFFB      RJMP	0xF08B
    0F090 8300      ST	Z,R16
    0F091 E9E0      LDI	R30,0x90
    0F092 EEF0      LDI	R31,0xE0
    0F093 E0A0      LDI	R26,0
    0F094 E0B1      LDI	R27,1
    0F095 EE10      LDI	R17,0xE0
    0F096 E001      LDI	R16,1
    0F097 BF0B      OUT	0x3B,R16
    0F098 3FE5      CPI	R30,0xF5
    0F099 07F1      CPC	R31,R17
    0F09A F021      BEQ	0xF09F
    0F09B 95D8      ELPM
    0F09C 9631      ADIW	R30,1
    0F09D 920D      ST	X+,R0
    0F09E CFF9      RJMP	0xF098
    0F09F 940E F20C CALL	_main
_exit:
    0F0A1 CFFF      RJMP	_exit
FILE: D:\chen\Core\FirmWare_CT\DMX_MCUBootLoader(20170226_ZKY3_V20）\main.c
(0001) 
(0002) 
(0003) 
(0004) #include <macros.h>
(0005) #include <stdio.h>
(0006) #include	"HAL.H"			// 其它单片机需修改HAL*硬件抽象层的几个文件
(0007) 
(0008) #define DBG 0
(0009) 
(0010) 
(0011) unsigned int flash_bufferPoint; 
(0012) char flash_buf[256]; //FALSH页缓冲区,M128的一个Flash页为256字节(128字) 
(0013) long address = 0; 
(0014)    
(0015) 
(0016) unsigned char tx_data[64];
(0017) unsigned char UpdateFlag=0;
(0018) 
(0019) 
(0020) 
(0021) extern void USBStart(void);
(0022) extern void EP2SendConst(UINT8 mLen, const unsigned char  *mBuf);
(0023) extern unsigned char	UsbConfig ,UsbReset;	 
(0024) 
(0025) //USB接收缓冲区数据结构
(0026) typedef struct RXDATA
(0027) {
(0028)  unsigned char flag;
(0029)  unsigned char len;
(0030)  unsigned char buf[64];
(0031) };
(0032) struct RXDATA RxData;
(0033) 
(0034) 
(0035)  
(0036) unsigned char UpdateBegin;//接收主程序数据开始标志
(0037) unsigned int DataReCn;
(0038) unsigned char crc16hi,crc16lo,DownloadSpeed;
(0039) unsigned int Timer3Cn;
(0040) 	   
(0041) extern void	Init374Device( void );  // 初始化USB设备
(0042) extern void EP2Send(UINT8 mLen, PUINT8 mBuf);
(0043) extern unsigned char	UsbConfig ;	// USB配置标志
(0044) 
(0045) void DelayMs(unsigned int t);
(0046) 
(0047) //OSC=8M Hz
(0048) //UART0 initialize
(0049) // desired baud rate: 38400
(0050) // actual: baud rate:37500 (2.4%)
(0051) void uart0_init(void)
(0052) {
(0053)  UCSR0B = 0x00; //disable while setting baud rate
_uart0_init:
    0F0A2 2422      CLR	R2
    0F0A3 B82A      OUT	0x0A,R2
(0054)  UCSR0A = 0x00;
    0F0A4 B82B      OUT	0x0B,R2
(0055)  UCSR0C = 0x06;
    0F0A5 E086      LDI	R24,6
    0F0A6 9380 0095 STS	0x95,R24
(0056)  UBRR0L = 0x0B; //set baud rate lo
    0F0A8 E08B      LDI	R24,0xB
    0F0A9 B989      OUT	0x09,R24
(0057)  UBRR0H = 0x00; //set baud rate hi
    0F0AA 9220 0090 STS	0x90,R2
(0058)  UCSR0B = 0x18;
    0F0AC E188      LDI	R24,0x18
    0F0AD B98A      OUT	0x0A,R24
    0F0AE 9508      RET
(0059) }
(0060) 
(0061) 
(0062) 
(0063) void port_init(void)
(0064) {
(0065)  PORTA = 0x00; 
_port_init:
    0F0AF 2422      CLR	R2
    0F0B0 BA2B      OUT	0x1B,R2
(0066)  DDRA  = 0x00; 
    0F0B1 BA2A      OUT	0x1A,R2
(0067)  
(0068)  PORTB = 0x10; 
    0F0B2 E180      LDI	R24,0x10
    0F0B3 BB88      OUT	0x18,R24
(0069)  DDRB  = 0x10; 
    0F0B4 BB87      OUT	0x17,R24
(0070)  
(0071)  PORTC = 0x00; 
    0F0B5 BA25      OUT	0x15,R2
(0072)  DDRC  = 0x00;
    0F0B6 BA24      OUT	0x14,R2
(0073)  
(0074)  PORTD = 0x00; 
    0F0B7 BA22      OUT	0x12,R2
(0075)  DDRD  = 0x00; 
    0F0B8 BA21      OUT	0x11,R2
(0076)  
(0077)  PORTE = 0x00;
    0F0B9 B823      OUT	0x03,R2
(0078)  DDRE  = 0x00;
    0F0BA B822      OUT	0x02,R2
(0079)  
(0080)  PORTF = 0x00; 
    0F0BB 9220 0062 STS	0x62,R2
(0081)  DDRF  = 0x00; 
    0F0BD 9220 0061 STS	0x61,R2
(0082)  
(0083)  PORTG = 0x00;
    0F0BF 9220 0065 STS	0x65,R2
(0084)  DDRG  = 0x00;
    0F0C1 9220 0064 STS	0x64,R2
    0F0C3 9508      RET
_DelayMs:
  n                    --> R10
  f                    --> Y,+0
  t                    --> R10
    0F0C4 940E F905 CALL	push_xgsetF00C
    0F0C6 0158      MOVW	R10,R16
    0F0C7 9724      SBIW	R28,4
(0085) }
(0086) 
(0087) void DelayMs(unsigned int t)
(0088) {
(0089)    float f;
(0090)    unsigned int n;
(0091)    if(t>8388)
    0F0C8 EC84      LDI	R24,0xC4
    0F0C9 E290      LDI	R25,0x20
    0F0CA 158A      CP	R24,R10
    0F0CB 059B      CPC	R25,R11
    0F0CC F408      BCC	0xF0CE
(0092)      t=8388;
    0F0CD 015C      MOVW	R10,R24
(0093)    f=t;
    0F0CE 0185      MOVW	R16,R10
    0F0CF 940E F973 CALL	uint2fp
    0F0D1 8308      ST	Y,R16
    0F0D2 8319      STD	Y+1,R17
    0F0D3 832A      STD	Y+2,R18
    0F0D4 833B      STD	Y+3,R19
(0094)    f*=15.625;
    0F0D5 E80C      LDI	R16,0x8C
    0F0D6 EE10      LDI	R17,0xE0
    0F0D7 940E F892 CALL	elpm32
    0F0D9 01CE      MOVW	R24,R28
    0F0DA 939A      ST	-Y,R25
    0F0DB 938A      ST	-Y,R24
    0F0DC 940E FA76 CALL	fpmule1
    0F0DE 8308      ST	Y,R16
    0F0DF 8319      STD	Y+1,R17
    0F0E0 832A      STD	Y+2,R18
    0F0E1 833B      STD	Y+3,R19
(0095)    n=f;
    0F0E2 8108      LD	R16,Y
    0F0E3 8119      LDD	R17,Y+1
    0F0E4 812A      LDD	R18,Y+2
    0F0E5 813B      LDD	R19,Y+3
    0F0E6 940E F941 CALL	fpint
    0F0E8 0158      MOVW	R10,R16
(0096)    TCNT1=65536-n;
    0F0E9 0115      MOVW	R2,R10
    0F0EA 2444      CLR	R4
    0F0EB 2455      CLR	R5
    0F0EC E040      LDI	R20,0
    0F0ED E050      LDI	R21,0
    0F0EE E061      LDI	R22,1
    0F0EF E070      LDI	R23,0
    0F0F0 1942      SUB	R20,R2
    0F0F1 0953      SBC	R21,R3
    0F0F2 0964      SBC	R22,R4
    0F0F3 0975      SBC	R23,R5
    0F0F4 BD5D      OUT	0x2D,R21
    0F0F5 BD4C      OUT	0x2C,R20
(0097)    TCCR1B=0x05;//启动定时器，1024分频
    0F0F6 E085      LDI	R24,5
    0F0F7 BD8E      OUT	0x2E,R24
(0098)    TIFR|=0x04;//清定时器1中断标志
    0F0F8 B786      IN	R24,0x36
    0F0F9 6084      ORI	R24,4
    0F0FA BF86      OUT	0x36,R24
(0099)    while((TIFR&0x04)==0x00);
    0F0FB B626      IN	R2,0x36
    0F0FC FE22      SBRS	R2,2
    0F0FD CFFD      RJMP	0xF0FB
(0100)    TCCR1B=0x00;//停止定时器
    0F0FE 2422      CLR	R2
    0F0FF BC2E      OUT	0x2E,R2
    0F100 9624      ADIW	R28,4
    0F101 940C F90C JMP	pop_xgsetF00C
_crc16:
  ii                   --> R20
  ch                   --> R10
  cl                   --> R22
  savelo               --> R14
  savehi               --> Y,+0
  flag                 --> R12
  length               --> R18
  r_data               --> Y,+11
    0F103 940E F88D CALL	push_arg4
    0F105 940E F8FA CALL	push_xgsetF0FC
    0F107 9721      SBIW	R28,1
(0101) }
(0102) 
(0103) 
(0104) void crc16(unsigned char r_data[],unsigned int length)
(0105) {
(0106)         unsigned char cl,ch;
(0107)         unsigned char savehi,savelo;
(0108)         int ii,flag;
(0109)         crc16hi=0xFF;
    0F108 EF8F      LDI	R24,0xFF
    0F109 9380 0169 STS	crc16hi,R24
(0110)         crc16lo=0xFF;
    0F10B 9380 0168 STS	crc16lo,R24
(0111)         cl=0x1;
    0F10D E061      LDI	R22,1
(0112)         ch=0xA0;
    0F10E EA80      LDI	R24,0xA0
    0F10F 2EA8      MOV	R10,R24
(0113)         for (ii=0;ii<length-2;ii++)
    0F110 2744      CLR	R20
    0F111 2755      CLR	R21
    0F112 C038      RJMP	0xF14B
(0114)         {
(0115)             crc16lo=(crc16lo ^ r_data[ii]);
    0F113 01FA      MOVW	R30,R20
    0F114 840B      LDD	R0,Y+11
    0F115 841C      LDD	R1,Y+12
    0F116 0DE0      ADD	R30,R0
    0F117 1DF1      ADC	R31,R1
    0F118 8020      LD	R2,Z
    0F119 9030 0168 LDS	R3,crc16lo
    0F11B 2432      EOR	R3,R2
    0F11C 9230 0168 STS	crc16lo,R3
(0116)                 for (flag=0;flag<8;flag++)
    0F11E 24CC      CLR	R12
    0F11F 24DD      CLR	R13
(0117)                 {
(0118)                        savehi=crc16hi;
    0F120 9020 0169 LDS	R2,crc16hi
    0F122 8228      ST	Y,R2
(0119)                         savelo=crc16lo;
    0F123 90E0 0168 LDS	R14,crc16lo
(0120)                        crc16hi=(crc16hi>>1);
    0F125 9426      LSR	R2
    0F126 9220 0169 STS	crc16hi,R2
(0121)                        crc16lo=(crc16lo>>1);
    0F128 2C2E      MOV	R2,R14
    0F129 9426      LSR	R2
    0F12A 9220 0168 STS	crc16lo,R2
(0122)                         if ((savehi & 0x01)==0x01)
    0F12C 8188      LD	R24,Y
    0F12D 7081      ANDI	R24,1
    0F12E 3081      CPI	R24,1
    0F12F F421      BNE	0xF134
(0123)                                 crc16lo=(crc16lo | 0x80);
    0F130 2D82      MOV	R24,R2
    0F131 6880      ORI	R24,0x80
    0F132 9380 0168 STS	crc16lo,R24
(0124)                         if        ((savelo & 0x01)==0x01)
    0F134 2D8E      MOV	R24,R14
    0F135 7081      ANDI	R24,1
    0F136 3081      CPI	R24,1
    0F137 F451      BNE	0xF142
(0125)                         {
(0126)                                 crc16hi = (crc16hi ^ ch);
    0F138 9020 0169 LDS	R2,crc16hi
    0F13A 242A      EOR	R2,R10
    0F13B 9220 0169 STS	crc16hi,R2
(0127) 								crc16lo = (crc16lo ^ cl);
    0F13D 9020 0168 LDS	R2,crc16lo
    0F13F 2626      EOR	R2,R22
    0F140 9220 0168 STS	crc16lo,R2
    0F142 01C6      MOVW	R24,R12
    0F143 9601      ADIW	R24,1
    0F144 016C      MOVW	R12,R24
    0F145 3088      CPI	R24,0x8
    0F146 E0E0      LDI	R30,0
    0F147 079E      CPC	R25,R30
    0F148 F2BC      BLT	0xF120
    0F149 5F4F      SUBI	R20,0xFF
    0F14A 4F5F      SBCI	R21,0xFF
    0F14B 01C9      MOVW	R24,R18
    0F14C 9702      SBIW	R24,2
    0F14D 1748      CP	R20,R24
    0F14E 0759      CPC	R21,R25
    0F14F F408      BCC	0xF151
    0F150 CFC2      RJMP	0xF113
    0F151 9621      ADIW	R28,1
    0F152 940E F8EF CALL	pop_xgsetF0FC
    0F154 9624      ADIW	R28,4
    0F155 9508      RET
_timer3_ovf_isr:
    0F156 922A      ST	-Y,R2
    0F157 938A      ST	-Y,R24
    0F158 B62F      IN	R2,0x3F
    0F159 922A      ST	-Y,R2
(0128)                         }        
(0129)                 }
(0130)         }
(0131) }
(0132) 
(0133) #pragma interrupt_handler timer3_ovf_isr:iv_TIM3_OVF
(0134) void timer3_ovf_isr(void)
(0135) {
(0136)   UpdateBegin=0;//回到待命状态
    0F15A 2422      CLR	R2
    0F15B 9220 016C STS	UpdateBegin,R2
(0137)   TCCR3B = 0x00; //stop  
    0F15D 9220 008A STS	0x8A,R2
(0138)   ETIMSK &= 0xfb;//关定时器3中断
    0F15F 9180 007D LDS	R24,0x7D
    0F161 7F8B      ANDI	R24,0xFB
    0F162 9380 007D STS	0x7D,R24
(0139)   ETIFR|=0x04; //清定时器3中断标志 
    0F164 9180 007C LDS	R24,0x7C
    0F166 6084      ORI	R24,4
    0F167 9380 007C STS	0x7C,R24
    0F169 9029      LD	R2,Y+
    0F16A BE2F      OUT	0x3F,R2
    0F16B 9189      LD	R24,Y+
    0F16C 9029      LD	R2,Y+
    0F16D 9518      RETI
(0140) }
(0141) 
(0142) 
(0143) void SetTimer3(void)//页写开始后，如果有500ms时间内一个字节也没收到，则退出页写状态，回到待命状态
(0144) {  
(0145)     TCCR3B = 0x00; //stop    
_SetTimer3:
    0F16E 2422      CLR	R2
    0F16F 9220 008A STS	0x8A,R2
(0146)     TCNT3H = 0xF0; //8M,500ms
    0F171 EF80      LDI	R24,0xF0
    0F172 9380 0089 STS	0x89,R24
(0147)     TCNT3L = 0xBE; //8M,500ms
    0F174 EB8E      LDI	R24,0xBE
    0F175 9380 0088 STS	0x88,R24
(0148) 	ETIFR|=0x04; //清定时器3中断标志
    0F177 9180 007C LDS	R24,0x7C
    0F179 6084      ORI	R24,4
    0F17A 9380 007C STS	0x7C,R24
(0149)  	TCCR3B = 0x05; //1024分频
    0F17C E085      LDI	R24,5
    0F17D 9380 008A STS	0x8A,R24
(0150) 	ETIFR|=0x04; //清定时器3中断标志
    0F17F 9180 007C LDS	R24,0x7C
    0F181 6084      ORI	R24,4
    0F182 9380 007C STS	0x7C,R24
(0151) 	ETIMSK |= 0x04; //开定时器3中断
    0F184 9180 007D LDS	R24,0x7D
    0F186 6084      ORI	R24,4
    0F187 9380 007D STS	0x7D,R24
    0F189 9508      RET
(0152) }
(0153) //call this routine to initialize all peripherals
(0154) void init_devices(void)
(0155) {
(0156)  //stop errant interrupts until set up
(0157)  CLI(); //disable all interrupts
_init_devices:
    0F18A 94F8      BCLR	7
(0158)  XDIV  = 0x00; //xtal divider
    0F18B 2422      CLR	R2
    0F18C BE2C      OUT	0x3C,R2
(0159)  XMCRA = 0x00; //external memory
    0F18D 9220 006D STS	0x6D,R2
(0160)  port_init();
    0F18F DF1F      RCALL	_port_init
(0161) #if DBG
(0162)  uart0_init();
(0163) #endif
(0164) 
(0165)  MCUCR = 0x00;
    0F190 2422      CLR	R2
    0F191 BE25      OUT	0x35,R2
(0166)  EICRA = 0x00; //extended ext ints
    0F192 9220 006A STS	0x6A,R2
(0167)  EICRB = 0x00; //extended ext ints
    0F194 BE2A      OUT	0x3A,R2
(0168)  EIMSK = 0x00;
    0F195 BE29      OUT	0x39,R2
(0169)  TIMSK = 0x00; //timer interrupt sources
    0F196 BE27      OUT	0x37,R2
(0170)  ETIMSK = 0x00; //extended timer interrupt sources
    0F197 9220 007D STS	0x7D,R2
(0171)  SEI(); //re-enable interrupts
    0F199 9478      BSET	7
    0F19A 9508      RET
_boot_page_ew:
  code                 --> R16
  p_address            --> Y,+0
    0F19B 940E F88D CALL	push_arg4
    0F19D 810C      LDD	R16,Y+4
(0172)  //all peripherals are now initialized
(0173) }
(0174) 
(0175) 
(0176) //擦除(code=0x03)和写入(code=0x05)一个Flash页 
(0177) void boot_page_ew(long p_address,char code) 
(0178) { 
(0179)     asm("mov r30,r16\n" 
    0F19E 2FE0      MOV	R30,R16
    0F19F 2FF1      MOV	R31,R17
    0F1A0 BF2B      OUT	0x3B,R18
(0180)         "mov r31,r17\n" 
(0181)         "out 0x3b,r18\n");            //将页地址放入Z寄存器和RAMPZ的Bit0中 
(0182)     SPMCSR = code;                //寄存器SPMCSR中为操作码 
    0F1A1 9300 0068 STS	0x68,R16
(0183)     asm("spm\n");                    //对指定Flash页进行操作 
    0F1A3 95E8      SPM
    0F1A4 9624      ADIW	R28,4
    0F1A5 9508      RET
_boot_page_fill:
  data                 --> Y,+2
  address              --> Y,+0
    0F1A6 940E F88D CALL	push_arg4
(0184) }         
(0185) //填充Flash缓冲页中的一个字 
(0186) void boot_page_fill(unsigned int address,int data) 
(0187) { 
(0188)     asm("mov r30,r16\n" 
    0F1A8 2FE0      MOV	R30,R16
    0F1A9 2FF1      MOV	R31,R17
    0F1AA 2E02      MOV	R0,R18
    0F1AB 2E13      MOV	R1,R19
(0189)         "mov r31,r17\n"             //Z寄存器中为填冲页内地址 
(0190)         "mov r0,r18\n" 
(0191)         "mov r1,r19\n");            //R0R1中为一个指令字 
(0192)     SPMCSR = 0x01; 
    0F1AC E081      LDI	R24,1
    0F1AD 9380 0068 STS	0x68,R24
(0193)     asm("spm\n"); 
    0F1AF 95E8      SPM
    0F1B0 9624      ADIW	R28,4
    0F1B1 9508      RET
(0194) } 
(0195) //等待一个Flash页的写完成 
(0196) void wait_page_rw_ok(void) 
(0197) { 
_wait_page_rw_ok:
    0F1B2 C008      RJMP	0xF1BB
(0198)       while(SPMCSR & 0x40) 
(0199)      { 
(0200)          while(SPMCSR & 0x01); 
    0F1B3 9020 0068 LDS	R2,0x68
    0F1B5 FC20      SBRC	R2,0
    0F1B6 CFFC      RJMP	0xF1B3
(0201)          SPMCSR = 0x11; 
    0F1B7 E181      LDI	R24,0x11
    0F1B8 9380 0068 STS	0x68,R24
(0202)          asm("spm\n"); 
    0F1BA 95E8      SPM
    0F1BB 9020 0068 LDS	R2,0x68
    0F1BD FC26      SBRC	R2,6
    0F1BE CFF4      RJMP	0xF1B3
    0F1BF 9508      RET
_write_one_page:
  i                    --> R20
    0F1C0 934A      ST	-Y,R20
    0F1C1 935A      ST	-Y,R21
    0F1C2 9721      SBIW	R28,1
(0203)      } 
(0204) } 
(0205) 
(0206) /*
(0207) //更新一个Flash页的完整处理 
(0208) void write_one_page(void) 
(0209) { 
(0210)     int i; 
(0211)     boot_page_ew(address,0x03);                    //擦除一个Flash页 
(0212)     wait_page_rw_ok();                            //等待擦除完成 
(0213) 	 
(0214)     for(i=0;i<256;i+=2)                //将数据填入Flash缓冲页中 
(0215)     { 
(0216)         boot_page_fill(i, flash_buf[i]+(flash_buf[i+1]<<8)); 
(0217)     } 
(0218)     boot_page_ew(address,0x05);                    //将缓冲页数据写入一个Flash页 
(0219)     wait_page_rw_ok();                            //等待写入完成 
(0220) }        
(0221) */
(0222) 
(0223) //更新一个Flash页的完整处理 
(0224) void write_one_page(void) 
(0225) { 
(0226)     int i; 
(0227)     boot_page_ew(address,0x03);                    //擦除一个Flash页 
    0F1C3 E083      LDI	R24,3
    0F1C4 8388      ST	Y,R24
    0F1C5 9120 0102 LDS	R18,address+2
    0F1C7 9130 0103 LDS	R19,address+3
    0F1C9 9100 0100 LDS	R16,address
    0F1CB 9110 0101 LDS	R17,address+1
    0F1CD DFCD      RCALL	_boot_page_ew
(0228)     
(0229)     wait_page_rw_ok();                            //等待擦除完成 
    0F1CE DFE3      RCALL	_wait_page_rw_ok
(0230)     for(i=0;i<256;i+=2)                //将数据填入Flash缓冲页中 
    0F1CF 2744      CLR	R20
    0F1D0 2755      CLR	R21
(0231)     { 
(0232)         boot_page_fill(i, flash_buf[i+2]+(flash_buf[i+3]<<8)); 
    0F1D1 EF82      LDI	R24,0xF2
    0F1D2 E091      LDI	R25,1
    0F1D3 01FA      MOVW	R30,R20
    0F1D4 0FE8      ADD	R30,R24
    0F1D5 1FF9      ADC	R31,R25
    0F1D6 8020      LD	R2,Z
    0F1D7 2433      CLR	R3
    0F1D8 2C32      MOV	R3,R2
    0F1D9 2422      CLR	R2
    0F1DA EF81      LDI	R24,0xF1
    0F1DB E091      LDI	R25,1
    0F1DC 01FA      MOVW	R30,R20
    0F1DD 0FE8      ADD	R30,R24
    0F1DE 1FF9      ADC	R31,R25
    0F1DF 8120      LD	R18,Z
    0F1E0 2733      CLR	R19
    0F1E1 0D22      ADD	R18,R2
    0F1E2 1D33      ADC	R19,R3
    0F1E3 018A      MOVW	R16,R20
    0F1E4 DFC1      RCALL	_boot_page_fill
    0F1E5 5F4E      SUBI	R20,0xFE
    0F1E6 4F5F      SBCI	R21,0xFF
    0F1E7 3040      CPI	R20,0
    0F1E8 E0E1      LDI	R30,1
    0F1E9 075E      CPC	R21,R30
    0F1EA F334      BLT	0xF1D1
(0233)     } 
(0234)     boot_page_ew(address,0x05);                    //将缓冲页数据写入一个Flash页 
    0F1EB E085      LDI	R24,5
    0F1EC 8388      ST	Y,R24
    0F1ED 9120 0102 LDS	R18,address+2
    0F1EF 9130 0103 LDS	R19,address+3
    0F1F1 9100 0100 LDS	R16,address
    0F1F3 9110 0101 LDS	R17,address+1
    0F1F5 DFA5      RCALL	_boot_page_ew
(0235)    
(0236)    
(0237)     wait_page_rw_ok();                            //等待写入完成 
    0F1F6 DFBB      RCALL	_wait_page_rw_ok
    0F1F7 9621      ADIW	R28,1
    0F1F8 9159      LD	R21,Y+
    0F1F9 9149      LD	R20,Y+
    0F1FA 9508      RET
(0238) }        
(0239) 
(0240) 
(0241) void delay(unsigned int t) //y=x+3(us)
(0242) {
(0243)  while(t--);
_delay:
  t                    --> R16
    0F1FB 0118      MOVW	R2,R16
    0F1FC 5001      SUBI	R16,1
    0F1FD 4010      SBCI	R17,0
    0F1FE 2022      TST	R2
    0F1FF F7D9      BNE	0xF1FB
    0F200 2033      TST	R3
    0F201 F7C9      BNE	0xF1FB
    0F202 9508      RET
(0244) }
(0245)  
(0246) 
(0247) void quit(void) 
(0248) {
(0249)  	 UCSR0B = 0x00; //disable 
_quit:
    0F203 2422      CLR	R2
    0F204 B82A      OUT	0x0A,R2
(0250) 	 
(0251)     MCUCR = 0x01; 
    0F205 E081      LDI	R24,1
    0F206 BF85      OUT	0x35,R24
(0252)     MCUCR = 0x00;       //将中断向量表迁移到应用程序区头部 
    0F207 BE25      OUT	0x35,R2
(0253)     RAMPZ = 0x00;       //RAMPZ清零初始化 
    0F208 BE2B      OUT	0x3B,R2
(0254)     asm("jmp 0x0000\n");//跳转到Flash的0x0000处，执行用户的应用程序 
    0F209 940C 0000 JMP	0x0
    0F20B 9508      RET
(0255) } 
(0256) 
(0257) //主程序 
(0258) void main(void) 
(0259) { 
(0260)    unsigned int i ; 
(0261)    unsigned char j;
(0262)    unsigned char int0,miso;
(0263)   
(0264)    delay(1000);
_main:
  miso                 --> Y,+1
  int0                 --> Y,+1
  i                    --> Y,+1
  j                    --> R10
    0F20C EE08      LDI	R16,0xE8
    0F20D E013      LDI	R17,3
    0F20E DFEC      RCALL	_delay
(0265) 	  
(0266)    init_devices();
    0F20F DF7A      RCALL	_init_devices
(0267) 
(0268)    RxData.flag=0;
    0F210 2422      CLR	R2
    0F211 9220 016D STS	RxData,R2
(0269)  
(0270)  
(0271) 	 
(0272)      
(0273)    //内部上拉外部下拉时，输出变输入后，口线立即变高，5us后变低
(0274)    SFIOR&=0xfb;   //上拉不禁止,bit2=0
    0F213 B580      IN	R24,0x20
    0F214 7F8B      ANDI	R24,0xFB
    0F215 BD80      OUT	0x20,R24
(0275)    
(0276)    PORTB|=0x08;  //PB3内部上拉
    0F216 9AC3      SBI	0x18,3
(0277)    DDRB&=0xf7;   //PB3设为输入 
    0F217 B387      IN	R24,0x17
    0F218 7F87      ANDI	R24,0xF7
    0F219 BB87      OUT	0x17,R24
(0278)    
(0279)    PORTD|=0x01;  //PD0内部上拉
    0F21A 9A90      SBI	0x12,0
(0280)    DDRD&=0xfe;   //PD0设为输入 
    0F21B B381      IN	R24,0x11
    0F21C 7F8E      ANDI	R24,0xFE
    0F21D BB81      OUT	0x11,R24
(0281)    
(0282)    SFIOR&=0xfb;   //上拉不禁止,bit2=0
    0F21E B580      IN	R24,0x20
    0F21F 7F8B      ANDI	R24,0xFB
    0F220 BD80      OUT	0x20,R24
(0283)    
(0284)    PORTB|=0x08;  //PB3内部上拉
    0F221 9AC3      SBI	0x18,3
(0285)    DDRB&=0xf7;   //PB3设为输入   
    0F222 B387      IN	R24,0x17
    0F223 7F87      ANDI	R24,0xF7
    0F224 BB87      OUT	0x17,R24
(0286)    PORTB|=0x08;  //PB3内部上拉
    0F225 9AC3      SBI	0x18,3
(0287)    
(0288)    PORTD|=0x01;  //PD0内部上拉
    0F226 9A90      SBI	0x12,0
(0289)    DDRD&=0xfe;   //PD0设为输入 
    0F227 B381      IN	R24,0x11
    0F228 7F8E      ANDI	R24,0xFE
    0F229 BB81      OUT	0x11,R24
(0290)    PORTD|=0x01;  //PD0内部上拉
    0F22A 9A90      SBI	0x12,0
(0291)    
(0292)    DelayMs(100);
    0F22B E604      LDI	R16,0x64
    0F22C E010      LDI	R17,0
    0F22D DE96      RCALL	_DelayMs
(0293)    
(0294)  
(0295)  
(0296)       CLI();
    0F22E 94F8      BCLR	7
(0297)       EIMSK = 0x41;
    0F22F E481      LDI	R24,0x41
    0F230 BF89      OUT	0x39,R24
(0298) 	  SEI();
    0F231 9478      BSET	7
(0299)    #if DBG
(0300)       printf("Communication Status\r\n");
(0301)    #endif
(0302)       RxData.flag=0;
    0F232 2422      CLR	R2
    0F233 9220 016D STS	RxData,R2
(0303)    
(0304)       //内部上拉外部下拉时，输入变输出后，口线立即变低
(0305) 	  //初始化SPI总线
(0306) 	  
(0307) 	  
(0308) 	  DDRB|=0x07;//PB0/1/2设为输出 
    0F235 B387      IN	R24,0x17
    0F236 6087      ORI	R24,7
    0F237 BB87      OUT	0x17,R24
(0309)       DelayMs(30);
    0F238 E10E      LDI	R16,0x1E
    0F239 E010      LDI	R17,0
    0F23A DE89      RCALL	_DelayMs
(0310)       SPCR = 0x00; //SPI必须先禁止，再使能，否则会使能不成功
    0F23B 2422      CLR	R2
    0F23C B82D      OUT	0x0D,R2
(0311) 	  DelayMs(30);
    0F23D E10E      LDI	R16,0x1E
    0F23E E010      LDI	R17,0
    0F23F DE84      RCALL	_DelayMs
(0312) 	  /*
(0313) 	  SPCR = 0x5d; //setup SPICLK=F0sc/16
(0314) 	  SPSR = 0x00; //setup SPI时钟频率不双倍
(0315) 	  SPCR = 0x5d; //setup SPICLK=F0sc/16
(0316) 	  */
(0317) 	  
(0318) 	  SPCR = 0x5f; //setup SPI SPICLK=Fosc/128
    0F240 E58F      LDI	R24,0x5F
    0F241 B98D      OUT	0x0D,R24
(0319) 	  SPSR = 0x01; //setup SPI SPI时钟频率双倍
    0F242 E081      LDI	R24,1
    0F243 B98E      OUT	0x0E,R24
(0320) 	  SPCR = 0x5f; //setup SPI SPICLK=Fosc/128
    0F244 E58F      LDI	R24,0x5F
    0F245 B98D      OUT	0x0D,R24
(0321) 	  
(0322) 	  address=0 ;
    0F246 E080      LDI	R24,0
    0F247 9380 0100 STS	address,R24
    0F249 9380 0101 STS	address+1,R24
    0F24B 9380 0102 STS	address+2,R24
    0F24D 9380 0103 STS	address+3,R24
(0323)       flash_bufferPoint=0; 
    0F24F 2422      CLR	R2
    0F250 2433      CLR	R3
    0F251 9230 02F0 STS	flash_bufferPoint+1,R3
    0F253 9220 02EF STS	flash_bufferPoint,R2
(0324)       UpdateFlag=0;
    0F255 9220 0104 STS	UpdateFlag,R2
(0325) 	  
(0326) 	  USBStart();
    0F257 940E F793 CALL	_USBStart
(0327) 	  
(0328) 	#if DBG   
(0329) 	  printf("Init374Device Begin\r\n");
(0330) 	#endif
(0331) 	  
(0332) 	 for(j=0;j<100;j++)	  //常亮3秒，等待PC机加载USB驱动，如是安装驱动，则不受超时限制，直到驱动安装完毕
    0F259 24AA      CLR	R10
    0F25A C012      RJMP	0xF26D
(0333) 	 {
(0334) 	  while(UsbReset==1)
(0335) 	   {
(0336) 	    if(UsbConfig == 1)
    0F25B 9180 0163 LDS	R24,UsbConfig
    0F25D 3081      CPI	R24,1
    0F25E F409      BNE	0xF260
(0337) 		 {
(0338) 		  break;
    0F25F C004      RJMP	0xF264
    0F260 9180 0164 LDS	R24,UsbReset
    0F262 3081      CPI	R24,1
    0F263 F3B9      BEQ	0xF25B
(0339) 		 }
(0340) 	   }
(0341) 	  if(UsbConfig == 1) 
    0F264 9180 0163 LDS	R24,UsbConfig
    0F266 3081      CPI	R24,1
    0F267 F409      BNE	0xF269
(0342) 	    {
(0343) 	     break; //等待USB驱动安装成功
    0F268 C007      RJMP	0xF270
(0344) 		}
(0345) 	  DelayMs(30); 
    0F269 E10E      LDI	R16,0x1E
    0F26A E010      LDI	R17,0
    0F26B DE58      RCALL	_DelayMs
    0F26C 94A3      INC	R10
    0F26D 2D8A      MOV	R24,R10
    0F26E 3684      CPI	R24,0x64
    0F26F F380      BCS	0xF260
(0346) 	  }
(0347) 	 
(0348) 
(0349) 	 if(j>=100)//在规定时间内没有加载驱动，说明地面回放仪没有连上电脑，则直接进入到采样状态
    0F270 2D8A      MOV	R24,R10
    0F271 3684      CPI	R24,0x64
    0F272 F008      BCS	0xF274
(0350) 	  {
(0351) 	     quit();
    0F273 DF8F      RCALL	_quit
(0352) 	  }
(0353) 	  
(0354) 	 
(0355) 	  #if DBG
(0356) 	  printf("Init374Device End\r\n");
(0357) 	  #endif
(0358) 	  
(0359) 	 
(0360) 	  #if DBG
(0361) 	  printf("UsbConfig OK\r\n");
(0362) 	  #endif
(0363)        
(0364) 	  UCSR0B = 0x00; //disable 
    0F274 2422      CLR	R2
    0F275 B82A      OUT	0x0A,R2
(0365) 	   
(0366) 	 TCCR3B = 0x00; //stop    
    0F276 9220 008A STS	0x8A,R2
(0367) 	 TCNT3H = 0x48; //16M,3s
    0F278 E488      LDI	R24,0x48
    0F279 9380 0089 STS	0x89,R24
(0368)       TCNT3L = 0xE5;
    0F27B EE85      LDI	R24,0xE5
    0F27C 9380 0088 STS	0x88,R24
(0369) 	ETIFR|=0x04; //清定时器3中断标志
    0F27E 9180 007C LDS	R24,0x7C
    0F280 6084      ORI	R24,4
    0F281 9380 007C STS	0x7C,R24
(0370) 	ETIMSK &= 0xfb;//关定时器3中断
    0F283 9180 007D LDS	R24,0x7D
    0F285 7F8B      ANDI	R24,0xFB
    0F286 9380 007D STS	0x7D,R24
(0371)  	TCCR3B = 0x05; //1024分频
    0F288 E085      LDI	R24,5
    0F289 9380 008A STS	0x8A,R24
(0372) 	ETIFR|=0x04; //清定时器3中断标志
    0F28B 9180 007C LDS	R24,0x7C
    0F28D 6084      ORI	R24,4
    0F28E 9380 007C STS	0x7C,R24
(0373) 	    
(0374) 	UpdateBegin=0;
    0F290 9220 016C STS	UpdateBegin,R2
    0F292 C079      RJMP	0xF30C
(0375) 	while( ((ETIFR&0x04)==0x00) && (UpdateBegin==0) )
(0376) 	{
(0377) 	 if((RxData.flag==1))//3秒内收到开始更新命令
    0F293 9180 016D LDS	R24,RxData
    0F295 3081      CPI	R24,1
    0F296 F009      BEQ	0xF298
    0F297 C074      RJMP	0xF30C
(0378) 	 {  
(0379) 	  if(RxData.buf[4]==0x01)
    0F298 9180 0173 LDS	R24,RxData+6
    0F29A 3081      CPI	R24,1
    0F29B F589      BNE	0xF2CD
(0380) 	   {
(0381) 	    		tx_data[0]=0xe7;  //帧头
    0F29C EE87      LDI	R24,0xE7
    0F29D 9380 01AF STS	tx_data,R24
(0382) 				tx_data[1]=0xe7; //帧头
    0F29F 9380 01B0 STS	tx_data+1,R24
(0383) 				tx_data[2]=0x00; //地址1
    0F2A1 2422      CLR	R2
    0F2A2 9220 01B1 STS	tx_data+2,R2
(0384) 				tx_data[3]=0x00;   //地址2
    0F2A4 9220 01B2 STS	tx_data+3,R2
(0385) 				tx_data[4]=RxData.buf[4]; //命令
    0F2A6 9020 0173 LDS	R2,RxData+6
    0F2A8 9220 01B3 STS	tx_data+4,R2
(0386) 				tx_data[5]=0x02; //数据长度低字节
    0F2AA E082      LDI	R24,2
    0F2AB 9380 01B4 STS	tx_data+5,R24
(0387) 				tx_data[6]=0x00; //数据长度高字节
    0F2AD 2422      CLR	R2
    0F2AE 9220 01B5 STS	tx_data+6,R2
(0388) 				tx_data[7]=0x01; 
    0F2B0 E081      LDI	R24,1
    0F2B1 9380 01B6 STS	tx_data+7,R24
(0389) 				tx_data[8]=0xe7; 
    0F2B3 EE87      LDI	R24,0xE7
    0F2B4 9380 01B7 STS	tx_data+8,R24
(0390) 				tx_data[9]=0x00; 
    0F2B6 9220 01B8 STS	tx_data+9,R2
(0391) 				tx_data[10]=0x00; 
    0F2B8 9220 01B9 STS	tx_data+10,R2
(0392) 				tx_data[11]=0x00; 
    0F2BA 9220 01BA STS	tx_data+11,R2
(0393) 				tx_data[12]=0x00; 
    0F2BC 9220 01BB STS	tx_data+12,R2
(0394) 				tx_data[13]=0x00; 
    0F2BE 9220 01BC STS	tx_data+13,R2
(0395) 				tx_data[14]=0x00; //校验
    0F2C0 9220 01BD STS	tx_data+14,R2
(0396) 				tx_data[15]=0x00; //校验
    0F2C2 9220 01BE STS	tx_data+15,R2
(0397)       			EP2Send(16, tx_data);
    0F2C4 EA2F      LDI	R18,0xAF
    0F2C5 E031      LDI	R19,1
    0F2C6 E100      LDI	R16,0x10
    0F2C7 940E F86B CALL	_EP2Send
(0398)  				UpdateBegin=1;
    0F2C9 E081      LDI	R24,1
    0F2CA 9380 016C STS	UpdateBegin,R24
(0399) 	   }  	
    0F2CC C03C      RJMP	0xF309
(0400) 	   else  //收到其它命令一律退出更新
(0401) 	   {
(0402) 	   		 TCCR3B = 0x00; //stop    
    0F2CD 2422      CLR	R2
    0F2CE 9220 008A STS	0x8A,R2
(0403) 			 ETIFR|=0x04; //清定时器3中断标志
    0F2D0 9180 007C LDS	R24,0x7C
    0F2D2 6084      ORI	R24,4
    0F2D3 9380 007C STS	0x7C,R24
(0404) 			 ETIMSK &= 0xfb;//关定时器3中断
    0F2D5 9180 007D LDS	R24,0x7D
    0F2D7 7F8B      ANDI	R24,0xFB
    0F2D8 9380 007D STS	0x7D,R24
(0405) 	
(0406) 	     		tx_data[0]=0xe7;  //帧头
    0F2DA EE87      LDI	R24,0xE7
    0F2DB 9380 01AF STS	tx_data,R24
(0407) 				tx_data[1]=0xe7; //帧头
    0F2DD 9380 01B0 STS	tx_data+1,R24
(0408) 				tx_data[2]=0x00; //地址1
    0F2DF 9220 01B1 STS	tx_data+2,R2
(0409) 				tx_data[3]=0x00;   //地址2
    0F2E1 9220 01B2 STS	tx_data+3,R2
(0410) 				tx_data[4]=RxData.buf[4]; //命令
    0F2E3 9020 0173 LDS	R2,RxData+6
    0F2E5 9220 01B3 STS	tx_data+4,R2
(0411) 				tx_data[5]=0x02; //数据长度低字节
    0F2E7 E082      LDI	R24,2
    0F2E8 9380 01B4 STS	tx_data+5,R24
(0412) 				tx_data[6]=0x00; //数据长度高字节
    0F2EA 2422      CLR	R2
    0F2EB 9220 01B5 STS	tx_data+6,R2
(0413) 				tx_data[7]=RxData.buf[4]; 
    0F2ED 9020 0173 LDS	R2,RxData+6
    0F2EF 9220 01B6 STS	tx_data+7,R2
(0414) 				tx_data[8]=0xe7; 
    0F2F1 EE87      LDI	R24,0xE7
    0F2F2 9380 01B7 STS	tx_data+8,R24
(0415) 				tx_data[9]=0x00; 
    0F2F4 2422      CLR	R2
    0F2F5 9220 01B8 STS	tx_data+9,R2
(0416) 				tx_data[10]=0x00; 
    0F2F7 9220 01B9 STS	tx_data+10,R2
(0417) 				tx_data[11]=0x00; 
    0F2F9 9220 01BA STS	tx_data+11,R2
(0418) 				tx_data[12]=0x00; 
    0F2FB 9220 01BB STS	tx_data+12,R2
(0419) 				tx_data[13]=0x00; 
    0F2FD 9220 01BC STS	tx_data+13,R2
(0420) 				tx_data[14]=0x00; //校验
    0F2FF 9220 01BD STS	tx_data+14,R2
(0421) 				tx_data[15]=0x00; //校验
    0F301 9220 01BE STS	tx_data+15,R2
(0422)       			EP2Send(16, tx_data);		
    0F303 EA2F      LDI	R18,0xAF
    0F304 E031      LDI	R19,1
    0F305 E100      LDI	R16,0x10
    0F306 940E F86B CALL	_EP2Send
(0423) 		 		quit();
    0F308 DEFA      RCALL	_quit
(0424) 	   } 
(0425) 	   RxData.flag=0;  
    0F309 2422      CLR	R2
    0F30A 9220 016D STS	RxData,R2
    0F30C 9020 007C LDS	R2,0x7C
    0F30E FC22      SBRC	R2,2
    0F30F C005      RJMP	0xF315
    0F310 9020 016C LDS	R2,UpdateBegin
    0F312 2022      TST	R2
    0F313 F409      BNE	0xF315
    0F314 CF7E      RJMP	0xF293
(0426) 	 }		 							
(0427) 	} 
(0428) 	
(0429) 	TCCR3B = 0x00; //stop    
    0F315 2422      CLR	R2
    0F316 9220 008A STS	0x8A,R2
(0430) 	ETIFR|=0x04; //清定时器3中断标志
    0F318 9180 007C LDS	R24,0x7C
    0F31A 6084      ORI	R24,4
    0F31B 9380 007C STS	0x7C,R24
(0431) 	ETIMSK &= 0xfb;//关定时器3中断
    0F31D 9180 007D LDS	R24,0x7D
    0F31F 7F8B      ANDI	R24,0xFB
    0F320 9380 007D STS	0x7D,R24
(0432) 	
(0433) 	if(UpdateBegin==0)//3秒内没收到开始更新命令，则直接跳到主程序
    0F322 9020 016C LDS	R2,UpdateBegin
    0F324 2022      TST	R2
    0F325 F409      BNE	0xF327
(0434) 	{
(0435) 	 quit();
    0F326 DEDC      RCALL	_quit
(0436) 	}  
(0437) 	   
(0438)     UpdateBegin=0;
    0F327 2422      CLR	R2
    0F328 9220 016C STS	UpdateBegin,R2
    0F32A C1A3      RJMP	0xF4CE
(0439) 	while(1)
(0440) 	{
(0441)  	  if(RxData.flag==1)//接收到了正常命令帧
    0F32B 9180 016D LDS	R24,RxData
    0F32D 3081      CPI	R24,1
    0F32E F009      BEQ	0xF330
    0F32F C19E      RJMP	0xF4CE
(0442)    	  {
(0443) 	 	 if(UpdateBegin>0)//接收主程序二进制数据
    0F330 E080      LDI	R24,0
    0F331 9020 016C LDS	R2,UpdateBegin
    0F333 1582      CP	R24,R2
    0F334 F008      BCS	0xF336
    0F335 C0BF      RJMP	0xF3F5
(0444)      	 { 	  
(0445) 		      SetTimer3();	 //每收到一字节就重新开始定时500ms，超时后回到待命状态
    0F336 DE37      RCALL	_SetTimer3
(0446) 			  
(0447) 		      flash_buf[DataReCn]=RxData.buf[4];//命令字节当数据字节
    0F337 EE8F      LDI	R24,0xEF
    0F338 E091      LDI	R25,1
    0F339 91E0 016A LDS	R30,DataReCn
    0F33B 91F0 016B LDS	R31,DataReCn+1
    0F33D 0FE8      ADD	R30,R24
    0F33E 1FF9      ADC	R31,R25
    0F33F 9020 0173 LDS	R2,RxData+6
    0F341 8220      ST	Z,R2
(0448) 			  DataReCn++;
    0F342 9180 016A LDS	R24,DataReCn
    0F344 9190 016B LDS	R25,DataReCn+1
    0F346 9601      ADIW	R24,1
    0F347 9390 016B STS	DataReCn+1,R25
    0F349 9380 016A STS	DataReCn,R24
(0449) 			  
(0450) 			   
(0451) 		 	 if(DataReCn==258)//2字节页索引，256字节页数据
    0F34B 3082      CPI	R24,2
    0F34C E0E1      LDI	R30,1
    0F34D 079E      CPC	R25,R30
    0F34E F009      BEQ	0xF350
    0F34F C17B      RJMP	0xF4CB
(0452) 		   	 {
(0453) 			   TCCR3B = 0x00; //stop  
    0F350 2422      CLR	R2
    0F351 9220 008A STS	0x8A,R2
(0454)   			   ETIMSK &= 0xfb;//关定时器3中断
    0F353 9180 007D LDS	R24,0x7D
    0F355 7F8B      ANDI	R24,0xFB
    0F356 9380 007D STS	0x7D,R24
(0455)   			   ETIFR|=0x04; //清定时器3中断标志 
    0F358 9180 007C LDS	R24,0x7C
    0F35A 6084      ORI	R24,4
    0F35B 9380 007C STS	0x7C,R24
(0456)   			   
(0457) 			   
(0458)   			   if(UpdateBegin==1)//如果是主控板页写准备了，则此时写入一页
    0F35D 9180 016C LDS	R24,UpdateBegin
    0F35F 3081      CPI	R24,1
    0F360 F009      BEQ	0xF362
    0F361 C05D      RJMP	0xF3BF
(0459) 				{
(0460)                   address=flash_buf[0]*256+flash_buf[1];  
    0F362 9120 01EF LDS	R18,flash_buf
    0F364 2733      CLR	R19
    0F365 E000      LDI	R16,0
    0F366 E011      LDI	R17,1
    0F367 940E F8A6 CALL	empy16s
    0F369 0118      MOVW	R2,R16
    0F36A 9040 01F0 LDS	R4,flash_buf+1
    0F36C 2455      CLR	R5
    0F36D 0C24      ADD	R2,R4
    0F36E 1C35      ADC	R3,R5
    0F36F 2444      CLR	R4
    0F370 FC37      SBRC	R3,7
    0F371 9440      COM	R4
    0F372 2455      CLR	R5
    0F373 FC47      SBRC	R4,7
    0F374 9450      COM	R5
    0F375 9230 0101 STS	address+1,R3
    0F377 9220 0100 STS	address,R2
    0F379 9250 0103 STS	address+3,R5
    0F37B 9240 0102 STS	address+2,R4
(0461) 			      address*=256;	 
    0F37D E040      LDI	R20,0
    0F37E E051      LDI	R21,1
    0F37F E060      LDI	R22,0
    0F380 E070      LDI	R23,0
    0F381 925A      ST	-Y,R5
    0F382 924A      ST	-Y,R4
    0F383 923A      ST	-Y,R3
    0F384 922A      ST	-Y,R2
    0F385 018A      MOVW	R16,R20
    0F386 019B      MOVW	R18,R22
    0F387 940E F8B6 CALL	empy32u|empy32s
    0F389 9310 0101 STS	address+1,R17
    0F38B 9300 0100 STS	address,R16
    0F38D 9330 0103 STS	address+3,R19
    0F38F 9320 0102 STS	address+2,R18
(0462) 				  
(0463) 			      if(address<0)
    0F391 E040      LDI	R20,0
    0F392 E050      LDI	R21,0
    0F393 E060      LDI	R22,0
    0F394 E070      LDI	R23,0
    0F395 1704      CP	R16,R20
    0F396 0715      CPC	R17,R21
    0F397 0726      CPC	R18,R22
    0F398 0737      CPC	R19,R23
    0F399 F44C      BGE	0xF3A3
(0464) 			          address=0;
    0F39A E080      LDI	R24,0
    0F39B 9380 0100 STS	address,R24
    0F39D 9380 0101 STS	address+1,R24
    0F39F 9380 0102 STS	address+2,R24
    0F3A1 9380 0103 STS	address+3,R24
(0465) 				 
(0466) 			     if(address>0xff00)//对应页索引为255，这是最后一页能写的页，目前限制固件大小为64K字节
    0F3A3 E040      LDI	R20,0
    0F3A4 EF5F      LDI	R21,0xFF
    0F3A5 E060      LDI	R22,0
    0F3A6 E070      LDI	R23,0
    0F3A7 9040 0102 LDS	R4,address+2
    0F3A9 9050 0103 LDS	R5,address+3
    0F3AB 9020 0100 LDS	R2,address
    0F3AD 9030 0101 LDS	R3,address+1
    0F3AF 1542      CP	R20,R2
    0F3B0 0553      CPC	R21,R3
    0F3B1 0564      CPC	R22,R4
    0F3B2 0575      CPC	R23,R5
    0F3B3 F454      BGE	0xF3BE
(0467) 			         address=0xff00;
    0F3B4 E080      LDI	R24,0
    0F3B5 9380 0100 STS	address,R24
    0F3B7 9380 0102 STS	address+2,R24
    0F3B9 9380 0103 STS	address+3,R24
    0F3BB EF8F      LDI	R24,0xFF
    0F3BC 9380 0101 STS	address+1,R24
(0468) 				
(0469) 		          write_one_page();	//约20ms    
    0F3BE DE01      RCALL	_write_one_page
(0470) 			    }   
(0471) 				
(0472) 			   UpdateBegin=0;//一页写完了，下一页又从页写准备开始
    0F3BF 2422      CLR	R2
    0F3C0 9220 016C STS	UpdateBegin,R2
(0473) 			   
(0474) 			   crc16(flash_buf,258);//12ms
    0F3C2 E022      LDI	R18,2
    0F3C3 E031      LDI	R19,1
    0F3C4 EE0F      LDI	R16,0xEF
    0F3C5 E011      LDI	R17,1
    0F3C6 DD3C      RCALL	_crc16
(0475) 		        		    
(0476) 				tx_data[0]=0xe7;  //帧头
    0F3C7 EE87      LDI	R24,0xE7
    0F3C8 9380 01AF STS	tx_data,R24
(0477) 				tx_data[1]=0xe7; //帧头
    0F3CA 9380 01B0 STS	tx_data+1,R24
(0478) 				tx_data[2]=0x00; //地址1
    0F3CC 2422      CLR	R2
    0F3CD 9220 01B1 STS	tx_data+2,R2
(0479) 				tx_data[3]=0x00;   //地址2
    0F3CF 9220 01B2 STS	tx_data+3,R2
(0480) 				tx_data[4]=02; //命令，暂用页写准备这个命令，上位机不关心这个返回字节
    0F3D1 E082      LDI	R24,2
    0F3D2 9380 01B3 STS	tx_data+4,R24
(0481) 				tx_data[5]=0x02; //数据长度低字节
    0F3D4 9380 01B4 STS	tx_data+5,R24
(0482) 				tx_data[6]=0x00; //数据长度高字节
    0F3D6 9220 01B5 STS	tx_data+6,R2
(0483) 				tx_data[7]=crc16lo; 
    0F3D8 9020 0168 LDS	R2,crc16lo
    0F3DA 9220 01B6 STS	tx_data+7,R2
(0484) 				tx_data[8]=crc16hi; 
    0F3DC 9020 0169 LDS	R2,crc16hi
    0F3DE 9220 01B7 STS	tx_data+8,R2
(0485) 				tx_data[9]=0x00; 
    0F3E0 2422      CLR	R2
    0F3E1 9220 01B8 STS	tx_data+9,R2
(0486) 				tx_data[10]=0x00; 
    0F3E3 9220 01B9 STS	tx_data+10,R2
(0487) 				tx_data[11]=0x00; 
    0F3E5 9220 01BA STS	tx_data+11,R2
(0488) 				tx_data[12]=0x00; 
    0F3E7 9220 01BB STS	tx_data+12,R2
(0489) 				tx_data[13]=0x00; 
    0F3E9 9220 01BC STS	tx_data+13,R2
(0490) 				tx_data[14]=0x00; //校验
    0F3EB 9220 01BD STS	tx_data+14,R2
(0491) 				tx_data[15]=0x00; //校验
    0F3ED 9220 01BE STS	tx_data+15,R2
(0492)       			EP2Send(16, tx_data);	 //将这一页的校验码上传给上位机，上位机判断后决定是继续烧写一页还是重烧这一页	 		        
    0F3EF EA2F      LDI	R18,0xAF
    0F3F0 E031      LDI	R19,1
    0F3F1 E100      LDI	R16,0x10
    0F3F2 940E F86B CALL	_EP2Send
(0493) 			 }	 	 
(0494) 	     }
    0F3F4 C0D6      RJMP	0xF4CB
(0495)   		 else//若不是数据状态，则进入以下各个命令的子语句
(0496) 		 {
(0497)     		switch(RxData.buf[4]) 
    0F3F5 90A0 0173 LDS	R10,RxData+6
    0F3F7 24BB      CLR	R11
    0F3F8 20AA      TST	R10
    0F3F9 F411      BNE	0xF3FC
    0F3FA 20BB      TST	R11
    0F3FB F081      BEQ	0xF40C
    0F3FC 01C5      MOVW	R24,R10
    0F3FD 3081      CPI	R24,1
    0F3FE E0E0      LDI	R30,0
    0F3FF 079E      CPC	R25,R30
    0F400 F1B9      BEQ	0xF438
    0F401 3082      CPI	R24,2
    0F402 E0E0      LDI	R30,0
    0F403 079E      CPC	R25,R30
    0F404 F409      BNE	0xF406
    0F405 C060      RJMP	0xF466
    0F406 3083      CPI	R24,3
    0F407 E0E0      LDI	R30,0
    0F408 079E      CPC	R25,R30
    0F409 F409      BNE	0xF40B
    0F40A C092      RJMP	0xF49D
    0F40B C0BF      RJMP	0xF4CB
(0498)      		{		
(0499) 			  case 0x00://地面仪版本
(0500) 				tx_data[0]=0xe7;  //帧头
    0F40C EE87      LDI	R24,0xE7
    0F40D 9380 01AF STS	tx_data,R24
(0501) 				tx_data[1]=0xe7; //帧头
    0F40F 9380 01B0 STS	tx_data+1,R24
(0502) 				tx_data[2]=0x00; //地址1
    0F411 2422      CLR	R2
    0F412 9220 01B1 STS	tx_data+2,R2
(0503) 				tx_data[3]=0x00;   //地址2
    0F414 9220 01B2 STS	tx_data+3,R2
(0504) 				tx_data[4]=RxData.buf[4]; //命令
    0F416 9020 0173 LDS	R2,RxData+6
    0F418 9220 01B3 STS	tx_data+4,R2
(0505) 				tx_data[5]=0x01; //数据长度低字节
    0F41A E081      LDI	R24,1
    0F41B 9380 01B4 STS	tx_data+5,R24
(0506) 				tx_data[6]=0x00; //数据长度高字节
    0F41D 2422      CLR	R2
    0F41E 9220 01B5 STS	tx_data+6,R2
(0507) 				tx_data[7]=0x00; 
    0F420 9220 01B6 STS	tx_data+7,R2
(0508) 				tx_data[8]=0x00; 
    0F422 9220 01B7 STS	tx_data+8,R2
(0509) 				tx_data[9]=0x00; 
    0F424 9220 01B8 STS	tx_data+9,R2
(0510) 				tx_data[10]=0x00; 
    0F426 9220 01B9 STS	tx_data+10,R2
(0511) 				tx_data[11]=0x00; 
    0F428 9220 01BA STS	tx_data+11,R2
(0512) 				tx_data[12]=0x00; 
    0F42A 9220 01BB STS	tx_data+12,R2
(0513) 				tx_data[13]=0x00; 
    0F42C 9220 01BC STS	tx_data+13,R2
(0514) 				tx_data[14]=0x00; //校验
    0F42E 9220 01BD STS	tx_data+14,R2
(0515) 				tx_data[15]=0x00; //校验
    0F430 9220 01BE STS	tx_data+15,R2
(0516)       			EP2Send(16, tx_data);	
    0F432 EA2F      LDI	R18,0xAF
    0F433 E031      LDI	R19,1
    0F434 E100      LDI	R16,0x10
    0F435 940E F86B CALL	_EP2Send
(0517) 				break;
    0F437 C093      RJMP	0xF4CB
(0518) 				
(0519) 			   case 0x01://地面仪握手，进入更新状态  			      			       
(0520) 	  			tx_data[0]=0xe7;  //帧头
    0F438 EE87      LDI	R24,0xE7
    0F439 9380 01AF STS	tx_data,R24
(0521) 				tx_data[1]=0xe7; //帧头
    0F43B 9380 01B0 STS	tx_data+1,R24
(0522) 				tx_data[2]=0x00; //地址1
    0F43D 2422      CLR	R2
    0F43E 9220 01B1 STS	tx_data+2,R2
(0523) 				tx_data[3]=0x00;   //地址2
    0F440 9220 01B2 STS	tx_data+3,R2
(0524) 				tx_data[4]=RxData.buf[4]; //命令
    0F442 9020 0173 LDS	R2,RxData+6
    0F444 9220 01B3 STS	tx_data+4,R2
(0525) 				tx_data[5]=0x02; //数据长度低字节
    0F446 E082      LDI	R24,2
    0F447 9380 01B4 STS	tx_data+5,R24
(0526) 				tx_data[6]=0x00; //数据长度高字节
    0F449 2422      CLR	R2
    0F44A 9220 01B5 STS	tx_data+6,R2
(0527) 				tx_data[7]=0x01; 
    0F44C E081      LDI	R24,1
    0F44D 9380 01B6 STS	tx_data+7,R24
(0528) 				tx_data[8]=0xe7; 
    0F44F EE87      LDI	R24,0xE7
    0F450 9380 01B7 STS	tx_data+8,R24
(0529) 				tx_data[9]=0x00; 
    0F452 9220 01B8 STS	tx_data+9,R2
(0530) 				tx_data[10]=0x00; 
    0F454 9220 01B9 STS	tx_data+10,R2
(0531) 				tx_data[11]=0x00; 
    0F456 9220 01BA STS	tx_data+11,R2
(0532) 				tx_data[12]=0x00; 
    0F458 9220 01BB STS	tx_data+12,R2
(0533) 				tx_data[13]=0x00; 
    0F45A 9220 01BC STS	tx_data+13,R2
(0534) 				tx_data[14]=0x00; //校验
    0F45C 9220 01BD STS	tx_data+14,R2
(0535) 				tx_data[15]=0x00; //校验
    0F45E 9220 01BE STS	tx_data+15,R2
(0536)       			EP2Send(16, tx_data);
    0F460 EA2F      LDI	R18,0xAF
    0F461 E031      LDI	R19,1
    0F462 E100      LDI	R16,0x10
    0F463 940E F86B CALL	_EP2Send
(0537) 				break;
    0F465 C065      RJMP	0xF4CB
(0538) 						 		   			
(0539) 			case 0x02://地面仪页写准备		
(0540) 				UpdateBegin=1;//页写准备，从页索引0开始烧写，最大页索引255，共64K字节程序空间
    0F466 E081      LDI	R24,1
    0F467 9380 016C STS	UpdateBegin,R24
(0541) 				DataReCn=0;    
    0F469 2422      CLR	R2
    0F46A 2433      CLR	R3
    0F46B 9230 016B STS	DataReCn+1,R3
    0F46D 9220 016A STS	DataReCn,R2
(0542) 				SetTimer3();//开始计时，每500ms内至少要有一个字节收到
    0F46F DCFE      RCALL	_SetTimer3
(0543) 				
(0544) 				tx_data[0]=0xe7;  //帧头
    0F470 EE87      LDI	R24,0xE7
    0F471 9380 01AF STS	tx_data,R24
(0545) 				tx_data[1]=0xe7; //帧头
    0F473 9380 01B0 STS	tx_data+1,R24
(0546) 				tx_data[2]=0x00; //地址1
    0F475 2422      CLR	R2
    0F476 9220 01B1 STS	tx_data+2,R2
(0547) 				tx_data[3]=0x00;   //地址2
    0F478 9220 01B2 STS	tx_data+3,R2
(0548) 				tx_data[4]=RxData.buf[4]; //命令
    0F47A 9020 0173 LDS	R2,RxData+6
    0F47C 9220 01B3 STS	tx_data+4,R2
(0549) 				tx_data[5]=0x02; //数据长度低字节
    0F47E E082      LDI	R24,2
    0F47F 9380 01B4 STS	tx_data+5,R24
(0550) 				tx_data[6]=0x00; //数据长度高字节
    0F481 2422      CLR	R2
    0F482 9220 01B5 STS	tx_data+6,R2
(0551) 				tx_data[7]=0x02; 
    0F484 9380 01B6 STS	tx_data+7,R24
(0552) 				tx_data[8]=0xe7; 
    0F486 EE87      LDI	R24,0xE7
    0F487 9380 01B7 STS	tx_data+8,R24
(0553) 				tx_data[9]=0x00; 
    0F489 9220 01B8 STS	tx_data+9,R2
(0554) 				tx_data[10]=0x00; 
    0F48B 9220 01B9 STS	tx_data+10,R2
(0555) 				tx_data[11]=0x00; 
    0F48D 9220 01BA STS	tx_data+11,R2
(0556) 				tx_data[12]=0x00; 
    0F48F 9220 01BB STS	tx_data+12,R2
(0557) 				tx_data[13]=0x00; 
    0F491 9220 01BC STS	tx_data+13,R2
(0558) 				tx_data[14]=0x00; //校验
    0F493 9220 01BD STS	tx_data+14,R2
(0559) 				tx_data[15]=0x00; //校验
    0F495 9220 01BE STS	tx_data+15,R2
(0560)       			EP2Send(16, tx_data);			
    0F497 EA2F      LDI	R18,0xAF
    0F498 E031      LDI	R19,1
    0F499 E100      LDI	R16,0x10
    0F49A 940E F86B CALL	_EP2Send
(0561) 				break;
    0F49C C02E      RJMP	0xF4CB
(0562) 											
(0563) 				
(0564) 			case 0x03://地面仪退出更新状态，运行正常程序
(0565) 				tx_data[0]=0xe7;  //帧头
    0F49D EE87      LDI	R24,0xE7
    0F49E 9380 01AF STS	tx_data,R24
(0566) 				tx_data[1]=0xe7; //帧头
    0F4A0 9380 01B0 STS	tx_data+1,R24
(0567) 				tx_data[2]=0x00; //地址1
    0F4A2 2422      CLR	R2
    0F4A3 9220 01B1 STS	tx_data+2,R2
(0568) 				tx_data[3]=0x00;   //地址2
    0F4A5 9220 01B2 STS	tx_data+3,R2
(0569) 				tx_data[4]=RxData.buf[4]; //命令
    0F4A7 9020 0173 LDS	R2,RxData+6
    0F4A9 9220 01B3 STS	tx_data+4,R2
(0570) 				tx_data[5]=0x02; //数据长度低字节
    0F4AB E082      LDI	R24,2
    0F4AC 9380 01B4 STS	tx_data+5,R24
(0571) 				tx_data[6]=0x00; //数据长度高字节
    0F4AE 2422      CLR	R2
    0F4AF 9220 01B5 STS	tx_data+6,R2
(0572) 				tx_data[7]=0x03; 
    0F4B1 E083      LDI	R24,3
    0F4B2 9380 01B6 STS	tx_data+7,R24
(0573) 				tx_data[8]=0xe7; 
    0F4B4 EE87      LDI	R24,0xE7
    0F4B5 9380 01B7 STS	tx_data+8,R24
(0574) 				tx_data[9]=0x00; 
    0F4B7 9220 01B8 STS	tx_data+9,R2
(0575) 				tx_data[10]=0x00; 
    0F4B9 9220 01B9 STS	tx_data+10,R2
(0576) 				tx_data[11]=0x00; 
    0F4BB 9220 01BA STS	tx_data+11,R2
(0577) 				tx_data[12]=0x00; 
    0F4BD 9220 01BB STS	tx_data+12,R2
(0578) 				tx_data[13]=0x00; 
    0F4BF 9220 01BC STS	tx_data+13,R2
(0579) 				tx_data[14]=0x00; //校验
    0F4C1 9220 01BD STS	tx_data+14,R2
(0580) 				tx_data[15]=0x00; //校验
    0F4C3 9220 01BE STS	tx_data+15,R2
(0581)       			EP2Send(16, tx_data);	
    0F4C5 EA2F      LDI	R18,0xAF
    0F4C6 E031      LDI	R19,1
    0F4C7 E100      LDI	R16,0x10
    0F4C8 940E F86B CALL	_EP2Send
(0582) 				 quit();
    0F4CA DD38      RCALL	_quit
(0583) 				break;
(0584) 
(0585) 				default:
(0586) 				break;
(0587) 	  	    }//switch
(0588) 	     }//UpdateBegin
(0589) 		 RxData.flag=0;
    0F4CB 2422      CLR	R2
    0F4CC 9220 016D STS	RxData,R2
    0F4CE CE5C      RJMP	0xF32B
    0F4CF 9508      RET
_int6_isr:
  SetupReqBuf          --> Y,+2
  i                    --> Y,+3
  k                    --> Y,+3
  l                    --> R10
  m                    --> R10
  s                    --> R20
    0F4D0 920A      ST	-Y,R0
    0F4D1 921A      ST	-Y,R1
    0F4D2 922A      ST	-Y,R2
    0F4D3 923A      ST	-Y,R3
    0F4D4 924A      ST	-Y,R4
    0F4D5 925A      ST	-Y,R5
    0F4D6 926A      ST	-Y,R6
    0F4D7 927A      ST	-Y,R7
    0F4D8 928A      ST	-Y,R8
    0F4D9 929A      ST	-Y,R9
    0F4DA 930A      ST	-Y,R16
    0F4DB 931A      ST	-Y,R17
    0F4DC 932A      ST	-Y,R18
    0F4DD 933A      ST	-Y,R19
    0F4DE 938A      ST	-Y,R24
    0F4DF 939A      ST	-Y,R25
    0F4E0 93AA      ST	-Y,R26
    0F4E1 93BA      ST	-Y,R27
    0F4E2 93EA      ST	-Y,R30
    0F4E3 93FA      ST	-Y,R31
    0F4E4 B60F      IN	R0,0x3F
    0F4E5 920A      ST	-Y,R0
    0F4E6 940E F905 CALL	push_xgsetF00C
    0F4E8 972A      SBIW	R28,0xA
FILE: D:\chen\Core\FirmWare_CT\DMX_MCUBootLoader(20170226_ZKY3_V20）\DEVICE.C
(0001) /* CH374芯片 应用层 V1.0 */
(0002) /* USB设备,模拟CH372或CH375的TEST程序与计算机通讯 */
(0003) 
(0004) #include	"HAL.H"			// 其它单片机需修改HAL*硬件抽象层的几个文件
(0005)  
(0006) typedef struct RX
(0007) {
(0008)  unsigned char flag;
(0009)  unsigned char len;
(0010)  unsigned char buf[64];
(0011) };
(0012) extern struct RX RxData;
(0013) 
(0014) unsigned char EP2SendBusy=0;
(0015) 
(0016) // 设备描述符
(0017) const	UINT8C	MyDevDescr[] = {0x12, 0x01, 0x10, 0x01,
(0018) 								0xFF, 0x80, 0x37, 0x08,
(0019) 								//0x15, 0x38, 0x01, 0x28,  // 厂商ID和产品ID
(0020) 								0x48, 0x43, 0x37, 0x55,  // 厂商ID和产品ID
(0021) 								0x00, 0x01, 0x01, 0x02,
(0022) 								0x00,  0x01 };
(0023) // 配置描述符
(0024) const	UINT8C	MyCfgDescr[] = { 0x09, 0x02, 0x27, 0x00, 0x01, 0x01, 0x00, 0x80, 0x32,
(0025) 								 0x09, 0x04, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x37, 0x00,
(0026) 								 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00,
(0027) 								 0x07, 0x05, 0x02, 0x02, 0x40, 0x00, 0x00,
(0028) 								 0x07, 0x05, 0x81, 0x03, 0x08, 0x00, 0x00 };
(0029) // 语言描述符
(0030) const	UINT8C	MyLangDescr[] = { 0x04, 0x03, 0x09, 0x04 };
(0031) 
(0032) // 厂家信息
(0033) const	UINT8C	MyManuInfo[] = { 0x0E, 0x03, 'G', 0, 'Z', 0, 'T', 0, 'S', 0, 'N', 0, 'Y', 0 };
(0034) // 产品信息
(0035) //const	UINT8C	MyProdInfo[] = { 0x16, 0x03, 'S', 0, 'H', 0, 'Y', 0, '-', 0, '1', 0 , ' ', 0, 'V', 0 , '1', 0 , '.', 0 , '0', 0 };
(0036) const	UINT8C	MyProdInfo[] = { 0x12, 0x03, 'T', 0, 'S', 0, 'N', 0, 'Y', 0, '-', 0 , '1', 0 , '.', 0 , '0', 0  };
(0037) 
(0038) void	USB_DeviceInterrupt( void );  // USB设备中断服务程序
(0039) void	Init374Device( void );  // 初始化USB设备
(0040) void USBStart(void);
(0041) unsigned char	UsbConfig = 0,UsbReset = 0;	// USB配置标志
(0042) 
(0043) 
(0044) #pragma interrupt_handler int6_isr:iv_INT6
(0045) void int6_isr(void)
(0046) {
(0047)     unsigned int k;
(0048) 	UINT8	s,l,i,m=0;
    0F4E9 24AA      CLR	R10
(0049) 	static	UINT8	SetupReq, SetupLen;
(0050) 	static	PUINT8	pDescr;
(0051) 	
(0052) 	s = Read374Byte( REG_INTER_FLAG );  // 获取中断状态
    0F4EA E009      LDI	R16,0x9
    0F4EB 940E F7C3 CALL	_Read374Byte
    0F4ED 2F40      MOV	R20,R16
(0053) 
(0054)     if(!(s & BIT_IF_INTER_FLAG))  //0x0f
    0F4EE 2F84      MOV	R24,R20
    0F4EF 708F      ANDI	R24,0xF
    0F4F0 F409      BNE	0xF4F2
(0055) 	    return;	    
    0F4F1 C267      RJMP	0xF759
(0056) 	
(0057) 	if ( s & BIT_IF_BUS_RESET )    //0x02
    0F4F2 FF41      SBRS	R20,1
    0F4F3 C018      RJMP	0xF50C
(0058) 	{  // USB总线复位
(0059) 	    UsbReset = 1;
    0F4F4 E081      LDI	R24,1
    0F4F5 9380 0164 STS	UsbReset,R24
(0060) 		Write374Byte( REG_USB_ADDR, 0x00 );  // 清USB设备地址
    0F4F7 2722      CLR	R18
    0F4F8 E008      LDI	R16,0x8
    0F4F9 940E F7D6 CALL	_Write374Byte
(0061) 		Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_NAK( 0 ) );
    0F4FB E02E      LDI	R18,0xE
    0F4FC E00C      LDI	R16,0xC
    0F4FD 940E F7D6 CALL	_Write374Byte
(0062) 		Write374Byte( REG_USB_ENDP1, M_SET_EP1_TRAN_NAK( 0 ) );
    0F4FF E02E      LDI	R18,0xE
    0F500 E00D      LDI	R16,0xD
    0F501 940E F7D6 CALL	_Write374Byte
(0063) 		Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_NAK( 0 ) );
    0F503 E022      LDI	R18,2
    0F504 E00E      LDI	R16,0xE
    0F505 940E F7D6 CALL	_Write374Byte
(0064) 		Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_BUS_RESET );  // 清中断标志
    0F507 E122      LDI	R18,0x12
    0F508 E009      LDI	R16,0x9
    0F509 940E F7D6 CALL	_Write374Byte
(0065) 	}
    0F50B C24D      RJMP	0xF759
(0066) 	else if ( s & BIT_IF_TRANSFER )  //0x01
    0F50C FF40      SBRS	R20,0
    0F50D C230      RJMP	0xF73E
(0067) 	{  // USB传输
(0068) 		s = Read374Byte( REG_USB_STATUS );  //USB状态, 只读  REG_USB_STATUS=0x0a
    0F50E E00A      LDI	R16,0xA
    0F50F 940E F7C3 CALL	_Read374Byte
    0F511 2F40      MOV	R20,R16
(0069) 		 //printf("BIT_IF_TRANSFER s=%x\r\n",s);
(0070) 		switch( s & BIT_STAT_PID_ENDP )   //USB传输的事务和端点号：BIT_STAT_PID_ENDP=0x0f
    0F512 2F64      MOV	R22,R20
    0F513 2777      CLR	R23
    0F514 706F      ANDI	R22,0xF
    0F515 7070      ANDI	R23,0
    0F516 3060      CPI	R22,0
    0F517 0767      CPC	R22,R23
    0F518 F409      BNE	0xF51A
    0F519 C213      RJMP	0xF72D
    0F51A 3062      CPI	R22,2
    0F51B E0E0      LDI	R30,0
    0F51C 077E      CPC	R23,R30
    0F51D F0B9      BEQ	0xF535
    0F51E 3060      CPI	R22,0
    0F51F E0E0      LDI	R30,0
    0F520 077E      CPC	R23,R30
    0F521 F40C      BGE	0xF523
    0F522 C216      RJMP	0xF739
    0F523 3068      CPI	R22,0x8
    0F524 E0E0      LDI	R30,0
    0F525 077E      CPC	R23,R30
    0F526 F409      BNE	0xF528
    0F527 C1BA      RJMP	0xF6E2
    0F528 3069      CPI	R22,0x9
    0F529 E0E0      LDI	R30,0
    0F52A 077E      CPC	R23,R30
    0F52B F171      BEQ	0xF55A
    0F52C 306A      CPI	R22,0xA
    0F52D E0E0      LDI	R30,0
    0F52E 077E      CPC	R23,R30
    0F52F F0D1      BEQ	0xF54A
    0F530 306C      CPI	R22,0xC
    0F531 E0E0      LDI	R30,0
    0F532 077E      CPC	R23,R30
    0F533 F199      BEQ	0xF567
    0F534 C204      RJMP	0xF739
(0071) 		{  // USB设备中断状态
(0072) 			case USB_INT_EP2_OUT:  //USB端点2的OUT  USB_INT_EP2_OUT=0x02
(0073) 			 {  
(0074) 			   // 批量端点下传成功 
(0075) 				//if ( s & BIT_STAT_TOG_MATCH ) //0x10;
(0076) 				{   RxData.flag=0;
    0F535 2422      CLR	R2
    0F536 9220 016D STS	RxData,R2
(0077) 					RxData.len = Read374Byte( REG_USB_LENGTH );
    0F538 E00B      LDI	R16,0xB
    0F539 940E F7C3 CALL	_Read374Byte
    0F53B 2EA0      MOV	R10,R16
    0F53C 92A0 016E STS	RxData+1,R10
(0078) 					Read374Block( RAM_ENDP2_RECV,RxData.len,RxData.buf );
    0F53E E68F      LDI	R24,0x6F
    0F53F E091      LDI	R25,1
    0F540 8399      STD	Y+1,R25
    0F541 8388      ST	Y,R24
    0F542 2D2A      MOV	R18,R10
    0F543 EC00      LDI	R16,0xC0
    0F544 940E F7E7 CALL	_Read374Block
(0079)                     RxData.flag=1;
    0F546 E081      LDI	R24,1
    0F547 9380 016D STS	RxData,R24
(0080) 					//printf("USB_INT_EP2_OUT len=%x\r\n",RxData.len);
(0081) 		        }
(0082) 				break;
    0F549 C1EF      RJMP	0xF739
(0083) 			}
(0084) 			case USB_INT_EP2_IN:  //USB_INT_EP2_IN=0x0a, USB端点2的IN 
(0085) 			{  // 批量端点上传成功,未处理
(0086) 				Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_NAK( Read374Byte( REG_USB_ENDP2 ) ) ^ BIT_EP2_TRAN_TOG );
    0F54A E00E      LDI	R16,0xE
    0F54B 940E F7C3 CALL	_Read374Byte
    0F54D 2F60      MOV	R22,R16
    0F54E E480      LDI	R24,0x40
    0F54F 2F26      MOV	R18,R22
    0F550 7F2C      ANDI	R18,0xFC
    0F551 6022      ORI	R18,2
    0F552 2728      EOR	R18,R24
    0F553 E00E      LDI	R16,0xE
    0F554 940E F7D6 CALL	_Write374Byte
(0087) 				EP2SendBusy=0;
    0F556 2422      CLR	R2
    0F557 9220 0105 STS	EP2SendBusy,R2
(0088) 				//printf("USB_INT_EP2_IN\r\n");
(0089) 				break;
    0F559 C1DF      RJMP	0xF739
(0090) 			}
(0091) 			case USB_INT_EP1_IN:   // 0x09,USB端点1的IN 
(0092) 			{  // 中断端点上传成功,未处理
(0093) 				Write374Byte( REG_USB_ENDP1, M_SET_EP1_TRAN_NAK( Read374Byte( REG_USB_ENDP1 ) ) ^ BIT_EP1_TRAN_TOG );
    0F55A E00D      LDI	R16,0xD
    0F55B 940E F7C3 CALL	_Read374Byte
    0F55D 2F60      MOV	R22,R16
    0F55E E480      LDI	R24,0x40
    0F55F 2F26      MOV	R18,R22
    0F560 7F20      ANDI	R18,0xF0
    0F561 602E      ORI	R18,0xE
    0F562 2728      EOR	R18,R24
    0F563 E00D      LDI	R16,0xD
    0F564 940E F7D6 CALL	_Write374Byte
(0094) 				break;
    0F566 C1D2      RJMP	0xF739
(0095) 			}
(0096) 			case USB_INT_EP0_SETUP:    //USB_INT_EP0_SETUP=0x0C	USB端点0的SETUP 
(0097) 			{  // 控制传输
(0098) 				USB_SETUP_REQ	SetupReqBuf;
(0099) 				
(0100) 				l = Read374Byte( REG_USB_LENGTH );
    0F567 E00B      LDI	R16,0xB
    0F568 940E F7C3 CALL	_Read374Byte
    0F56A 2EA0      MOV	R10,R16
(0101) 				if ( l == sizeof( USB_SETUP_REQ ) ) 
    0F56B 3008      CPI	R16,0x8
    0F56C F009      BEQ	0xF56E
    0F56D C14E      RJMP	0xF6BC
(0102) 				{
(0103) 					Read374Block( RAM_ENDP0_RECV, l, (PUINT8)&SetupReqBuf );
    0F56E 01CE      MOVW	R24,R28
    0F56F 9602      ADIW	R24,2
    0F570 8399      STD	Y+1,R25
    0F571 8388      ST	Y,R24
    0F572 2D2A      MOV	R18,R10
    0F573 E208      LDI	R16,0x28
    0F574 940E F7E7 CALL	_Read374Block
(0104) 					SetupLen = SetupReqBuf.wLengthL;
    0F576 8428      LDD	R2,Y+8
    0F577 9220 02F2 STS	DEVICE.C:SetupLen,R2
(0105) 					if ( SetupReqBuf.wLengthH || SetupLen > 0x7F ) SetupLen = 0x7F;  // 限制总长度
    0F579 8429      LDD	R2,Y+9
    0F57A 2022      TST	R2
    0F57B F429      BNE	0xF581
    0F57C E78F      LDI	R24,0x7F
    0F57D 9020 02F2 LDS	R2,DEVICE.C:SetupLen
    0F57F 1582      CP	R24,R2
    0F580 F418      BCC	0xF584
    0F581 E78F      LDI	R24,0x7F
    0F582 9380 02F2 STS	DEVICE.C:SetupLen,R24
(0106) 					l = 0;  // 默认为成功并且上传0长度
    0F584 24AA      CLR	R10
(0107) 					
(0108) 					/*if ( ( SetupReqBuf.bType & DEF_USB_REQ_TYPE ) != DEF_USB_REQ_STAND ) 
(0109) 					{  // 只支持标准请求 
(0110) 						l = 0xFF;  // 操作失败
(0111) 					}
(0112) 					else */
(0113) 					{  // 标准请求
(0114) 						SetupReq = SetupReqBuf.bReq;  // 请求码
    0F585 802B      LDD	R2,Y+3
    0F586 9220 02F1 STS	DEVICE.C:SetupReq,R2
(0115) 						//printf("SetupReq:%x\r\n",SetupReq);
(0116) 						
(0117) 						switch( SetupReq ) 
    0F588 2D62      MOV	R22,R2
    0F589 2777      CLR	R23
    0F58A 3060      CPI	R22,0
    0F58B 0767      CPC	R22,R23
    0F58C F409      BNE	0xF58E
    0F58D C114      RJMP	0xF6A2
    0F58E 3061      CPI	R22,1
    0F58F E0E0      LDI	R30,0
    0F590 077E      CPC	R23,R30
    0F591 F409      BNE	0xF593
    0F592 C0B8      RJMP	0xF64B
    0F593 3065      CPI	R22,5
    0F594 E0E0      LDI	R30,0
    0F595 077E      CPC	R23,R30
    0F596 F409      BNE	0xF598
    0F597 C09E      RJMP	0xF636
    0F598 3066      CPI	R22,6
    0F599 E0E0      LDI	R30,0
    0F59A 077E      CPC	R23,R30
    0F59B F0D1      BEQ	0xF5B6
    0F59C 3068      CPI	R22,0x8
    0F59D E0E0      LDI	R30,0
    0F59E 077E      CPC	R23,R30
    0F59F F409      BNE	0xF5A1
    0F5A0 C099      RJMP	0xF63A
    0F5A1 3069      CPI	R22,0x9
    0F5A2 E0E0      LDI	R30,0
    0F5A3 077E      CPC	R23,R30
    0F5A4 F409      BNE	0xF5A6
    0F5A5 C0A1      RJMP	0xF647
    0F5A6 306A      CPI	R22,0xA
    0F5A7 E0E0      LDI	R30,0
    0F5A8 077E      CPC	R23,R30
    0F5A9 F409      BNE	0xF5AB
    0F5AA C0EC      RJMP	0xF697
    0F5AB 3060      CPI	R22,0
    0F5AC E0E0      LDI	R30,0
    0F5AD 077E      CPC	R23,R30
    0F5AE F40C      BGE	0xF5B0
    0F5AF C109      RJMP	0xF6B9
    0F5B0 3F6E      CPI	R22,0xFE
    0F5B1 E0E0      LDI	R30,0
    0F5B2 077E      CPC	R23,R30
    0F5B3 F409      BNE	0xF5B5
    0F5B4 C0FF      RJMP	0xF6B4
    0F5B5 C103      RJMP	0xF6B9
(0118) 						{   
(0119) 							case DEF_USB_GET_DESCR:    //USB接收描述；DEF_USB_GET_DESCR=0x06
(0120) 							    switch( SetupReqBuf.wValueH ) 
    0F5B6 816D      LDD	R22,Y+5
    0F5B7 2777      CLR	R23
    0F5B8 3061      CPI	R22,1
    0F5B9 E0E0      LDI	R30,0
    0F5BA 077E      CPC	R23,R30
    0F5BB F049      BEQ	0xF5C5
    0F5BC 3062      CPI	R22,2
    0F5BD E0E0      LDI	R30,0
    0F5BE 077E      CPC	R23,R30
    0F5BF F071      BEQ	0xF5CE
    0F5C0 3063      CPI	R22,3
    0F5C1 E0E0      LDI	R30,0
    0F5C2 077E      CPC	R23,R30
    0F5C3 F099      BEQ	0xF5D7
    0F5C4 C03E      RJMP	0xF603
(0121) 								{
(0122) 									case 1:
(0123) 										pDescr = (PUINT8)( &MyDevDescr[0] );
    0F5C5 E086      LDI	R24,6
    0F5C6 E091      LDI	R25,1
    0F5C7 9390 02F4 STS	DEVICE.C:pDescr+1,R25
    0F5C9 9380 02F3 STS	DEVICE.C:pDescr,R24
(0124) 										l = sizeof( MyDevDescr );
    0F5CB E182      LDI	R24,0x12
    0F5CC 2EA8      MOV	R10,R24
(0125) 										break;
    0F5CD C037      RJMP	0xF605
(0126) 									case 2:
(0127) 										pDescr = (PUINT8)( &MyCfgDescr[0] );
    0F5CE E188      LDI	R24,0x18
    0F5CF E091      LDI	R25,1
    0F5D0 9390 02F4 STS	DEVICE.C:pDescr+1,R25
    0F5D2 9380 02F3 STS	DEVICE.C:pDescr,R24
(0128) 										l = sizeof( MyCfgDescr );
    0F5D4 E287      LDI	R24,0x27
    0F5D5 2EA8      MOV	R10,R24
(0129) 										//l = SetupReqBuf.wLengthL;
(0130) 										break;
    0F5D6 C02E      RJMP	0xF605
(0131) 									case 3:
(0132) 										switch( SetupReqBuf.wValueL ) 
    0F5D7 816C      LDD	R22,Y+4
    0F5D8 2777      CLR	R23
    0F5D9 3060      CPI	R22,0
    0F5DA 0767      CPC	R22,R23
    0F5DB F0D9      BEQ	0xF5F7
    0F5DC 3061      CPI	R22,1
    0F5DD E0E0      LDI	R30,0
    0F5DE 077E      CPC	R23,R30
    0F5DF F029      BEQ	0xF5E5
    0F5E0 3062      CPI	R22,2
    0F5E1 E0E0      LDI	R30,0
    0F5E2 077E      CPC	R23,R30
    0F5E3 F051      BEQ	0xF5EE
    0F5E4 C01B      RJMP	0xF600
(0133) 										{
(0134) 											case 1:
(0135) 												pDescr = (PUINT8)( &MyManuInfo[0] );
    0F5E5 E483      LDI	R24,0x43
    0F5E6 E091      LDI	R25,1
    0F5E7 9390 02F4 STS	DEVICE.C:pDescr+1,R25
    0F5E9 9380 02F3 STS	DEVICE.C:pDescr,R24
(0136) 												l = sizeof( MyManuInfo );
    0F5EB E08E      LDI	R24,0xE
    0F5EC 2EA8      MOV	R10,R24
(0137) 												break;
    0F5ED C017      RJMP	0xF605
(0138) 											case 2:
(0139) 												pDescr = (PUINT8)( &MyProdInfo[0] );
    0F5EE E581      LDI	R24,0x51
    0F5EF E091      LDI	R25,1
    0F5F0 9390 02F4 STS	DEVICE.C:pDescr+1,R25
    0F5F2 9380 02F3 STS	DEVICE.C:pDescr,R24
(0140) 												l = sizeof( MyProdInfo );
    0F5F4 E182      LDI	R24,0x12
    0F5F5 2EA8      MOV	R10,R24
(0141) 												break;
    0F5F6 C00E      RJMP	0xF605
(0142) 											case 0:
(0143) 												pDescr = (PUINT8)( &MyLangDescr[0] );
    0F5F7 E38F      LDI	R24,0x3F
    0F5F8 E091      LDI	R25,1
    0F5F9 9390 02F4 STS	DEVICE.C:pDescr+1,R25
    0F5FB 9380 02F3 STS	DEVICE.C:pDescr,R24
(0144) 												l = sizeof( MyLangDescr );
    0F5FD E084      LDI	R24,4
    0F5FE 2EA8      MOV	R10,R24
(0145) 												break;
    0F5FF C005      RJMP	0xF605
(0146) 											default:
(0147) 												l = 0xFF;  // 操作失败
    0F600 EF8F      LDI	R24,0xFF
    0F601 2EA8      MOV	R10,R24
(0148) 												break;
(0149) 										}
(0150) 										break;
    0F602 C002      RJMP	0xF605
(0151) 									default:
(0152) 										l = 0xFF;  // 操作失败
    0F603 EF8F      LDI	R24,0xFF
    0F604 2EA8      MOV	R10,R24
(0153) 										break;
(0154) 								}
(0155) 								if ( SetupLen > l ) SetupLen = l;  // 限制总长度
    0F605 2C2A      MOV	R2,R10
    0F606 2433      CLR	R3
    0F607 9040 02F2 LDS	R4,DEVICE.C:SetupLen
    0F609 2455      CLR	R5
    0F60A 1424      CP	R2,R4
    0F60B 0435      CPC	R3,R5
    0F60C F414      BGE	0xF60F
    0F60D 92A0 02F2 STS	DEVICE.C:SetupLen,R10
(0156) 								l = SetupLen >= RAM_ENDP0_SIZE ? RAM_ENDP0_SIZE : SetupLen;  // 本次传输长度
    0F60F 9180 02F2 LDS	R24,DEVICE.C:SetupLen
    0F611 3088      CPI	R24,0x8
    0F612 F018      BCS	0xF616
    0F613 E068      LDI	R22,0x8
    0F614 E070      LDI	R23,0
    0F615 C003      RJMP	0xF619
    0F616 9160 02F2 LDS	R22,DEVICE.C:SetupLen
    0F618 2777      CLR	R23
    0F619 2EA6      MOV	R10,R22
(0157) 								Write374Block2( RAM_ENDP0_TRAN, l, pDescr );  /* 加载上传数据 */
    0F61A 9020 02F3 LDS	R2,DEVICE.C:pDescr
    0F61C 9030 02F4 LDS	R3,DEVICE.C:pDescr+1
    0F61E 8239      STD	Y+1,R3
    0F61F 8228      ST	Y,R2
    0F620 2D2A      MOV	R18,R10
    0F621 E200      LDI	R16,0x20
    0F622 940E F829 CALL	_Write374Block2
(0158) 								SetupLen -= l;
    0F624 9020 02F2 LDS	R2,DEVICE.C:SetupLen
    0F626 1A26      SUB	R2,R22
    0F627 9220 02F2 STS	DEVICE.C:SetupLen,R2
(0159) 								pDescr += l;
    0F629 9020 02F3 LDS	R2,DEVICE.C:pDescr
    0F62B 9030 02F4 LDS	R3,DEVICE.C:pDescr+1
    0F62D 2C4A      MOV	R4,R10
    0F62E 2455      CLR	R5
    0F62F 0C42      ADD	R4,R2
    0F630 1C53      ADC	R5,R3
    0F631 9250 02F4 STS	DEVICE.C:pDescr+1,R5
    0F633 9240 02F3 STS	DEVICE.C:pDescr,R4
(0160) 								break;
    0F635 C088      RJMP	0xF6BE
(0161) 							case DEF_USB_SET_ADDRESS:  //0x05
(0162) 								SetupLen = SetupReqBuf.wValueL;  // 暂存USB设备地址
    0F636 802C      LDD	R2,Y+4
    0F637 9220 02F2 STS	DEVICE.C:SetupLen,R2
(0163) 								break;
    0F639 C084      RJMP	0xF6BE
(0164) 							case DEF_USB_GET_CONFIG:   //0x08
(0165) 								Write374Byte( RAM_ENDP0_TRAN, UsbConfig );
    0F63A 9120 0163 LDS	R18,UsbConfig
    0F63C E200      LDI	R16,0x20
    0F63D 940E F7D6 CALL	_Write374Byte
(0166) 								if ( SetupLen >= 1 ) l = 1;
    0F63F 9180 02F2 LDS	R24,DEVICE.C:SetupLen
    0F641 3081      CPI	R24,1
    0F642 F408      BCC	0xF644
    0F643 C07A      RJMP	0xF6BE
    0F644 24AA      CLR	R10
    0F645 94A3      INC	R10
(0167) 								break;
    0F646 C077      RJMP	0xF6BE
(0168) 							case DEF_USB_SET_CONFIG:  //0x09
(0169) 								UsbConfig = SetupReqBuf.wValueL;
    0F647 802C      LDD	R2,Y+4
    0F648 9220 0163 STS	UsbConfig,R2
(0170) 								break;
    0F64A C073      RJMP	0xF6BE
(0171) 							case DEF_USB_CLR_FEATURE:  //USB标准设备请求 0x01
(0172) 								if ( ( SetupReqBuf.bType & 0x1F ) == 0x02 ) 
    0F64B 818A      LDD	R24,Y+2
    0F64C 718F      ANDI	R24,0x1F
    0F64D 3082      CPI	R24,2
    0F64E F009      BEQ	0xF650
    0F64F C044      RJMP	0xF694
(0173) 								{  // 不是端点不支持
(0174) 									switch( SetupReqBuf.wIndexL ) 
    0F650 816E      LDD	R22,Y+6
    0F651 2777      CLR	R23
    0F652 3061      CPI	R22,1
    0F653 E0E0      LDI	R30,0
    0F654 077E      CPC	R23,R30
    0F655 F189      BEQ	0xF687
    0F656 3062      CPI	R22,2
    0F657 E0E0      LDI	R30,0
    0F658 077E      CPC	R23,R30
    0F659 F0C1      BEQ	0xF672
    0F65A 3061      CPI	R22,1
    0F65B E0E0      LDI	R30,0
    0F65C 077E      CPC	R23,R30
    0F65D F19C      BLT	0xF691
    0F65E 3861      CPI	R22,0x81
    0F65F E0E0      LDI	R30,0
    0F660 077E      CPC	R23,R30
    0F661 F0D1      BEQ	0xF67C
    0F662 3862      CPI	R22,0x82
    0F663 E0E0      LDI	R30,0
    0F664 077E      CPC	R23,R30
    0F665 F009      BEQ	0xF667
    0F666 C02A      RJMP	0xF691
(0175) 									{
(0176) 										case 0x82:
(0177) 											Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_NAK( Read374Byte( REG_USB_ENDP2 ) ) );
    0F667 E00E      LDI	R16,0xE
    0F668 940E F7C3 CALL	_Read374Byte
    0F66A 2F60      MOV	R22,R16
    0F66B 2F26      MOV	R18,R22
    0F66C 7F2C      ANDI	R18,0xFC
    0F66D 6022      ORI	R18,2
    0F66E E00E      LDI	R16,0xE
    0F66F 940E F7D6 CALL	_Write374Byte
(0178) 											break;
    0F671 C04C      RJMP	0xF6BE
(0179) 										case 0x02:
(0180) 											Write374Byte( REG_USB_ENDP2, M_SET_EP2_RECV_ACK( Read374Byte( REG_USB_ENDP2 ) ) );
    0F672 E00E      LDI	R16,0xE
    0F673 940E F7C3 CALL	_Read374Byte
    0F675 2F60      MOV	R22,R16
    0F676 2F26      MOV	R18,R22
    0F677 7C2F      ANDI	R18,0xCF
    0F678 E00E      LDI	R16,0xE
    0F679 940E F7D6 CALL	_Write374Byte
(0181) 											break;
    0F67B C042      RJMP	0xF6BE
(0182) 										case 0x81:
(0183) 											Write374Byte( REG_USB_ENDP1, M_SET_EP1_TRAN_NAK( Read374Byte( REG_USB_ENDP1 ) ) );
    0F67C E00D      LDI	R16,0xD
    0F67D 940E F7C3 CALL	_Read374Byte
    0F67F 2F60      MOV	R22,R16
    0F680 2F26      MOV	R18,R22
    0F681 7F20      ANDI	R18,0xF0
    0F682 602E      ORI	R18,0xE
    0F683 E00D      LDI	R16,0xD
    0F684 940E F7D6 CALL	_Write374Byte
(0184) 											break;
    0F686 C037      RJMP	0xF6BE
(0185) 										case 0x01:
(0186) 											Write374Byte( REG_USB_ENDP1, M_SET_EP1_RECV_ACK( Read374Byte( REG_USB_ENDP1 ) ) );
    0F687 E00D      LDI	R16,0xD
    0F688 940E F7C3 CALL	_Read374Byte
    0F68A 2F60      MOV	R22,R16
    0F68B 2F26      MOV	R18,R22
    0F68C 7C2F      ANDI	R18,0xCF
    0F68D E00D      LDI	R16,0xD
    0F68E 940E F7D6 CALL	_Write374Byte
(0187) 											break;
    0F690 C02D      RJMP	0xF6BE
(0188) 										default:
(0189) 											l = 0xFF;  // 操作失败
    0F691 EF8F      LDI	R24,0xFF
    0F692 2EA8      MOV	R10,R24
(0190) 											break;
(0191) 									}
(0192) 								}
    0F693 C02A      RJMP	0xF6BE
(0193) 								else l = 0xFF;  // 操作失败
    0F694 EF8F      LDI	R24,0xFF
    0F695 2EA8      MOV	R10,R24
(0194) 								break;
    0F696 C027      RJMP	0xF6BE
(0195) 							case DEF_USB_GET_INTERF:
(0196) 								Write374Byte( RAM_ENDP0_TRAN, 0 );
    0F697 2722      CLR	R18
    0F698 E200      LDI	R16,0x20
    0F699 940E F7D6 CALL	_Write374Byte
(0197) 								if ( SetupLen >= 1 ) l = 1;
    0F69B 9180 02F2 LDS	R24,DEVICE.C:SetupLen
    0F69D 3081      CPI	R24,1
    0F69E F0F8      BCS	0xF6BE
    0F69F 24AA      CLR	R10
    0F6A0 94A3      INC	R10
(0198) 								break;
    0F6A1 C01C      RJMP	0xF6BE
(0199) 							case DEF_USB_GET_STATUS:
(0200) 								Write374Byte( RAM_ENDP0_TRAN, 0 );
    0F6A2 2722      CLR	R18
    0F6A3 E200      LDI	R16,0x20
    0F6A4 940E F7D6 CALL	_Write374Byte
(0201) 								Write374Byte( RAM_ENDP0_TRAN + 1, 0 );
    0F6A6 2722      CLR	R18
    0F6A7 E201      LDI	R16,0x21
    0F6A8 940E F7D6 CALL	_Write374Byte
(0202) 								if ( SetupLen >= 2 ) l = 2;
    0F6AA 9180 02F2 LDS	R24,DEVICE.C:SetupLen
    0F6AC 3082      CPI	R24,2
    0F6AD F018      BCS	0xF6B1
    0F6AE E082      LDI	R24,2
    0F6AF 2EA8      MOV	R10,R24
    0F6B0 C00D      RJMP	0xF6BE
(0203) 								else l = SetupLen;
    0F6B1 90A0 02F2 LDS	R10,DEVICE.C:SetupLen
(0204) 								break;
    0F6B3 C00A      RJMP	0xF6BE
(0205) 							case 0xfe:
(0206) 							   	Write374Byte( RAM_ENDP0_TRAN, 0 );
    0F6B4 2722      CLR	R18
    0F6B5 E200      LDI	R16,0x20
    0F6B6 940E F7D6 CALL	_Write374Byte
(0207) 								//Write374Byte( REG_USB_LENGTH, 1 );
(0208) 					           // Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_ACK( Read374Byte( REG_USB_ENDP0 ), l ) ^ BIT_EP0_TRAN_TOG );
(0209) 								//printf("GET_MAX_LUN:\r\n");
(0210) 								break;
    0F6B8 C005      RJMP	0xF6BE
(0211) 							default:
(0212) 								l = 0xFF;  // 操作失败
    0F6B9 EF8F      LDI	R24,0xFF
    0F6BA 2EA8      MOV	R10,R24
(0213) 								break;
(0214) 						}
(0215) 					}
(0216) 				}
    0F6BB C002      RJMP	0xF6BE
(0217) 				else l = 0xFF;  // 操作失败
    0F6BC EF8F      LDI	R24,0xFF
    0F6BD 2EA8      MOV	R10,R24
(0218) 				if ( l == 0xFF ) 
    0F6BE 2D8A      MOV	R24,R10
    0F6BF 3F8F      CPI	R24,0xFF
    0F6C0 F429      BNE	0xF6C6
(0219) 				{  // 操作失败
(0220) 					Write374Byte( REG_USB_ENDP0, M_SET_EP0_RECV_STA( M_SET_EP0_TRAN_STA( 0 ) ) );  // STALL
    0F6C1 E32F      LDI	R18,0x3F
    0F6C2 E00C      LDI	R16,0xC
    0F6C3 940E F7D6 CALL	_Write374Byte
(0221) 				}
    0F6C5 C073      RJMP	0xF739
(0222) 				else if ( l <= RAM_ENDP0_SIZE ) 
    0F6C6 E088      LDI	R24,0x8
    0F6C7 158A      CP	R24,R10
    0F6C8 F070      BCS	0xF6D7
(0223) 				{  // 上传数据
(0224) 					Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_ACK( M_SET_EP0_RECV_ACK( Read374Byte( REG_USB_ENDP0 ) ), l ) | BIT_EP0_TRAN_TOG );  // DATA1
    0F6C9 E00C      LDI	R16,0xC
    0F6CA 940E F7C3 CALL	_Read374Byte
    0F6CC 2F60      MOV	R22,R16
    0F6CD 2D8A      MOV	R24,R10
    0F6CE 708F      ANDI	R24,0xF
    0F6CF 2F26      MOV	R18,R22
    0F6D0 7C20      ANDI	R18,0xC0
    0F6D1 2B28      OR	R18,R24
    0F6D2 6420      ORI	R18,0x40
    0F6D3 E00C      LDI	R16,0xC
    0F6D4 940E F7D6 CALL	_Write374Byte
(0225) 				}
    0F6D6 C062      RJMP	0xF739
(0226) 				else 
(0227) 				{  // 下传数据或其它
(0228) 					Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_NAK( M_SET_EP0_RECV_ACK( Read374Byte( REG_USB_ENDP0 ) ) ) | BIT_EP0_RECV_TOG );  // DATA1
    0F6D7 E00C      LDI	R16,0xC
    0F6D8 940E F7C3 CALL	_Read374Byte
    0F6DA 2F60      MOV	R22,R16
    0F6DB 2F26      MOV	R18,R22
    0F6DC 7C20      ANDI	R18,0xC0
    0F6DD 682E      ORI	R18,0x8E
    0F6DE E00C      LDI	R16,0xC
    0F6DF 940E F7D6 CALL	_Write374Byte
(0229) 				}
(0230) 				//ARD=2;
(0231) 				break;
    0F6E1 C057      RJMP	0xF739
(0232) 			}
(0233) 			case USB_INT_EP0_IN:   // 0x08  USB端点0的IN
(0234) 			{
(0235) 				switch( SetupReq ) 
    0F6E2 9160 02F1 LDS	R22,DEVICE.C:SetupReq
    0F6E4 2777      CLR	R23
    0F6E5 3065      CPI	R22,5
    0F6E6 E0E0      LDI	R30,0
    0F6E7 077E      CPC	R23,R30
    0F6E8 F1D1      BEQ	0xF723
    0F6E9 3066      CPI	R22,6
    0F6EA E0E0      LDI	R30,0
    0F6EB 077E      CPC	R23,R30
    0F6EC F009      BEQ	0xF6EE
    0F6ED C03A      RJMP	0xF728
(0236) 				{
(0237) 					case DEF_USB_GET_DESCR:
(0238) 						l = SetupLen >= RAM_ENDP0_SIZE ? RAM_ENDP0_SIZE : SetupLen;  // 本次传输长度
    0F6EE 9180 02F2 LDS	R24,DEVICE.C:SetupLen
    0F6F0 3088      CPI	R24,0x8
    0F6F1 F018      BCS	0xF6F5
    0F6F2 E068      LDI	R22,0x8
    0F6F3 E070      LDI	R23,0
    0F6F4 C003      RJMP	0xF6F8
    0F6F5 9160 02F2 LDS	R22,DEVICE.C:SetupLen
    0F6F7 2777      CLR	R23
    0F6F8 2EA6      MOV	R10,R22
(0239) 						Write374Block2( RAM_ENDP0_TRAN, l, pDescr );  /* 加载上传数据 */
    0F6F9 9020 02F3 LDS	R2,DEVICE.C:pDescr
    0F6FB 9030 02F4 LDS	R3,DEVICE.C:pDescr+1
    0F6FD 8239      STD	Y+1,R3
    0F6FE 8228      ST	Y,R2
    0F6FF 2D2A      MOV	R18,R10
    0F700 E200      LDI	R16,0x20
    0F701 940E F829 CALL	_Write374Block2
(0240) 						SetupLen -= l;
    0F703 9020 02F2 LDS	R2,DEVICE.C:SetupLen
    0F705 1A26      SUB	R2,R22
    0F706 9220 02F2 STS	DEVICE.C:SetupLen,R2
(0241) 						pDescr += l;
    0F708 9020 02F3 LDS	R2,DEVICE.C:pDescr
    0F70A 9030 02F4 LDS	R3,DEVICE.C:pDescr+1
    0F70C 2C4A      MOV	R4,R10
    0F70D 2455      CLR	R5
    0F70E 0C42      ADD	R4,R2
    0F70F 1C53      ADC	R5,R3
    0F710 9250 02F4 STS	DEVICE.C:pDescr+1,R5
    0F712 9240 02F3 STS	DEVICE.C:pDescr,R4
(0242) 						Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_ACK( Read374Byte( REG_USB_ENDP0 ), l ) ^ BIT_EP0_TRAN_TOG );
    0F714 E00C      LDI	R16,0xC
    0F715 940E F7C3 CALL	_Read374Byte
    0F717 2F60      MOV	R22,R16
    0F718 2D8A      MOV	R24,R10
    0F719 708F      ANDI	R24,0xF
    0F71A 2F26      MOV	R18,R22
    0F71B 7F20      ANDI	R18,0xF0
    0F71C 2B28      OR	R18,R24
    0F71D E480      LDI	R24,0x40
    0F71E 2728      EOR	R18,R24
    0F71F E00C      LDI	R16,0xC
    0F720 940E F7D6 CALL	_Write374Byte
(0243) 						//printf("DEF_USB_GET_DESCR:\r\n");
(0244) 						break;
    0F722 C016      RJMP	0xF739
(0245) 					case DEF_USB_SET_ADDRESS:
(0246) 						Write374Byte( REG_USB_ADDR, SetupLen );
    0F723 9120 02F2 LDS	R18,DEVICE.C:SetupLen
    0F725 E008      LDI	R16,0x8
    0F726 940E F7D6 CALL	_Write374Byte
(0247) 					default:
(0248) 						Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_NAK( 0 ) );  // 结束
    0F728 E02E      LDI	R18,0xE
    0F729 E00C      LDI	R16,0xC
    0F72A 940E F7D6 CALL	_Write374Byte
(0249) 						break;
(0250) 				}
(0251) 				break;
    0F72C C00C      RJMP	0xF739
(0252) 			}
(0253) 			case USB_INT_EP0_OUT:     //0x00， USB端点0的OUT 
(0254) 			{
(0255) 				switch( SetupReq ) 
    0F72D 9160 02F1 LDS	R22,DEVICE.C:SetupReq
    0F72F 2777      CLR	R23
    0F730 3066      CPI	R22,6
    0F731 E0E0      LDI	R30,0
    0F732 077E      CPC	R23,R30
    0F733 F009      BEQ	0xF735
    0F734 C000      RJMP	0xF735
(0256) 				{
(0257) //					case download:
(0258) //						get_data;
(0259) //						break;
(0260) 					case DEF_USB_GET_DESCR:
(0261) 					 //Write374Byte( RAM_ENDP0_TRAN,00 );
(0262) 					default:
(0263) 						Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_NAK( 0 ) );  // 结束
    0F735 E02E      LDI	R18,0xE
    0F736 E00C      LDI	R16,0xC
    0F737 940E F7D6 CALL	_Write374Byte
(0264) 						break;
(0265) 				}
(0266) 				break;
(0267) 			}
(0268) 			default: 
(0269) 			{
(0270) 				break;
(0271) 			}
(0272) 		}
(0273) 		Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_TRANSFER );  // 清中断标志
    0F739 E121      LDI	R18,0x11
    0F73A E009      LDI	R16,0x9
    0F73B 940E F7D6 CALL	_Write374Byte
(0274) 	}
    0F73D C01B      RJMP	0xF759
(0275) 	else if ( s & BIT_IF_USB_SUSPEND ) 
    0F73E FF42      SBRS	R20,2
    0F73F C00E      RJMP	0xF74E
(0276) 	{  // USB总线挂起
(0277) 		Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_USB_SUSPEND );  // 清中断标志
    0F740 E124      LDI	R18,0x14
    0F741 E009      LDI	R16,0x9
    0F742 940E F7D6 CALL	_Write374Byte
(0278) 		Write374Byte( REG_SYS_CTRL, Read374Byte( REG_SYS_CTRL ) | BIT_CTRL_OSCIL_OFF );  // 时钟振荡器停止振荡,进入睡眠状态
    0F744 E005      LDI	R16,5
    0F745 940E F7C3 CALL	_Read374Byte
    0F747 2F60      MOV	R22,R16
    0F748 2F26      MOV	R18,R22
    0F749 6021      ORI	R18,1
    0F74A E005      LDI	R16,5
    0F74B 940E F7D6 CALL	_Write374Byte
(0279) 	}
    0F74D C00B      RJMP	0xF759
(0280) 	else if ( s & BIT_IF_WAKE_UP ) 
    0F74E FF43      SBRS	R20,3
    0F74F C005      RJMP	0xF755
(0281) 	{  // 芯片唤醒完成
(0282) 		Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_WAKE_UP );  // 清中断标志
    0F750 E128      LDI	R18,0x18
    0F751 E009      LDI	R16,0x9
    0F752 940E F7D6 CALL	_Write374Byte
(0283) 	}
    0F754 C004      RJMP	0xF759
(0284) 	else 
(0285) 	{  // 意外的中断,不可能发生的情况,除了硬件损坏
(0286) 		Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_INTER_FLAG );  // 清中断标志
    0F755 E12F      LDI	R18,0x1F
    0F756 E009      LDI	R16,0x9
    0F757 940E F7D6 CALL	_Write374Byte
(0287) 	}
    0F759 962A      ADIW	R28,0xA
    0F75A 940E F90C CALL	pop_xgsetF00C
    0F75C 9009      LD	R0,Y+
    0F75D BE0F      OUT	0x3F,R0
    0F75E 91F9      LD	R31,Y+
    0F75F 91E9      LD	R30,Y+
    0F760 91B9      LD	R27,Y+
    0F761 91A9      LD	R26,Y+
    0F762 9199      LD	R25,Y+
    0F763 9189      LD	R24,Y+
    0F764 9139      LD	R19,Y+
    0F765 9129      LD	R18,Y+
    0F766 9119      LD	R17,Y+
    0F767 9109      LD	R16,Y+
    0F768 9099      LD	R9,Y+
    0F769 9089      LD	R8,Y+
    0F76A 9079      LD	R7,Y+
    0F76B 9069      LD	R6,Y+
    0F76C 9059      LD	R5,Y+
    0F76D 9049      LD	R4,Y+
    0F76E 9039      LD	R3,Y+
    0F76F 9029      LD	R2,Y+
    0F770 9019      LD	R1,Y+
    0F771 9009      LD	R0,Y+
    0F772 9518      RETI
(0288) 	
(0289) }
(0290) 
(0291) void	Init374Device( void )  // 初始化USB设备
(0292) {     
(0293) 	Write374Byte( REG_USB_ADDR, 0x00 );
_Init374Device:
    0F773 2722      CLR	R18
    0F774 E008      LDI	R16,0x8
    0F775 940E F7D6 CALL	_Write374Byte
(0294) 	Write374Byte( REG_USB_ENDP0, M_SET_EP0_TRAN_NAK( 0 ) );
    0F777 E02E      LDI	R18,0xE
    0F778 E00C      LDI	R16,0xC
    0F779 940E F7D6 CALL	_Write374Byte
(0295) 	Write374Byte( REG_USB_ENDP1, M_SET_EP1_TRAN_NAK( 0 ) );
    0F77B E02E      LDI	R18,0xE
    0F77C E00D      LDI	R16,0xD
    0F77D 940E F7D6 CALL	_Write374Byte
(0296) 	Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_NAK( 0 ) );
    0F77F E022      LDI	R18,2
    0F780 E00E      LDI	R16,0xE
    0F781 940E F7D6 CALL	_Write374Byte
(0297) 	Write374Byte( REG_INTER_FLAG, BIT_IF_USB_PAUSE | BIT_IF_INTER_FLAG );  // 清所有中断标志
    0F783 E12F      LDI	R18,0x1F
    0F784 E009      LDI	R16,0x9
    0F785 940E F7D6 CALL	_Write374Byte
(0298) 	Write374Byte( REG_INTER_EN, BIT_IE_TRANSFER | BIT_IE_BUS_RESET | BIT_IE_USB_SUSPEND );  // 允许传输完成中断和USB总线复位中断以及USB总线挂起中断,芯片唤醒完成中断
    0F787 E027      LDI	R18,7
    0F788 E007      LDI	R16,7
    0F789 940E F7D6 CALL	_Write374Byte
(0299) 	Write374Byte( REG_SYS_CTRL, BIT_CTRL_OE_POLAR );  // 对于CH374T或者UEN引脚悬空的CH374S必须置BIT_CTRL_OE_POLAR为1
    0F78B E420      LDI	R18,0x40
    0F78C E005      LDI	R16,5
    0F78D 940E F7D6 CALL	_Write374Byte
(0300) 	Write374Byte( REG_USB_SETUP, BIT_SETP_TRANS_EN | BIT_SETP_PULLUP_EN );  // 启动USB设备
    0F78F E023      LDI	R18,3
    0F790 E006      LDI	R16,6
    0F791 940C F7D6 JMP	_Write374Byte
_USBStart:
  i                    --> R20
    0F793 934A      ST	-Y,R20
    0F794 935A      ST	-Y,R21
(0301) }
(0302) 
(0303) 
(0304) void USBStart(void)
(0305) {
(0306)       unsigned int i;
(0307)  
(0308)  
(0309) 	  Write374Byte(REG_SYS_CTRL,0x08);	   //CH374软复位
    0F795 E028      LDI	R18,0x8
    0F796 E005      LDI	R16,5
    0F797 940E F7D6 CALL	_Write374Byte
(0310) 	  for(i=0;i<50000;i++);//18ms
    0F799 2744      CLR	R20
    0F79A 2755      CLR	R21
    0F79B C002      RJMP	0xF79E
    0F79C 5F4F      SUBI	R20,0xFF
    0F79D 4F5F      SBCI	R21,0xFF
    0F79E E580      LDI	R24,0x50
    0F79F EC93      LDI	R25,0xC3
    0F7A0 E0A0      LDI	R26,0
    0F7A1 E0B0      LDI	R27,0
    0F7A2 011A      MOVW	R2,R20
    0F7A3 2444      CLR	R4
    0F7A4 2455      CLR	R5
    0F7A5 1628      CP	R2,R24
    0F7A6 0639      CPC	R3,R25
    0F7A7 064A      CPC	R4,R26
    0F7A8 065B      CPC	R5,R27
    0F7A9 F394      BLT	0xF79C
(0311) 	  Write374Byte(REG_SYS_CTRL,0x00);
    0F7AA 2722      CLR	R18
    0F7AB E005      LDI	R16,5
    0F7AC 940E F7D6 CALL	_Write374Byte
(0312) 	  for(i=0;i<50000;i++);//18ms 
    0F7AE 2744      CLR	R20
    0F7AF 2755      CLR	R21
    0F7B0 C002      RJMP	0xF7B3
    0F7B1 5F4F      SUBI	R20,0xFF
    0F7B2 4F5F      SBCI	R21,0xFF
    0F7B3 E580      LDI	R24,0x50
    0F7B4 EC93      LDI	R25,0xC3
    0F7B5 E0A0      LDI	R26,0
    0F7B6 E0B0      LDI	R27,0
    0F7B7 011A      MOVW	R2,R20
    0F7B8 2444      CLR	R4
    0F7B9 2455      CLR	R5
    0F7BA 1628      CP	R2,R24
    0F7BB 0639      CPC	R3,R25
    0F7BC 064A      CPC	R4,R26
    0F7BD 065B      CPC	R5,R27
    0F7BE F394      BLT	0xF7B1
(0313)  
(0314) 	 
(0315) 	 Init374Device();
    0F7BF DFB3      RCALL	_Init374Device
    0F7C0 9159      LD	R21,Y+
    0F7C1 9149      LD	R20,Y+
    0F7C2 9508      RET
FILE: D:\chen\Core\FirmWare_CT\DMX_MCUBootLoader(20170226_ZKY3_V20）\SPI_HW.C
(0001) 
(0002) #include <string.h>
(0003) #include <stdio.h>
(0004) #include	"HAL.H"			// 其它单片机需修改HAL*硬件抽象层的几个文件
(0005) /*
(0006) #define	CH374_SPI_SCS0			{DDRB|=0x10;PORTB&=0xef;}		 
(0007) #define	CH374_SPI_SCS1			{DDRB|=0x10;PORTB|=0x10;}
(0008) */
(0009) #define	CH374_SPI_SCS0			{DDRB|=0x01;PORTB&=0xFE;}		 
(0010) #define	CH374_SPI_SCS1			{DDRB|=0x01;PORTB|=0x01;}	
(0011) 	
(0012) extern unsigned char EP2SendBusy;
(0013) /*
(0014) #define	CH374_SPI_SCS0			PORTB&=0xfe;		 
(0015) #define	CH374_SPI_SCS1			PORTB|=0x01;		 
(0016)  
(0017) #define	CH374_SPI_SDI0			PORTB&=0xfb;		 
(0018) #define	CH374_SPI_SDI1			PORTB|=0x04;		 
(0019) 
(0020) #define	CH374_SPI_SDO			(PINB&0xf7)		   
(0021) 
(0022) #define	CH374_SPI_SCK1			PORTB|=0x02;		 
(0023) #define	CH374_SPI_SCK0			PORTB&=0xfd;	 
(0024) */
(0025) void EP2Send(UINT8 mLen, PUINT8 mBuf);
(0026) void EP2SendConst(UINT8 mLen, const unsigned char  *mBuf);
(0027) 
(0028) UINT8 Read374Byte( UINT8 mAddr )         // 从指定寄存器读取数据 
(0029) {
(0030) 	CH374_SPI_SCS0   //SPI片选有效
_Read374Byte:
  mAddr                --> R16
    0F7C3 9AB8      SBI	0x17,0
    0F7C4 B388      IN	R24,0x18
    0F7C5 7F8E      ANDI	R24,0xFE
    0F7C6 BB88      OUT	0x18,R24
(0031) 	
(0032) 	SPDR = mAddr; // 启动数据传输  发送读地址
    0F7C7 B90F      OUT	0x0F,R16
(0033)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7C8 9B77      SBIS	0x0E,7
    0F7C9 CFFE      RJMP	0xF7C8
(0034) 	
(0035) 	SPDR = 0xc0; // 启动数据传输  发送读命令 CMD_SPI_374READ=0xc0
    0F7CA EC80      LDI	R24,0xC0
    0F7CB B98F      OUT	0x0F,R24
(0036)     while((SPSR & 0x80)==0x00); // 等待传输结束  
    0F7CC 9B77      SBIS	0x0E,7
    0F7CD CFFE      RJMP	0xF7CC
(0037) 	
(0038) 	SPDR = 0x00;
    0F7CE 2422      CLR	R2
    0F7CF B82F      OUT	0x0F,R2
(0039)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7D0 9B77      SBIS	0x0E,7
    0F7D1 CFFE      RJMP	0xF7D0
(0040) 	
(0041)     CH374_SPI_SCS1              // SPI停止
    0F7D2 9AB8      SBI	0x17,0
    0F7D3 9AC0      SBI	0x18,0
(0042) 	return SPDR;
    0F7D4 B10F      IN	R16,0x0F
    0F7D5 9508      RET
(0043) }
(0044) 
(0045) void Write374Byte( UINT8 mAddr, UINT8 mData )  // 向指定寄存器写入数据 
(0046) {
(0047) 
(0048) 	CH374_SPI_SCS0   //SPI片选有效
_Write374Byte:
  mData                --> R18
  mAddr                --> R16
    0F7D6 9AB8      SBI	0x17,0
    0F7D7 B388      IN	R24,0x18
    0F7D8 7F8E      ANDI	R24,0xFE
    0F7D9 BB88      OUT	0x18,R24
(0049) 	
(0050) 	SPDR = mAddr; // 启动数据传输  发送读地址
    0F7DA B90F      OUT	0x0F,R16
(0051)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7DB 9B77      SBIS	0x0E,7
    0F7DC CFFE      RJMP	0xF7DB
(0052) 	
(0053) 	SPDR = 0x80; // 启动数据传输  发送写命令 CMD_SPI_374WRITE=0x80
    0F7DD E880      LDI	R24,0x80
    0F7DE B98F      OUT	0x0F,R24
(0054)     while((SPSR & 0x80)==0x00); // 等待传输结束  
    0F7DF 9B77      SBIS	0x0E,7
    0F7E0 CFFE      RJMP	0xF7DF
(0055) 	
(0056) 	SPDR = mData;
    0F7E1 B92F      OUT	0x0F,R18
(0057)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7E2 9B77      SBIS	0x0E,7
    0F7E3 CFFE      RJMP	0xF7E2
(0058) 	
(0059)     CH374_SPI_SCS1              // SPI停止
    0F7E4 9AB8      SBI	0x17,0
    0F7E5 9AC0      SBI	0x18,0
    0F7E6 9508      RET
_Read374Block:
  mBuf                 --> R10
  mLen                 --> R18
  mAddr                --> R16
    0F7E7 92AA      ST	-Y,R10
    0F7E8 92BA      ST	-Y,R11
    0F7E9 80AA      LDD	R10,Y+2
    0F7EA 80BB      LDD	R11,Y+3
(0060) 
(0061) }
(0062) 
(0063) void Read374Block( UINT8 mAddr, UINT8 mLen, PUINT8 mBuf )  // 从指定起始地址读出数据块 
(0064) {
(0065) 	CH374_SPI_SCS0    //SPI片选有效
    0F7EB 9AB8      SBI	0x17,0
    0F7EC B388      IN	R24,0x18
    0F7ED 7F8E      ANDI	R24,0xFE
    0F7EE BB88      OUT	0x18,R24
(0066) 	 
(0067) 	SPDR = mAddr; // 启动数据传输  发送读地址
    0F7EF B90F      OUT	0x0F,R16
(0068)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7F0 9B77      SBIS	0x0E,7
    0F7F1 CFFE      RJMP	0xF7F0
(0069) 	
(0070) 	SPDR = 0xc0; // 启动数据传输  发送读命令 CMD_SPI_374READ=0xc0
    0F7F2 EC80      LDI	R24,0xC0
    0F7F3 B98F      OUT	0x0F,R24
(0071)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7F4 9B77      SBIS	0x0E,7
    0F7F5 CFFE      RJMP	0xF7F4
    0F7F6 C008      RJMP	0xF7FF
(0072) 	
(0073) 	while ( mLen -- )
(0074) 	{
(0075) 	 SPDR = 0x00;
    0F7F7 2422      CLR	R2
    0F7F8 B82F      OUT	0x0F,R2
(0076)      while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F7F9 9B77      SBIS	0x0E,7
    0F7FA CFFE      RJMP	0xF7F9
(0077) 	 *mBuf++ = SPDR;
    0F7FB B02F      IN	R2,0x0F
    0F7FC 01F5      MOVW	R30,R10
    0F7FD 9221      ST	Z+,R2
    0F7FE 015F      MOVW	R10,R30
    0F7FF 2E22      MOV	R2,R18
    0F800 2433      CLR	R3
    0F801 5021      SUBI	R18,1
    0F802 2022      TST	R2
    0F803 F799      BNE	0xF7F7
(0078) 	 }
(0079) 	CH374_SPI_SCS1              //SPI停止
    0F804 9AB8      SBI	0x17,0
    0F805 9AC0      SBI	0x18,0
    0F806 90B9      LD	R11,Y+
    0F807 90A9      LD	R10,Y+
    0F808 9508      RET
_Write374Block:
  mBuf                 --> R10
  mLen                 --> R18
  mAddr                --> R16
    0F809 92AA      ST	-Y,R10
    0F80A 92BA      ST	-Y,R11
    0F80B 80AA      LDD	R10,Y+2
    0F80C 80BB      LDD	R11,Y+3
(0080) }
(0081) 
(0082) void Write374Block( UINT8 mAddr, UINT8 mLen, PUINT8 mBuf )  // 向指定起始地址写入数据块 
(0083) {
(0084) 	CH374_SPI_SCS0     //SPI片选有效
    0F80D 9AB8      SBI	0x17,0
    0F80E B388      IN	R24,0x18
    0F80F 7F8E      ANDI	R24,0xFE
    0F810 BB88      OUT	0x18,R24
(0085) 	 
(0086) 	SPDR = mAddr; // 启动数据传输  发送读地址
    0F811 B90F      OUT	0x0F,R16
(0087)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F812 9B77      SBIS	0x0E,7
    0F813 CFFE      RJMP	0xF812
(0088) 	
(0089) 	SPDR = 0x80; // 启动数据传输  发送写命令 CMD_SPI_374WRITE=0x80
    0F814 E880      LDI	R24,0x80
    0F815 B98F      OUT	0x0F,R24
(0090)     while((SPSR & 0x80)==0x00); // 等待传输结束  
    0F816 9B77      SBIS	0x0E,7
    0F817 CFFE      RJMP	0xF816
    0F818 C006      RJMP	0xF81F
(0091) 	
(0092) 	while ( mLen -- ) 
(0093) 	{
(0094) 	 SPDR = *mBuf++;
    0F819 01F5      MOVW	R30,R10
    0F81A 9021      LD	R2,Z+
    0F81B 015F      MOVW	R10,R30
    0F81C B82F      OUT	0x0F,R2
(0095)      while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F81D 9B77      SBIS	0x0E,7
    0F81E CFFE      RJMP	0xF81D
    0F81F 2E22      MOV	R2,R18
    0F820 2433      CLR	R3
    0F821 5021      SUBI	R18,1
    0F822 2022      TST	R2
    0F823 F7A9      BNE	0xF819
(0096) 	 }
(0097) 	
(0098) 	CH374_SPI_SCS1             //SPI停止
    0F824 9AB8      SBI	0x17,0
    0F825 9AC0      SBI	0x18,0
    0F826 90B9      LD	R11,Y+
    0F827 90A9      LD	R10,Y+
    0F828 9508      RET
_Write374Block2:
  mBuf                 --> R10
  mLen                 --> R18
  mAddr                --> R16
    0F829 92AA      ST	-Y,R10
    0F82A 92BA      ST	-Y,R11
    0F82B 80AA      LDD	R10,Y+2
    0F82C 80BB      LDD	R11,Y+3
(0099) }
(0100) 
(0101) void Write374Block2( UINT8 mAddr, UINT8 mLen,const unsigned char  *mBuf )  // 向指定起始地址写入数据块 
(0102) {
(0103) 	CH374_SPI_SCS0      //SPI片选有效
    0F82D 9AB8      SBI	0x17,0
    0F82E B388      IN	R24,0x18
    0F82F 7F8E      ANDI	R24,0xFE
    0F830 BB88      OUT	0x18,R24
(0104) 	 
(0105) 	SPDR = mAddr; // 启动数据传输  发送读地址
    0F831 B90F      OUT	0x0F,R16
(0106)     while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F832 9B77      SBIS	0x0E,7
    0F833 CFFE      RJMP	0xF832
(0107) 	
(0108) 	SPDR = 0x80; // 启动数据传输  发送写命令 CMD_SPI_374WRITE=0x80
    0F834 E880      LDI	R24,0x80
    0F835 B98F      OUT	0x0F,R24
(0109)     while((SPSR & 0x80)==0x00); // 等待传输结束  
    0F836 9B77      SBIS	0x0E,7
    0F837 CFFE      RJMP	0xF836
    0F838 C006      RJMP	0xF83F
(0110) 	
(0111) 	while ( mLen -- ) 
(0112) 	{
(0113) 	 SPDR = *mBuf++;
    0F839 01F5      MOVW	R30,R10
    0F83A 9021      LD	R2,Z+
    0F83B 015F      MOVW	R10,R30
    0F83C B82F      OUT	0x0F,R2
(0114)      while((SPSR & 0x80)==0x00); // 等待传输结束 
    0F83D 9B77      SBIS	0x0E,7
    0F83E CFFE      RJMP	0xF83D
    0F83F 2E22      MOV	R2,R18
    0F840 2433      CLR	R3
    0F841 5021      SUBI	R18,1
    0F842 2022      TST	R2
    0F843 F7A9      BNE	0xF839
(0115) 	 }
(0116) 	
(0117) 	CH374_SPI_SCS1              //SPI停止
    0F844 9AB8      SBI	0x17,0
    0F845 9AC0      SBI	0x18,0
    0F846 90B9      LD	R11,Y+
    0F847 90A9      LD	R10,Y+
    0F848 9508      RET
_EP2SendConst:
  mBuf                 --> R12
  mLen                 --> R10
    0F849 940E F900 CALL	push_xgset003C
    0F84B 0169      MOVW	R12,R18
    0F84C 2EA0      MOV	R10,R16
    0F84D 9722      SBIW	R28,2
(0118) }
(0119) 
(0120) void EP2SendConst(UINT8 mLen, const unsigned char  *mBuf)
(0121) {   while(EP2SendBusy);
    0F84E 9020 0105 LDS	R2,EP2SendBusy
    0F850 2022      TST	R2
    0F851 F7E1      BNE	0xF84E
(0122) 	Write374Block2( RAM_ENDP2_TRAN, mLen,mBuf );
    0F852 82D9      STD	Y+1,R13
    0F853 82C8      ST	Y,R12
    0F854 2D2A      MOV	R18,R10
    0F855 E400      LDI	R16,0x40
    0F856 DFD2      RCALL	_Write374Block2
(0123) 	Write374Byte( REG_USB_LENGTH, mLen );
    0F857 2D2A      MOV	R18,R10
    0F858 E00B      LDI	R16,0xB
    0F859 DF7C      RCALL	_Write374Byte
(0124) 	Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_ACK( Read374Byte( REG_USB_ENDP2 ) ) ^ BIT_EP2_RECV_TOG );
    0F85A E00E      LDI	R16,0xE
    0F85B DF67      RCALL	_Read374Byte
    0F85C E880      LDI	R24,0x80
    0F85D E090      LDI	R25,0
    0F85E 2F20      MOV	R18,R16
    0F85F 2733      CLR	R19
    0F860 7F2C      ANDI	R18,0xFC
    0F861 2728      EOR	R18,R24
    0F862 2739      EOR	R19,R25
    0F863 E00E      LDI	R16,0xE
    0F864 DF71      RCALL	_Write374Byte
(0125) 	EP2SendBusy=1;
    0F865 E081      LDI	R24,1
    0F866 9380 0105 STS	EP2SendBusy,R24
    0F868 9622      ADIW	R28,2
    0F869 940C F8EA JMP	pop_xgset003C
_EP2Send:
  mBuf                 --> R12
  mLen                 --> R10
    0F86B 940E F900 CALL	push_xgset003C
    0F86D 0169      MOVW	R12,R18
    0F86E 2EA0      MOV	R10,R16
    0F86F 9722      SBIW	R28,2
(0126) }
(0127) 
(0128) void EP2Send(UINT8 mLen, PUINT8 mBuf)
(0129) {   while(EP2SendBusy);
    0F870 9020 0105 LDS	R2,EP2SendBusy
    0F872 2022      TST	R2
    0F873 F7E1      BNE	0xF870
(0130) 	Write374Block( RAM_ENDP2_TRAN, mLen,mBuf );
    0F874 82D9      STD	Y+1,R13
    0F875 82C8      ST	Y,R12
    0F876 2D2A      MOV	R18,R10
    0F877 E400      LDI	R16,0x40
    0F878 DF90      RCALL	_Write374Block
(0131) 	Write374Byte( REG_USB_LENGTH, mLen );
    0F879 2D2A      MOV	R18,R10
    0F87A E00B      LDI	R16,0xB
    0F87B DF5A      RCALL	_Write374Byte
(0132) 	Write374Byte( REG_USB_ENDP2, M_SET_EP2_TRAN_ACK( Read374Byte( REG_USB_ENDP2 ) ) ^ BIT_EP2_RECV_TOG );
    0F87C E00E      LDI	R16,0xE
    0F87D DF45      RCALL	_Read374Byte
    0F87E E880      LDI	R24,0x80
    0F87F E090      LDI	R25,0
    0F880 2F20      MOV	R18,R16
    0F881 2733      CLR	R19
    0F882 7F2C      ANDI	R18,0xFC
    0F883 2728      EOR	R18,R24
    0F884 2739      EOR	R19,R25
    0F885 E00E      LDI	R16,0xE
    0F886 DF4F      RCALL	_Write374Byte
(0133) 	EP2SendBusy=1;
FILE: <library>
    0F887 E081      LDI	R24,1
    0F888 9380 0105 STS	EP2SendBusy,R24
    0F88A 9622      ADIW	R28,2
    0F88B 940C F8EA JMP	pop_xgset003C
push_arg4:
    0F88D 933A      ST	-Y,R19
    0F88E 932A      ST	-Y,R18
push_arg2:
    0F88F 931A      ST	-Y,R17
    0F890 930A      ST	-Y,R16
    0F891 9508      RET
elpm32:
    0F892 93EA      ST	-Y,R30
    0F893 93FA      ST	-Y,R31
    0F894 920A      ST	-Y,R0
    0F895 2FE0      MOV	R30,R16
    0F896 2FF1      MOV	R31,R17
    0F897 95D8      ELPM
    0F898 2D00      MOV	R16,R0
    0F899 9631      ADIW	R30,1
    0F89A 95D8      ELPM
    0F89B 2D10      MOV	R17,R0
    0F89C 9631      ADIW	R30,1
    0F89D 95D8      ELPM
    0F89E 2D20      MOV	R18,R0
    0F89F 9631      ADIW	R30,1
    0F8A0 95D8      ELPM
    0F8A1 2D30      MOV	R19,R0
    0F8A2 9009      LD	R0,Y+
    0F8A3 91F9      LD	R31,Y+
    0F8A4 91E9      LD	R30,Y+
    0F8A5 9508      RET
empy16s:
    0F8A6 920A      ST	-Y,R0
    0F8A7 921A      ST	-Y,R1
    0F8A8 938A      ST	-Y,R24
    0F8A9 939A      ST	-Y,R25
    0F8AA 9F02      MUL	R16,R18
    0F8AB 01C0      MOVW	R24,R0
    0F8AC 9F12      MUL	R17,R18
    0F8AD 0D90      ADD	R25,R0
    0F8AE 9F03      MUL	R16,R19
    0F8AF 0D90      ADD	R25,R0
    0F8B0 018C      MOVW	R16,R24
    0F8B1 9199      LD	R25,Y+
    0F8B2 9189      LD	R24,Y+
    0F8B3 9019      LD	R1,Y+
    0F8B4 9009      LD	R0,Y+
    0F8B5 9508      RET
empy32u|empy32s:
    0F8B6 940E F91C CALL	long_prolog
    0F8B8 927A      ST	-Y,R7
    0F8B9 940E F935 CALL	tstzero1
    0F8BB F159      BEQ	0xF8E7
    0F8BC 2477      CLR	R7
    0F8BD 940E F93B CALL	tstzero2
    0F8BF F419      BNE	0xF8C3
    0F8C0 018C      MOVW	R16,R24
    0F8C1 019D      MOVW	R18,R26
    0F8C2 C024      RJMP	0xF8E7
    0F8C3 920A      ST	-Y,R0
    0F8C4 921A      ST	-Y,R1
    0F8C5 9F08      MUL	R16,R24
    0F8C6 2CB0      MOV	R11,R0
    0F8C7 2CA1      MOV	R10,R1
    0F8C8 9F28      MUL	R18,R24
    0F8C9 2C90      MOV	R9,R0
    0F8CA 2C81      MOV	R8,R1
    0F8CB 9F18      MUL	R17,R24
    0F8CC 0CA0      ADD	R10,R0
    0F8CD 1C91      ADC	R9,R1
    0F8CE 1C87      ADC	R8,R7
    0F8CF 9F09      MUL	R16,R25
    0F8D0 0CA0      ADD	R10,R0
    0F8D1 1C91      ADC	R9,R1
    0F8D2 1C87      ADC	R8,R7
    0F8D3 9F19      MUL	R17,R25
    0F8D4 0C90      ADD	R9,R0
    0F8D5 1C81      ADC	R8,R1
    0F8D6 9F0A      MUL	R16,R26
    0F8D7 0C90      ADD	R9,R0
    0F8D8 1C81      ADC	R8,R1
    0F8D9 9F38      MUL	R19,R24
    0F8DA 0C80      ADD	R8,R0
    0F8DB 9F29      MUL	R18,R25
    0F8DC 0C80      ADD	R8,R0
    0F8DD 9F1A      MUL	R17,R26
    0F8DE 0C80      ADD	R8,R0
    0F8DF 9F0B      MUL	R16,R27
    0F8E0 0C80      ADD	R8,R0
    0F8E1 9019      LD	R1,Y+
    0F8E2 9009      LD	R0,Y+
    0F8E3 2D0B      MOV	R16,R11
    0F8E4 2D1A      MOV	R17,R10
    0F8E5 2D29      MOV	R18,R9
    0F8E6 2D38      MOV	R19,R8
    0F8E7 9079      LD	R7,Y+
    0F8E8 940C F92A JMP	long_epilog
pop_xgset003C:
    0F8EA 90A9      LD	R10,Y+
    0F8EB 90B9      LD	R11,Y+
    0F8EC 90C9      LD	R12,Y+
    0F8ED 90D9      LD	R13,Y+
    0F8EE 9508      RET
pop_xgsetF0FC:
    0F8EF 90A9      LD	R10,Y+
    0F8F0 90B9      LD	R11,Y+
    0F8F1 90C9      LD	R12,Y+
    0F8F2 90D9      LD	R13,Y+
    0F8F3 90E9      LD	R14,Y+
    0F8F4 90F9      LD	R15,Y+
    0F8F5 9149      LD	R20,Y+
    0F8F6 9159      LD	R21,Y+
    0F8F7 9169      LD	R22,Y+
    0F8F8 9179      LD	R23,Y+
    0F8F9 9508      RET
push_xgsetF0FC:
    0F8FA 937A      ST	-Y,R23
    0F8FB 936A      ST	-Y,R22
push_xgset30FC:
    0F8FC 935A      ST	-Y,R21
    0F8FD 934A      ST	-Y,R20
push_xgset00FC:
    0F8FE 92FA      ST	-Y,R15
    0F8FF 92EA      ST	-Y,R14
push_xgset003C:
    0F900 92DA      ST	-Y,R13
    0F901 92CA      ST	-Y,R12
    0F902 92BA      ST	-Y,R11
    0F903 92AA      ST	-Y,R10
    0F904 9508      RET
push_xgsetF00C:
    0F905 937A      ST	-Y,R23
    0F906 936A      ST	-Y,R22
    0F907 935A      ST	-Y,R21
    0F908 934A      ST	-Y,R20
    0F909 92BA      ST	-Y,R11
    0F90A 92AA      ST	-Y,R10
    0F90B 9508      RET
pop_xgsetF00C:
    0F90C 90A9      LD	R10,Y+
    0F90D 90B9      LD	R11,Y+
    0F90E 9149      LD	R20,Y+
    0F90F 9159      LD	R21,Y+
    0F910 9169      LD	R22,Y+
    0F911 9179      LD	R23,Y+
    0F912 9508      RET
neg32:
    0F913 9500      COM	R16
    0F914 9510      COM	R17
    0F915 9520      COM	R18
    0F916 9530      COM	R19
    0F917 5F0F      SUBI	R16,0xFF
    0F918 4F1F      SBCI	R17,0xFF
    0F919 4F2F      SBCI	R18,0xFF
    0F91A 4F3F      SBCI	R19,0xFF
    0F91B 9508      RET
long_prolog:
    0F91C 928A      ST	-Y,R8
    0F91D 929A      ST	-Y,R9
    0F91E 92AA      ST	-Y,R10
    0F91F 92BA      ST	-Y,R11
    0F920 93EA      ST	-Y,R30
    0F921 938A      ST	-Y,R24
    0F922 939A      ST	-Y,R25
    0F923 93AA      ST	-Y,R26
    0F924 93BA      ST	-Y,R27
    0F925 8589      LDD	R24,Y+9
    0F926 859A      LDD	R25,Y+10
    0F927 85AB      LDD	R26,Y+11
    0F928 85BC      LDD	R27,Y+12
    0F929 9508      RET
long_epilog:
    0F92A 91B9      LD	R27,Y+
    0F92B 91A9      LD	R26,Y+
    0F92C 9199      LD	R25,Y+
    0F92D 9189      LD	R24,Y+
    0F92E 91E9      LD	R30,Y+
    0F92F 90B9      LD	R11,Y+
    0F930 90A9      LD	R10,Y+
    0F931 9099      LD	R9,Y+
    0F932 9089      LD	R8,Y+
    0F933 9624      ADIW	R28,4
    0F934 9508      RET
tstzero1:
    0F935 27EE      CLR	R30
    0F936 2BE0      OR	R30,R16
    0F937 2BE1      OR	R30,R17
    0F938 2BE2      OR	R30,R18
    0F939 2BE3      OR	R30,R19
    0F93A 9508      RET
tstzero2:
    0F93B 27EE      CLR	R30
    0F93C 2BE8      OR	R30,R24
    0F93D 2BE9      OR	R30,R25
    0F93E 2BEA      OR	R30,R26
    0F93F 2BEB      OR	R30,R27
    0F940 9508      RET
fpint:
    0F941 924A      ST	-Y,R4
    0F942 925A      ST	-Y,R5
    0F943 926A      ST	-Y,R6
    0F944 938A      ST	-Y,R24
    0F945 940E F9A7 CALL	unpacku
    0F947 F111      BEQ	0xF96A
    0F948 2055      TST	R5
    0F949 F0E2      BMI	0xF966
    0F94A E18F      LDI	R24,0x1F
    0F94B 1648      CP	R4,R24
    0F94C F4C0      BCC	0xF965
    0F94D E187      LDI	R24,0x17
    0F94E 1648      CP	R4,R24
    0F94F F0D1      BEQ	0xF96A
    0F950 F458      BCC	0xF95C
    0F951 9441      NEG	R4
    0F952 EE89      LDI	R24,0xE9
    0F953 1A48      SUB	R4,R24
    0F954 C005      RJMP	0xF95A
    0F955 9535      ASR	R19
    0F956 9527      ROR	R18
    0F957 9517      ROR	R17
    0F958 9507      ROR	R16
    0F959 944A      DEC	R4
    0F95A F7D1      BNE	0xF955
    0F95B C00E      RJMP	0xF96A
    0F95C E187      LDI	R24,0x17
    0F95D 1A48      SUB	R4,R24
    0F95E 0F00      LSL	R16
    0F95F 1F11      ROL	R17
    0F960 1F22      ROL	R18
    0F961 1F33      ROL	R19
    0F962 944A      DEC	R4
    0F963 F7D1      BNE	0xF95E
    0F964 C005      RJMP	0xF96A
    0F965 E73F      LDI	R19,0x7F
    0F966 2F23      MOV	R18,R19
    0F967 2F13      MOV	R17,R19
    0F968 2F03      MOV	R16,R19
    0F969 C004      RJMP	0xF96E
    0F96A 2066      TST	R6
    0F96B F011      BEQ	0xF96E
    0F96C 940E F913 CALL	neg32
    0F96E 9189      LD	R24,Y+
    0F96F 9069      LD	R6,Y+
    0F970 9059      LD	R5,Y+
    0F971 9049      LD	R4,Y+
    0F972 9508      RET
uint2fp:
    0F973 9468      BSET	6
    0F974 C001      RJMP	0xF976
int2fp:
    0F975 94E8      BCLR	6
    0F976 2722      CLR	R18
    0F977 2733      CLR	R19
    0F978 F046      BRTS	0xF981
    0F979 FD17      SBRC	R17,7
    0F97A 9520      COM	R18
    0F97B FD17      SBRC	R17,7
    0F97C 9530      COM	R19
    0F97D C003      RJMP	0xF981
ulong2fp:
    0F97E 9468      BSET	6
    0F97F C001      RJMP	0xF981
long2fp:
    0F980 94E8      BCLR	6
    0F981 924A      ST	-Y,R4
    0F982 925A      ST	-Y,R5
    0F983 926A      ST	-Y,R6
    0F984 938A      ST	-Y,R24
    0F985 E187      LDI	R24,0x17
    0F986 2E48      MOV	R4,R24
    0F987 2455      CLR	R5
    0F988 2466      CLR	R6
    0F989 F036      BRTS	0xF990
    0F98A 2333      TST	R19
    0F98B F422      BPL	0xF990
    0F98C 940E F913 CALL	neg32
    0F98E E880      LDI	R24,0x80
    0F98F 2E68      MOV	R6,R24
    0F990 940E F9C0 CALL	normalize_and_pack
    0F992 9189      LD	R24,Y+
    0F993 9069      LD	R6,Y+
    0F994 9059      LD	R5,Y+
    0F995 9049      LD	R4,Y+
    0F996 9508      RET
unpacks:
    0F997 D00F      RCALL	unpacku
    0F998 F029      BEQ	0xF99E
    0F999 2066      TST	R6
    0F99A F011      BEQ	0xF99D
    0F99B 940E F913 CALL	neg32
    0F99D 9498      BCLR	1
    0F99E 9508      RET
tstR16_R19:
    0F99F 2300      TST	R16
    0F9A0 F429      BNE	0xF9A6
    0F9A1 2311      TST	R17
    0F9A2 F419      BNE	0xF9A6
    0F9A3 2322      TST	R18
    0F9A4 F409      BNE	0xF9A6
    0F9A5 2333      TST	R19
    0F9A6 9508      RET
unpacku:
    0F9A7 DFF7      RCALL	tstR16_R19
    0F9A8 F099      BEQ	0xF9BC
    0F9A9 938A      ST	-Y,R24
    0F9AA 2E63      MOV	R6,R19
    0F9AB E880      LDI	R24,0x80
    0F9AC 2268      AND	R6,R24
    0F9AD 0F22      LSL	R18
    0F9AE 1F33      ROL	R19
    0F9AF 2E43      MOV	R4,R19
    0F9B0 E78F      LDI	R24,0x7F
    0F9B1 1A48      SUB	R4,R24
    0F9B2 2455      CLR	R5
    0F9B3 2788      CLR	R24
    0F9B4 0A58      SBC	R5,R24
    0F9B5 9526      LSR	R18
    0F9B6 E830      LDI	R19,0x80
    0F9B7 2B23      OR	R18,R19
    0F9B8 2733      CLR	R19
    0F9B9 9189      LD	R24,Y+
    0F9BA 9498      BCLR	1
    0F9BB 9508      RET
    0F9BC 2444      CLR	R4
    0F9BD 2455      CLR	R5
    0F9BE 2466      CLR	R6
    0F9BF 9508      RET
normalize_and_pack:
    0F9C0 DFDE      RCALL	tstR16_R19
    0F9C1 F409      BNE	0xF9C3
    0F9C2 9508      RET
    0F9C3 93AA      ST	-Y,R26
    0F9C4 93BA      ST	-Y,R27
    0F9C5 01D2      MOVW	R26,R4
    0F9C6 939A      ST	-Y,R25
    0F9C7 938A      ST	-Y,R24
    0F9C8 E78E      LDI	R24,0x7E
    0F9C9 E090      LDI	R25,0
    0F9CA 2333      TST	R19
    0F9CB F049      BEQ	0xF9D5
    0F9CC 9536      LSR	R19
    0F9CD 9527      ROR	R18
    0F9CE 9517      ROR	R17
    0F9CF 9507      ROR	R16
    0F9D0 17A8      CP	R26,R24
    0F9D1 07B9      CPC	R27,R25
    0F9D2 F4CC      BGE	0xF9EC
    0F9D3 9611      ADIW	R26,1
    0F9D4 CFF5      RJMP	0xF9CA
    0F9D5 9580      COM	R24
    0F9D6 9590      COM	R25
    0F9D7 9601      ADIW	R24,1
    0F9D8 2322      TST	R18
    0F9D9 F0BA      BMI	0xF9F1
    0F9DA 0F00      LSL	R16
    0F9DB 1F11      ROL	R17
    0F9DC 1F22      ROL	R18
    0F9DD 17A8      CP	R26,R24
    0F9DE 07B9      CPC	R27,R25
    0F9DF F014      BLT	0xF9E2
    0F9E0 9711      SBIW	R26,1
    0F9E1 CFF6      RJMP	0xF9D8
    0F9E2 2700      CLR	R16
    0F9E3 2711      CLR	R17
    0F9E4 2722      CLR	R18
    0F9E5 2733      CLR	R19
    0F9E6 9189      LD	R24,Y+
    0F9E7 9199      LD	R25,Y+
    0F9E8 012D      MOVW	R4,R26
    0F9E9 91B9      LD	R27,Y+
    0F9EA 91A9      LD	R26,Y+
    0F9EB 9508      RET
    0F9EC 2733      CLR	R19
    0F9ED EF0F      LDI	R16,0xFF
    0F9EE 2F10      MOV	R17,R16
    0F9EF E72F      LDI	R18,0x7F
    0F9F0 2F32      MOV	R19,R18
    0F9F1 9189      LD	R24,Y+
    0F9F2 9199      LD	R25,Y+
    0F9F3 012D      MOVW	R4,R26
    0F9F4 C002      RJMP	0xF9F7
pack:
    0F9F5 93AA      ST	-Y,R26
    0F9F6 93BA      ST	-Y,R27
    0F9F7 DFA7      RCALL	tstR16_R19
    0F9F8 F049      BEQ	0xFA02
    0F9F9 01D2      MOVW	R26,R4
    0F9FA 58A1      SUBI	R26,0x81
    0F9FB 4FBF      SBCI	R27,0xFF
    0F9FC 012D      MOVW	R4,R26
    0F9FD 2D34      MOV	R19,R4
    0F9FE 0F22      LSL	R18
    0F9FF 9536      LSR	R19
    0FA00 9527      ROR	R18
    0FA01 2936      OR	R19,R6
    0FA02 91B9      LD	R27,Y+
    0FA03 91A9      LD	R26,Y+
    0FA04 9508      RET
saveFPRegs:
    0FA05 924A      ST	-Y,R4
    0FA06 925A      ST	-Y,R5
    0FA07 926A      ST	-Y,R6
    0FA08 927A      ST	-Y,R7
    0FA09 928A      ST	-Y,R8
    0FA0A 929A      ST	-Y,R9
    0FA0B 92AA      ST	-Y,R10
    0FA0C 92BA      ST	-Y,R11
    0FA0D 92CA      ST	-Y,R12
    0FA0E 92DA      ST	-Y,R13
    0FA0F 92EA      ST	-Y,R14
    0FA10 92FA      ST	-Y,R15
    0FA11 938A      ST	-Y,R24
    0FA12 939A      ST	-Y,R25
    0FA13 9508      RET
restoreFPRegs:
    0FA14 9199      LD	R25,Y+
    0FA15 9189      LD	R24,Y+
    0FA16 90F9      LD	R15,Y+
    0FA17 90E9      LD	R14,Y+
    0FA18 90D9      LD	R13,Y+
    0FA19 90C9      LD	R12,Y+
    0FA1A 90B9      LD	R11,Y+
    0FA1B 90A9      LD	R10,Y+
    0FA1C 9099      LD	R9,Y+
    0FA1D 9089      LD	R8,Y+
    0FA1E 9079      LD	R7,Y+
    0FA1F 9069      LD	R6,Y+
    0FA20 9059      LD	R5,Y+
    0FA21 9049      LD	R4,Y+
    0FA22 9508      RET
fpmule:
    0FA23 940E FA05 CALL	saveFPRegs
    0FA25 93AA      ST	-Y,R26
    0FA26 93BA      ST	-Y,R27
    0FA27 940E F9A7 CALL	unpacku
    0FA29 F1E1      BEQ	0xFA66
    0FA2A 2CE6      MOV	R14,R6
    0FA2B 2CD5      MOV	R13,R5
    0FA2C 2CC4      MOV	R12,R4
    0FA2D 2EB3      MOV	R11,R19
    0FA2E 2EA2      MOV	R10,R18
    0FA2F 2E91      MOV	R9,R17
    0FA30 2E80      MOV	R8,R16
    0FA31 8100      LD	R16,Z
    0FA32 8111      LDD	R17,Z+1
    0FA33 8122      LDD	R18,Z+2
    0FA34 8133      LDD	R19,Z+3
    0FA35 940E F9A7 CALL	unpacku
    0FA37 F171      BEQ	0xFA66
    0FA38 246E      EOR	R6,R14
    0FA39 0C4C      ADD	R4,R12
    0FA3A 1C5D      ADC	R5,R13
    0FA3B E880      LDI	R24,0x80
    0FA3C 1648      CP	R4,R24
    0FA3D 0653      CPC	R5,R19
    0FA3E F564      BGE	0xFA6B
    0FA3F E881      LDI	R24,0x81
    0FA40 1648      CP	R4,R24
    0FA41 EF8F      LDI	R24,0xFF
    0FA42 0658      CPC	R5,R24
    0FA43 F16C      BLT	0xFA71
    0FA44 9EA2      MUL	R10,R18
    0FA45 2DB1      MOV	R27,R1
    0FA46 2DA0      MOV	R26,R0
    0FA47 9E91      MUL	R9,R17
    0FA48 2D91      MOV	R25,R1
    0FA49 2D80      MOV	R24,R0
    0FA4A 9EA0      MUL	R10,R16
    0FA4B 0D80      ADD	R24,R0
    0FA4C 1D91      ADC	R25,R1
    0FA4D 1FA3      ADC	R26,R19
    0FA4E 1FB3      ADC	R27,R19
    0FA4F 9E82      MUL	R8,R18
    0FA50 0D80      ADD	R24,R0
    0FA51 1D91      ADC	R25,R1
    0FA52 1FA3      ADC	R26,R19
    0FA53 1FB3      ADC	R27,R19
    0FA54 9E92      MUL	R9,R18
    0FA55 0D90      ADD	R25,R0
    0FA56 1DA1      ADC	R26,R1
    0FA57 1FB3      ADC	R27,R19
    0FA58 9EA1      MUL	R10,R17
    0FA59 0D90      ADD	R25,R0
    0FA5A 1DA1      ADC	R26,R1
    0FA5B 1FB3      ADC	R27,R19
    0FA5C 2F2B      MOV	R18,R27
    0FA5D 2F1A      MOV	R17,R26
    0FA5E 2F09      MOV	R16,R25
    0FA5F 0F88      LSL	R24
    0FA60 1F00      ROL	R16
    0FA61 1F11      ROL	R17
    0FA62 1F22      ROL	R18
    0FA63 1F33      ROL	R19
    0FA64 940E F9C0 CALL	normalize_and_pack
    0FA66 91B9      LD	R27,Y+
    0FA67 91A9      LD	R26,Y+
    0FA68 940E FA14 CALL	restoreFPRegs
    0FA6A 9508      RET
    0FA6B EF0F      LDI	R16,0xFF
    0FA6C 2F10      MOV	R17,R16
    0FA6D E72F      LDI	R18,0x7F
    0FA6E E78F      LDI	R24,0x7F
    0FA6F 2E48      MOV	R4,R24
    0FA70 CFF5      RJMP	0xFA66
    0FA71 2700      CLR	R16
    0FA72 2F10      MOV	R17,R16
    0FA73 2F20      MOV	R18,R16
    0FA74 2F30      MOV	R19,R16
    0FA75 CFF0      RJMP	0xFA66
fpmule1:
    0FA76 93FA      ST	-Y,R31
    0FA77 93EA      ST	-Y,R30
    0FA78 81EA      LDD	R30,Y+2
    0FA79 81FB      LDD	R31,Y+3
    0FA7A 940E FA23 CALL	fpmule
    0FA7C 91E9      LD	R30,Y+
    0FA7D 91F9      LD	R31,Y+
    0FA7E 9622      ADIW	R28,2
    0FA7F 9508      RET
