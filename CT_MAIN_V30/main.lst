Interrupt Vectors
    00000 940C 004E JMP	__start|__text_start
    00002 940C 0071 JMP	_int0_isr
    00020 940C 04C6 JMP	_timer0_ovf_isr
    00024 940C 04A5 JMP	_uart0_rx_isr
    0003C 940C 0291 JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    0004E EFCF      LDI	R28,0xFF
    0004F E1D0      LDI	R29,0x10
    00050 BFCD      OUT	0x3D,R28
    00051 BFDE      OUT	0x3E,R29
    00052 50C0      SUBI	R28,0
    00053 40D1      SBCI	R29,1
    00054 EA0A      LDI	R16,0xAA
    00055 8308      ST	Y,R16
    00056 2400      CLR	R0
    00057 E0E0      LDI	R30,0
    00058 E0F1      LDI	R31,1
    00059 E013      LDI	R17,3
    0005A 34EC      CPI	R30,0x4C
    0005B 07F1      CPC	R31,R17
    0005C F011      BEQ	0x005F
    0005D 9201      ST	Z+,R0
    0005E CFFB      RJMP	0x005A
    0005F 8300      ST	Z,R16
    00060 E9EC      LDI	R30,0x9C
    00061 E0F0      LDI	R31,0
    00062 E0A0      LDI	R26,0
    00063 E0B1      LDI	R27,1
    00064 E010      LDI	R17,0
    00065 E000      LDI	R16,0
    00066 BF0B      OUT	0x3B,R16
    00067 39EC      CPI	R30,0x9C
    00068 07F1      CPC	R31,R17
    00069 F021      BEQ	0x006E
    0006A 95C8      LPM
    0006B 9631      ADIW	R30,1
    0006C 920D      ST	X+,R0
    0006D CFF9      RJMP	0x0067
    0006E 940E 065A CALL	_main
_exit:
    00070 CFFF      RJMP	_exit
_int0_isr:
    00071 922A      ST	-Y,R2
    00072 923A      ST	-Y,R3
    00073 938A      ST	-Y,R24
    00074 939A      ST	-Y,R25
    00075 93AA      ST	-Y,R26
    00076 93EA      ST	-Y,R30
    00077 93FA      ST	-Y,R31
    00078 B62F      IN	R2,0x3F
    00079 922A      ST	-Y,R2
FILE: D:\chen\Core\FirmWare_CT\CT_MAIN_V30\main.c
(0001)  /**************************************************
(0002) CTZK
(0003) //20161110 增加了全部采样的CRC16校验
(0004) //20161113 改进了流量数据中时间和相位由无符号短整型转为浮点数时的转换方法，以防上位机软件出现相位超大值
(0005) //20161224 将电机断流判断值由26mA改为13mA，因为目前调节电机工作时空载电流值仅为23~28mA，升级版本为V4.0
(0006) //20161229 修改收张电机的本电机同向和反向判断，修改调节电机的电机方向控制（与原来相反）
(0007) //20170308 流量采样增加校验帧，升级版本为V4.2
(0008) //20170607 电机断路电流由原来的13mA改为26mA 升级版本为V4.3
(0009) //20170608 改动电机过流档位并把最大档位提升到250mA，升级版本为V4.4
(0010) //20170609 加入调节电机微调功能，升级版本为V4.5
(0011) //20170613 增加电机断路电流上位机可设定(共6档)，增加调节电机微调时间由电机命令中自带参数，改上传电流由数字量为工程量（单位mA），堵转电流上传改为档位，版本升为V4.6
(0012) //20170614 上传的电缆电压也改为工程量，全部采样增加电缆电压
(0013) //20170622  为适应新高压电机驱动的电路板而改进一些功能，版本回退到V3.0
(0014) //20170701 为适应新电路板CT_MAIN_V30
(0015) //20170703 增加独立压力短节单芯内部总线通讯功能
(0016) //20170703 版本从6.0起步，为了与前一阶段的硬件相区别
(0017) //20170705 压力短节功能调通 V6.1
(0018) //20170711  版本回退到V1.0，方便以后的功能扩展
(0019) //20170817  升级版本到V1.1，增加了绝对时间差法流量计的功能支持
(0020) **************************************************/
(0021) #include <iom128v.h>								   	
(0022) #include <macros.h>
(0023) #include <stdio.h>
(0024) 
(0025)  
(0026) #define Debug 0
(0027) #define  BB     0x11       //固件版本号
(0028) 
(0029) 
(0030) #define M1_L     {PORTG&=0xf7;}
(0031) #define M1_H     {PORTG|=0x08;}
(0032) #define M2_L     {PORTG&=0xef;}
(0033) #define M2_H     {PORTG|=0x10;}
(0034) 
(0035)  
(0036) 
(0037) 
(0038) #define MANINT_CLR	{ EIFR|=0x01; }
(0039) #define MANINT_EN	{ EIMSK |= 0x01; }
(0040) #define MANINT_DIS	{ EIMSK &= 0xFE; }
(0041) 
(0042) #define INT_EN			{ SEI(); }
(0043) #define INT_DIS		{ CLI(); }
(0044) 
(0045)  
(0046)     
(0047) #define TPSBAUD  {TCNT3H = 0xFE;TCNT3L = 0x60;}
(0048)  
(0049) 
(0050) #define DELAY10 for(Tt=0;Tt<4;Tt++);
(0051) #define DELAY20 for(Tt=0;Tt<4;Tt++);
(0052) #define DELAY40 for(Tt=0;Tt<16;Tt++); 
(0053) #define DELAY50 for(Tt=0;Tt<21;Tt++); 
(0054) #define DELAY80 for(Tt=0;Tt<32;Tt++); 
(0055) #define DELAY89 for(Tt=0;Tt<36;Tt++); 
(0056) #define DELAY100 for(Tt=0;Tt<42;Tt++); 
(0057) #define DELAY170 for(Tt=0;Tt<72;Tt++);
(0058) #define DELAY268 for(Tt=0;Tt<113;Tt++);
(0059) #define DELAY397 for(Tt=0;Tt<165;Tt++);
(0060) #define DELAY400 for(Tt=0;Tt<168;Tt++);
(0061) 
(0062) /* 接收电平值 */
(0063) #define GET_RX() (PIND & (1<<PIND1))  
(0064) /* 发送高电平 */   
(0065) #define SET_TX() (PORTD |= 0x40)
(0066) /* 发送低电平 */ 
(0067) #define CLR_TX() (PORTD &= 0xbf)
(0068)         
(0069) 
(0070)  
(0071) 
(0072) /* 定时器中断发生时的读写周期 */
(0073) enum timer_turn {   
(0074)  RX_TURN = 0,                /* 读周期 */    
(0075)  TX_TURN,                    /* 写周期 */
(0076)  };
(0077)  
(0078) /* 数据帧结构 */
(0079) __flash enum frame_bit {    BIT_0 = 0,    BIT_1,    BIT_2,    BIT_3,    BIT_4,    BIT_5,    BIT_6,    BIT_7,    BIT_STOP,    BIT_IDLE,    BIT_START,};
(0080) 
(0081) union FIB
(0082) {
(0083)  float f;
(0084)  unsigned int i[2];
(0085)  unsigned char b[4];
(0086) }myFIB;
(0087) 
(0088)  
(0089)  
(0090)  
(0091) 
(0092) unsigned char T_Flag;
(0093) 
(0094) unsigned int Timer0Counter;//定时器0超过4ms时的计数
(0095) 
(0096) unsigned char Uart0RxData[74];//串口0接收数据缓存
(0097) unsigned char Uart0RxCounter;
(0098) 
(0099) unsigned char Uart1RxData[4];//串口1接收数据缓存
(0100) unsigned char Uart1RxCounter;
(0101) 
(0102) unsigned char Rx[18];//解码接收9位共18个半位
(0103) int  T_dat,R_dat;//曼码发送数据
(0104) int TPS_PData,TPS_TData;
(0105) unsigned char T_com;//曼码发送命令
(0106) 
(0107) unsigned char TimeOutFlag;//发送超时标志
(0108) 
(0109) unsigned char T_dat_buf[22];//曼码发送缓冲 
(0110) 
(0111) unsigned int DataFlag;//下发标定系数开始标志
(0112) unsigned char Int_count;
(0113) unsigned char IntFlag;//接收帧状态
(0114) 
(0115) unsigned int Tt,k;
(0116) unsigned int T2cn;
(0117) unsigned char coeffdata[320];
(0118) 
(0119) unsigned char Uart0TxData[74];//串口发送数据缓存
(0120) 
(0121) unsigned char EEPAdd;//接收系数存放地址索引
(0122) unsigned int coeff_len,coeff_count;//接收系数长度，接收系数计数
(0123) unsigned int CompCounter;
(0124) 
(0125) unsigned int bf;
(0126) 
(0127) unsigned long lfib;//短整型转浮点数时用的临时变量
(0128) unsigned char crc16hi,crc16lo,crc16array[32];
(0129) 
(0130) 
(0131) 
(0132) 
(0133) void InitialIO(void);
(0134) void init_USART0(void);
(0135) void SendUart0_2(unsigned char len,unsigned int s);
(0136) void SendUart0_3(unsigned char len,unsigned int s,unsigned char cn);
(0137) void Pwm_startup(unsigned char motor);
(0138) void Start(void);
(0139) void SendManchester(void); 
(0140) unsigned char SampleADC(unsigned char ch);
(0141) void EEPROM_write(unsigned int Address,unsigned char Data);
(0142) unsigned char EEPROM_read(unsigned int Address);
(0143) void Delay_ms(unsigned int t);
(0144) void crc16(unsigned char r_data[],unsigned int length);
(0145)  
(0146) void int0_isr(void);
(0147) 
(0148) #pragma interrupt_handler int0_isr:iv_INT0
(0149) void int0_isr(void)//外部中断0
(0150) { 
(0151)    TCCR2 = 0x00; //stop
    0007A 2422      CLR	R2
    0007B BC25      OUT	0x25,R2
(0152)    
(0153)     INT_DIS
    0007C 94F8      BCLR	7
(0154) 	MANINT_DIS
    0007D B789      IN	R24,0x39
    0007E 7F8E      ANDI	R24,0xFE
    0007F BF89      OUT	0x39,R24
(0155)    
(0156)   DELAY10
    00080 2433      CLR	R3
    00081 9230 02BE STS	Tt+1,R3
    00083 9220 02BD STS	Tt,R2
    00085 C009      RJMP	0x008F
    00086 9180 02BD LDS	R24,Tt
    00088 9190 02BE LDS	R25,Tt+1
    0008A 9601      ADIW	R24,1
    0008B 9390 02BE STS	Tt+1,R25
    0008D 9380 02BD STS	Tt,R24
    0008F 9180 02BD LDS	R24,Tt
    00091 9190 02BE LDS	R25,Tt+1
    00093 3084      CPI	R24,4
    00094 E0E0      LDI	R30,0
    00095 079E      CPC	R25,R30
    00096 F378      BCS	0x0086
(0157)   EIFR|=0x01;//清INT0中断标志 
    00097 B788      IN	R24,0x38
    00098 6081      ORI	R24,1
    00099 BF88      OUT	0x38,R24
(0158)   if((PIND&0x01)==0x00)//高脉冲不足10us则直接跳出
    0009A 9980      SBIC	0x10,0
    0009B C001      RJMP	0x009D
(0159)   {
(0160)    goto End;
    0009C C1C0      RJMP	0x025D
(0161)   }
(0162)    
(0163)    TCNT2 = 0x00;  
    0009D 2422      CLR	R2
    0009E BC24      OUT	0x24,R2
(0164)    TCCR2 = 0x03; //64分频,8M时钟，每个CLOCK耗时8us，最大定时2048us，每周期10个计数
    0009F E083      LDI	R24,3
    000A0 BD85      OUT	0x25,R24
    000A1 C029      RJMP	0x00CB
(0165)    
(0166)    while(1)
(0167)    {
(0168)      T2cn=TCNT2;
    000A2 B424      IN	R2,0x24
    000A3 2433      CLR	R3
    000A4 9230 02BA STS	T2cn+1,R3
    000A6 9220 02B9 STS	T2cn,R2
(0169) 	  if(T2cn>80)//设计值最多7个周期，在此多给一个周期，则超过8个周期还没来上升沿中断到来就直接跳出
    000A8 E580      LDI	R24,0x50
    000A9 E090      LDI	R25,0
    000AA 1582      CP	R24,R2
    000AB 0593      CPC	R25,R3
    000AC F408      BCC	0x00AE
(0170) 	  {
(0171) 	    goto End;
    000AD C1AF      RJMP	0x025D
(0172) 	  }
(0173)      if((PIND&0x01)==0x00)
    000AE 9980      SBIC	0x10,0
    000AF C01B      RJMP	0x00CB
(0174) 	 {
(0175) 	   DELAY20
    000B0 2422      CLR	R2
    000B1 2433      CLR	R3
    000B2 9230 02BE STS	Tt+1,R3
    000B4 9220 02BD STS	Tt,R2
    000B6 C009      RJMP	0x00C0
    000B7 9180 02BD LDS	R24,Tt
    000B9 9190 02BE LDS	R25,Tt+1
    000BB 9601      ADIW	R24,1
    000BC 9390 02BE STS	Tt+1,R25
    000BE 9380 02BD STS	Tt,R24
    000C0 9180 02BD LDS	R24,Tt
    000C2 9190 02BE LDS	R25,Tt+1
    000C4 3084      CPI	R24,4
    000C5 E0E0      LDI	R30,0
    000C6 079E      CPC	R25,R30
    000C7 F378      BCS	0x00B7
(0176) 	   if((PIND&0x01)==0x00)
    000C8 9980      SBIC	0x10,0
    000C9 C001      RJMP	0x00CB
(0177) 	    {
(0178) 	      break;
    000CA C031      RJMP	0x00FC
    000CB CFD6      RJMP	0x00A2
(0179) 	    }
(0180) 	 }
(0181)    }
(0182)   		   
(0183)     //开始判断同步头	
(0184) 	while(1)//还没有上升沿到来,死等
(0185) 	{
(0186) 	  T2cn=TCNT2;
    000CC B424      IN	R2,0x24
    000CD 2433      CLR	R3
    000CE 9230 02BA STS	T2cn+1,R3
    000D0 9220 02B9 STS	T2cn,R2
(0187) 	  if(T2cn>80)//设计值最多7个周期，在此多给一个周期，则超过8个周期还没来上升沿中断到来就直接跳出
    000D2 E580      LDI	R24,0x50
    000D3 E090      LDI	R25,0
    000D4 1582      CP	R24,R2
    000D5 0593      CPC	R25,R3
    000D6 F408      BCC	0x00D8
(0188) 	  {
(0189) 	    goto End;
    000D7 C185      RJMP	0x025D
(0190) 	  }
(0191) 	  if((EIFR&0x01)==0x01)
    000D8 B788      IN	R24,0x38
    000D9 7081      ANDI	R24,1
    000DA 3081      CPI	R24,1
    000DB F501      BNE	0x00FC
(0192) 	  {
(0193) 	   DELAY10
    000DC 2422      CLR	R2
    000DD 2433      CLR	R3
    000DE 9230 02BE STS	Tt+1,R3
    000E0 9220 02BD STS	Tt,R2
    000E2 C009      RJMP	0x00EC
    000E3 9180 02BD LDS	R24,Tt
    000E5 9190 02BE LDS	R25,Tt+1
    000E7 9601      ADIW	R24,1
    000E8 9390 02BE STS	Tt+1,R25
    000EA 9380 02BD STS	Tt,R24
    000EC 9180 02BD LDS	R24,Tt
    000EE 9190 02BE LDS	R25,Tt+1
    000F0 3084      CPI	R24,4
    000F1 E0E0      LDI	R30,0
    000F2 079E      CPC	R25,R30
    000F3 F378      BCS	0x00E3
(0194) 	   EIFR|=0x01;//清INT0中断标志 
    000F4 B788      IN	R24,0x38
    000F5 6081      ORI	R24,1
    000F6 BF88      OUT	0x38,R24
(0195) 	   if((PIND&0x01)==0x01)//高脉冲维持了10us，则认为是下一个有效上升沿到来
    000F7 B380      IN	R24,0x10
    000F8 7081      ANDI	R24,1
    000F9 3081      CPI	R24,1
    000FA F409      BNE	0x00FC
(0196) 	     {
(0197)    	     break;
    000FB C001      RJMP	0x00FD
    000FC CFCF      RJMP	0x00CC
(0198) 		 }
(0199) 	  }  
(0200) 	}
(0201) 	T2cn=TCNT2;
    000FD B424      IN	R2,0x24
    000FE 2433      CLR	R3
    000FF 9230 02BA STS	T2cn+1,R3
    00101 9220 02B9 STS	T2cn,R2
(0202) 	TCNT2=0;
    00103 2422      CLR	R2
    00104 BC24      OUT	0x24,R2
(0203) 	if((T2cn<60)||(T2cn>80))//同步头本应是7个周期，但收到的结果为6~8个周期内都认可
    00105 9020 02B9 LDS	R2,T2cn
    00107 9030 02BA LDS	R3,T2cn+1
    00109 01C1      MOVW	R24,R2
    0010A 338C      CPI	R24,0x3C
    0010B E0E0      LDI	R30,0
    0010C 079E      CPC	R25,R30
    0010D F028      BCS	0x0113
    0010E E580      LDI	R24,0x50
    0010F E090      LDI	R25,0
    00110 1582      CP	R24,R2
    00111 0593      CPC	R25,R3
    00112 F408      BCC	0x0114
(0204) 	{
(0205) 	 goto End;//没有收到正确的同步头，直接跳出
    00113 C149      RJMP	0x025D
(0206) 	}
(0207)  
(0208) Start:	//同步头解码正确，下面开始接收9位数据位	//按位从高到低接收数据位，8位数据加1位校验共9位 		      	
(0209)   for(Int_count=9;Int_count>0;Int_count--)
    00114 E089      LDI	R24,0x9
    00115 9380 02C0 STS	Int_count,R24
    00117 C0A6      RJMP	0x01BE
(0210)   {	
(0211)    while(1)
(0212)    {
(0213)      T2cn=TCNT2;
    00118 B424      IN	R2,0x24
    00119 2433      CLR	R3
    0011A 9230 02BA STS	T2cn+1,R3
    0011C 9220 02B9 STS	T2cn,R2
(0214) 	  if(T2cn>80)//设计值最多7个周期，在此多给一个周期，则超过8个周期还没来上升沿中断到来就直接跳出
    0011E E580      LDI	R24,0x50
    0011F E090      LDI	R25,0
    00120 1582      CP	R24,R2
    00121 0593      CPC	R25,R3
    00122 F408      BCC	0x0124
(0215) 	  {
(0216) 	    goto End;
    00123 C139      RJMP	0x025D
(0217) 	  }
(0218)      if((PIND&0x01)==0x00)
    00124 9980      SBIC	0x10,0
    00125 C01B      RJMP	0x0141
(0219) 	 {
(0220) 	   DELAY20
    00126 2422      CLR	R2
    00127 2433      CLR	R3
    00128 9230 02BE STS	Tt+1,R3
    0012A 9220 02BD STS	Tt,R2
    0012C C009      RJMP	0x0136
    0012D 9180 02BD LDS	R24,Tt
    0012F 9190 02BE LDS	R25,Tt+1
    00131 9601      ADIW	R24,1
    00132 9390 02BE STS	Tt+1,R25
    00134 9380 02BD STS	Tt,R24
    00136 9180 02BD LDS	R24,Tt
    00138 9190 02BE LDS	R25,Tt+1
    0013A 3084      CPI	R24,4
    0013B E0E0      LDI	R30,0
    0013C 079E      CPC	R25,R30
    0013D F378      BCS	0x012D
(0221) 	   if((PIND&0x01)==0x00)
    0013E 9980      SBIC	0x10,0
    0013F C001      RJMP	0x0141
(0222) 	    {
(0223) 	      break;
    00140 C031      RJMP	0x0172
    00141 CFD6      RJMP	0x0118
(0224) 	    }
(0225) 	 }
(0226)    } 
(0227)    while(1)//还没有上升沿到来,死等
(0228) 	{
(0229) 	  T2cn=TCNT2;
    00142 B424      IN	R2,0x24
    00143 2433      CLR	R3
    00144 9230 02BA STS	T2cn+1,R3
    00146 9220 02B9 STS	T2cn,R2
(0230) 	  if(T2cn>80)//设计值最多7个周期，在此多给一个周期，则超过8个周期还没来上升沿中断到来就直接跳出
    00148 E580      LDI	R24,0x50
    00149 E090      LDI	R25,0
    0014A 1582      CP	R24,R2
    0014B 0593      CPC	R25,R3
    0014C F408      BCC	0x014E
(0231) 	  {
(0232) 	    goto End;
    0014D C10F      RJMP	0x025D
(0233) 	  }
(0234) 	  if((EIFR&0x01)==0x01)
    0014E B788      IN	R24,0x38
    0014F 7081      ANDI	R24,1
    00150 3081      CPI	R24,1
    00151 F501      BNE	0x0172
(0235) 	  {
(0236) 	   DELAY10
    00152 2422      CLR	R2
    00153 2433      CLR	R3
    00154 9230 02BE STS	Tt+1,R3
    00156 9220 02BD STS	Tt,R2
    00158 C009      RJMP	0x0162
    00159 9180 02BD LDS	R24,Tt
    0015B 9190 02BE LDS	R25,Tt+1
    0015D 9601      ADIW	R24,1
    0015E 9390 02BE STS	Tt+1,R25
    00160 9380 02BD STS	Tt,R24
    00162 9180 02BD LDS	R24,Tt
    00164 9190 02BE LDS	R25,Tt+1
    00166 3084      CPI	R24,4
    00167 E0E0      LDI	R30,0
    00168 079E      CPC	R25,R30
    00169 F378      BCS	0x0159
(0237) 	   EIFR|=0x01;//清INT0中断标志 
    0016A B788      IN	R24,0x38
    0016B 6081      ORI	R24,1
    0016C BF88      OUT	0x38,R24
(0238) 	   if((PIND&0x01)==0x01)//高脉冲维持了10us，则认为是下一个有效上升沿到来
    0016D B380      IN	R24,0x10
    0016E 7081      ANDI	R24,1
    0016F 3081      CPI	R24,1
    00170 F409      BNE	0x0172
(0239) 	     {
(0240)    	     break;
    00171 C001      RJMP	0x0173
    00172 CFCF      RJMP	0x0142
(0241) 		 }
(0242) 	  }  
(0243) 	}
(0244) 	T2cn=TCNT2;
    00173 B424      IN	R2,0x24
    00174 2433      CLR	R3
    00175 9230 02BA STS	T2cn+1,R3
    00177 9220 02B9 STS	T2cn,R2
(0245) 	TCNT2=0;
    00179 2422      CLR	R2
    0017A BC24      OUT	0x24,R2
(0246) 	if(T2cn<20)//数据位最小是3位，可放宽到2位
    0017B 9180 02B9 LDS	R24,T2cn
    0017D 9190 02BA LDS	R25,T2cn+1
    0017F 3184      CPI	R24,0x14
    00180 E0E0      LDI	R30,0
    00181 079E      CPC	R25,R30
    00182 F420      BCC	0x0187
(0247) 	{
(0248) 	 IntFlag=3;//接收数据位不完整
    00183 E083      LDI	R24,3
    00184 9380 02BF STS	IntFlag,R24
(0249) 	 goto End;//数据位来得太早，退出
    00186 C0D6      RJMP	0x025D
(0250) 	}
(0251) 	else if(T2cn<40)//数据位1本应是3个周期，在此我们认为2~4个周期都是可以的
    00187 9180 02B9 LDS	R24,T2cn
    00189 9190 02BA LDS	R25,T2cn+1
    0018B 3288      CPI	R24,0x28
    0018C E0E0      LDI	R30,0
    0018D 079E      CPC	R25,R30
    0018E F450      BCC	0x0199
(0252) 	{
(0253) 	 Rx[Int_count]=1;
    0018F EE83      LDI	R24,0xE3
    00190 E092      LDI	R25,2
    00191 91E0 02C0 LDS	R30,Int_count
    00193 27FF      CLR	R31
    00194 0FE8      ADD	R30,R24
    00195 1FF9      ADC	R31,R25
    00196 E081      LDI	R24,1
    00197 8380      ST	Z,R24
(0254) 	}
    00198 C020      RJMP	0x01B9
(0255) 	else if(T2cn<60)//数据位0本应是5个周期，在此我们认为4~6个周期都是可以的
    00199 9180 02B9 LDS	R24,T2cn
    0019B 9190 02BA LDS	R25,T2cn+1
    0019D 338C      CPI	R24,0x3C
    0019E E0E0      LDI	R30,0
    0019F 079E      CPC	R25,R30
    001A0 F450      BCC	0x01AB
(0256) 	{
(0257) 	 Rx[Int_count]=0;
    001A1 EE83      LDI	R24,0xE3
    001A2 E092      LDI	R25,2
    001A3 91E0 02C0 LDS	R30,Int_count
    001A5 27FF      CLR	R31
    001A6 0FE8      ADD	R30,R24
    001A7 1FF9      ADC	R31,R25
    001A8 2422      CLR	R2
    001A9 8220      ST	Z,R2
(0258) 	}
    001AA C00E      RJMP	0x01B9
(0259) 	else if(T2cn<=80)//同步位本应是7周期，在此我们认为6~8周期都是可以的
    001AB E580      LDI	R24,0x50
    001AC E090      LDI	R25,0
    001AD 9020 02B9 LDS	R2,T2cn
    001AF 9030 02BA LDS	R3,T2cn+1
    001B1 1582      CP	R24,R2
    001B2 0593      CPC	R25,R3
    001B3 F008      BCS	0x01B5
(0260) 	{
(0261) 	 goto Start;//在接收数据位时收到了同步位，跳到数据位解码起始位处
    001B4 CF5F      RJMP	0x0114
(0262) 	}
(0263) 	else 
(0264) 	{
(0265) 	 IntFlag=3;//接收数据位不完整
    001B5 E083      LDI	R24,3
    001B6 9380 02BF STS	IntFlag,R24
(0266) 	 goto End;//数据位来得太迟，退出
    001B8 C0A4      RJMP	0x025D
    001B9 9180 02C0 LDS	R24,Int_count
    001BB 5081      SUBI	R24,1
    001BC 9380 02C0 STS	Int_count,R24
    001BE E080      LDI	R24,0
    001BF 9020 02C0 LDS	R2,Int_count
    001C1 1582      CP	R24,R2
    001C2 F408      BCC	0x01C4
    001C3 CF7D      RJMP	0x0141
(0267) 	}
(0268)   }   
(0269) 	
(0270)     R_dat=0;
    001C4 2422      CLR	R2
    001C5 2433      CLR	R3
    001C6 9230 02E0 STS	R_dat+1,R3
    001C8 9220 02DF STS	R_dat,R2
(0271)     if(Rx[2])
    001CA 9020 02E5 LDS	R2,Rx+2
    001CC 2022      TST	R2
    001CD F049      BEQ	0x01D7
(0272)           R_dat|=0x01;
    001CE 9180 02DF LDS	R24,R_dat
    001D0 9190 02E0 LDS	R25,R_dat+1
    001D2 6081      ORI	R24,1
    001D3 9390 02E0 STS	R_dat+1,R25
    001D5 9380 02DF STS	R_dat,R24
(0273)     if(Rx[3])
    001D7 9020 02E6 LDS	R2,Rx+3
    001D9 2022      TST	R2
    001DA F049      BEQ	0x01E4
(0274)           R_dat|=0x02;
    001DB 9180 02DF LDS	R24,R_dat
    001DD 9190 02E0 LDS	R25,R_dat+1
    001DF 6082      ORI	R24,2
    001E0 9390 02E0 STS	R_dat+1,R25
    001E2 9380 02DF STS	R_dat,R24
(0275)     if(Rx[4])
    001E4 9020 02E7 LDS	R2,Rx+4
    001E6 2022      TST	R2
    001E7 F049      BEQ	0x01F1
(0276)           R_dat|=0x04;
    001E8 9180 02DF LDS	R24,R_dat
    001EA 9190 02E0 LDS	R25,R_dat+1
    001EC 6084      ORI	R24,4
    001ED 9390 02E0 STS	R_dat+1,R25
    001EF 9380 02DF STS	R_dat,R24
(0277)     if(Rx[5])
    001F1 9020 02E8 LDS	R2,Rx+5
    001F3 2022      TST	R2
    001F4 F049      BEQ	0x01FE
(0278)           R_dat|=0x08;
    001F5 9180 02DF LDS	R24,R_dat
    001F7 9190 02E0 LDS	R25,R_dat+1
    001F9 6088      ORI	R24,0x8
    001FA 9390 02E0 STS	R_dat+1,R25
    001FC 9380 02DF STS	R_dat,R24
(0279)     if(Rx[6])
    001FE 9020 02E9 LDS	R2,Rx+6
    00200 2022      TST	R2
    00201 F049      BEQ	0x020B
(0280)           R_dat|=0x10;
    00202 9180 02DF LDS	R24,R_dat
    00204 9190 02E0 LDS	R25,R_dat+1
    00206 6180      ORI	R24,0x10
    00207 9390 02E0 STS	R_dat+1,R25
    00209 9380 02DF STS	R_dat,R24
(0281)     if(Rx[7])
    0020B 9020 02EA LDS	R2,Rx+7
    0020D 2022      TST	R2
    0020E F049      BEQ	0x0218
(0282)           R_dat|=0x20;
    0020F 9180 02DF LDS	R24,R_dat
    00211 9190 02E0 LDS	R25,R_dat+1
    00213 6280      ORI	R24,0x20
    00214 9390 02E0 STS	R_dat+1,R25
    00216 9380 02DF STS	R_dat,R24
(0283)     if(Rx[8])
    00218 9020 02EB LDS	R2,Rx+8
    0021A 2022      TST	R2
    0021B F049      BEQ	0x0225
(0284)           R_dat|=0x40;
    0021C 9180 02DF LDS	R24,R_dat
    0021E 9190 02E0 LDS	R25,R_dat+1
    00220 6480      ORI	R24,0x40
    00221 9390 02E0 STS	R_dat+1,R25
    00223 9380 02DF STS	R_dat,R24
(0285)     if(Rx[9])
    00225 9020 02EC LDS	R2,Rx+9
    00227 2022      TST	R2
    00228 F049      BEQ	0x0232
(0286)           R_dat|=0x80;
    00229 9180 02DF LDS	R24,R_dat
    0022B 9190 02E0 LDS	R25,R_dat+1
    0022D 6880      ORI	R24,0x80
    0022E 9390 02E0 STS	R_dat+1,R25
    00230 9380 02DF STS	R_dat,R24
(0287) 	
(0288) 	Rx[0]=1;  
    00232 E081      LDI	R24,1
    00233 9380 02E3 STS	Rx,R24
(0289) 	for(Int_count=2;Int_count<10;Int_count++)  
    00235 E082      LDI	R24,2
    00236 9380 02C0 STS	Int_count,R24
    00238 C012      RJMP	0x024B
(0290)        Rx[0]^=Rx[Int_count];  
    00239 EE83      LDI	R24,0xE3
    0023A E092      LDI	R25,2
    0023B 91E0 02C0 LDS	R30,Int_count
    0023D 27FF      CLR	R31
    0023E 0FE8      ADD	R30,R24
    0023F 1FF9      ADC	R31,R25
    00240 8020      LD	R2,Z
    00241 9030 02E3 LDS	R3,Rx
    00243 2432      EOR	R3,R2
    00244 9230 02E3 STS	Rx,R3
    00246 9180 02C0 LDS	R24,Int_count
    00248 5F8F      SUBI	R24,0xFF
    00249 9380 02C0 STS	Int_count,R24
    0024B 9180 02C0 LDS	R24,Int_count
    0024D 308A      CPI	R24,0xA
    0024E F350      BCS	0x0239
(0291) 	   
(0292) 	if(Rx[0]==Rx[1])
    0024F 9020 02E4 LDS	R2,Rx+1
    00251 9030 02E3 LDS	R3,Rx
    00253 1432      CP	R3,R2
    00254 F421      BNE	0x0259
(0293) 	 {
(0294) 		 IntFlag=1;//接收帧正常	
    00255 E081      LDI	R24,1
    00256 9380 02BF STS	IntFlag,R24
(0295) 	 }
    00258 C00A      RJMP	0x0263
(0296) 	else           
(0297) 	 {
(0298) 		 IntFlag=2;//接收帧校验错
    00259 E082      LDI	R24,2
    0025A 9380 02BF STS	IntFlag,R24
(0299) 	 }
(0300)  
(0301)    goto End1;//只要接收到正常的同步头，不管校验位是对是错，都暂时不开放INT0中断
    0025C C006      RJMP	0x0263
(0302)      
(0303) End:
(0304) 		MANINT_CLR
    0025D B788      IN	R24,0x38
    0025E 6081      ORI	R24,1
    0025F BF88      OUT	0x38,R24
(0305) 		MANINT_EN
    00260 B789      IN	R24,0x39
    00261 6081      ORI	R24,1
    00262 BF89      OUT	0x39,R24
(0306) End1:
(0307)    TCCR2 = 0x00; //stop
    00263 2422      CLR	R2
    00264 BC25      OUT	0x25,R2
(0308)    INT_EN
    00265 9478      BSET	7
    00266 9029      LD	R2,Y+
    00267 BE2F      OUT	0x3F,R2
    00268 91F9      LD	R31,Y+
    00269 91E9      LD	R30,Y+
    0026A 91A9      LD	R26,Y+
    0026B 9199      LD	R25,Y+
    0026C 9189      LD	R24,Y+
    0026D 9039      LD	R3,Y+
    0026E 9029      LD	R2,Y+
    0026F 9518      RETI
(0309) }
(0310) 
(0311) void InitialIO(void)
(0312) {//1输出，0输入
(0313)  PORTG&=0xe7; 
_InitialIO:
    00270 9180 0065 LDS	R24,0x65
    00272 7E87      ANDI	R24,0xE7
    00273 9380 0065 STS	0x65,R24
(0314)  DDRG|=0x18; 
    00275 9180 0064 LDS	R24,0x64
    00277 6188      ORI	R24,0x18
    00278 9380 0064 STS	0x64,R24
(0315)  
(0316)  PORTD&=0xBF;
    0027A B382      IN	R24,0x12
    0027B 7B8F      ANDI	R24,0xBF
    0027C BB82      OUT	0x12,R24
(0317)  DDRD|=0x40;
    0027D 9A8E      SBI	0x11,6
    0027E 9508      RET
(0318) }
(0319) 
(0320) 
(0321) //UART1 initialize
(0322) // desired baud rate:9600
(0323) // actual baud rate:9615 (0.2%)
(0324) // char size: 8 bit
(0325) // parity: Disabled
(0326) void uart1_init(void)
(0327) {
(0328)  UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    0027F 2422      CLR	R2
    00280 9220 009A STS	0x9A,R2
(0329)  UCSR1A = 0x02;
    00282 E082      LDI	R24,2
    00283 9380 009B STS	0x9B,R24
(0330)  UCSR1C = 0x06;
    00285 E086      LDI	R24,6
    00286 9380 009D STS	0x9D,R24
(0331)  UBRR1L = 0x67; //set baud rate lo
    00288 E687      LDI	R24,0x67
    00289 9380 0099 STS	0x99,R24
(0332)  UBRR1H = 0x00; //set baud rate hi
    0028B 9220 0098 STS	0x98,R2
(0333)  UCSR1B = 0x98;
    0028D E988      LDI	R24,0x98
    0028E 9380 009A STS	0x9A,R24
    00290 9508      RET
_uart1_rx_isr:
    00291 922A      ST	-Y,R2
    00292 938A      ST	-Y,R24
    00293 939A      ST	-Y,R25
    00294 93EA      ST	-Y,R30
    00295 93FA      ST	-Y,R31
    00296 B62F      IN	R2,0x3F
    00297 922A      ST	-Y,R2
(0334) }
(0335) 
(0336) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0337) void uart1_rx_isr(void)//串口1接收中断
(0338) {
(0339)   if(Uart1RxCounter<4)
    00298 9180 02F5 LDS	R24,Uart1RxCounter
    0029A 3084      CPI	R24,4
    0029B F478      BCC	0x02AB
(0340) 	{
(0341)     Uart1RxData[Uart1RxCounter]=UDR1;//接收串口数据,同时清空串口接收中断标志
    0029C EF86      LDI	R24,0xF6
    0029D E092      LDI	R25,2
    0029E 91E0 02F5 LDS	R30,Uart1RxCounter
    002A0 27FF      CLR	R31
    002A1 0FE8      ADD	R30,R24
    002A2 1FF9      ADC	R31,R25
    002A3 9020 009C LDS	R2,0x9C
    002A5 8220      ST	Z,R2
(0342)  	Uart1RxCounter++;
    002A6 9180 02F5 LDS	R24,Uart1RxCounter
    002A8 5F8F      SUBI	R24,0xFF
    002A9 9380 02F5 STS	Uart1RxCounter,R24
(0343) 	}
    002AB 9029      LD	R2,Y+
    002AC BE2F      OUT	0x3F,R2
    002AD 91F9      LD	R31,Y+
    002AE 91E9      LD	R30,Y+
    002AF 9199      LD	R25,Y+
    002B0 9189      LD	R24,Y+
    002B1 9029      LD	R2,Y+
    002B2 9518      RETI
_SendUart1:
  i                    --> Y,+1
  t                    --> R20
  s                    --> R18
  dat                  --> R16
    002B3 934A      ST	-Y,R20
(0344) }
(0345) 
(0346) 
(0347) void SendUart1(unsigned char dat,unsigned int s)   //串口发送数据
(0348) {//要求流量板在s个8ms内通过串口返回数据
(0349) unsigned char t,i; 	
(0350) 
(0351) for(t=0;t<4;t++)
    002B4 2744      CLR	R20
    002B5 C009      RJMP	0x02BF
(0352)   Uart1RxData[t]=0xff;
    002B6 EF86      LDI	R24,0xF6
    002B7 E092      LDI	R25,2
    002B8 2FE4      MOV	R30,R20
    002B9 27FF      CLR	R31
    002BA 0FE8      ADD	R30,R24
    002BB 1FF9      ADC	R31,R25
    002BC EF8F      LDI	R24,0xFF
    002BD 8380      ST	Z,R24
    002BE 9543      INC	R20
    002BF 3044      CPI	R20,4
    002C0 F3A8      BCS	0x02B6
(0353)   
(0354) Uart1RxCounter=0; //清串口接受计数  
    002C1 2422      CLR	R2
    002C2 9220 02F5 STS	Uart1RxCounter,R2
(0355) 
(0356) while(!(UCSR1A&(1<<UDRE1)));   // 等待发送缓冲器为空
    002C4 9020 009B LDS	R2,0x9B
    002C6 FE25      SBRS	R2,5
    002C7 CFFC      RJMP	0x02C4
(0357) UDR1=dat;  
    002C8 9300 009C STS	0x9C,R16
(0358) 
(0359) t=UDR1;//开串口接收中断前读空缓存
    002CA 9140 009C LDS	R20,0x9C
(0360) UCSR1B|=0x80;//开串口接收中断
    002CC 9180 009A LDS	R24,0x9A
    002CE 6880      ORI	R24,0x80
    002CF 9380 009A STS	0x9A,R24
(0361)                   
(0362) if(s>0)
    002D1 3020      CPI	R18,0
    002D2 0723      CPC	R18,R19
    002D3 F0C9      BEQ	0x02ED
(0363) {
(0364)  //超时设定
(0365) TimeOutFlag=0; //超时标志置0
    002D4 2422      CLR	R2
    002D5 9220 02D9 STS	TimeOutFlag,R2
(0366) Timer0Counter=s; //8ms定时循环次数
    002D7 9330 0346 STS	Timer0Counter+1,R19
    002D9 9320 0345 STS	Timer0Counter,R18
(0367) TCNT0=0x06;//定时8ms
    002DB E086      LDI	R24,6
    002DC BF82      OUT	0x32,R24
(0368) TCCR0|=0x06;//256分频
    002DD B783      IN	R24,0x33
    002DE 6086      ORI	R24,6
    002DF BF83      OUT	0x33,R24
(0369) TIFR|=0x01; //清定时器0中断标志
    002E0 B786      IN	R24,0x36
    002E1 6081      ORI	R24,1
    002E2 BF86      OUT	0x36,R24
(0370) TIMSK|=0x01;//使能定时器0中断
    002E3 B787      IN	R24,0x37
    002E4 6081      ORI	R24,1
    002E5 BF87      OUT	0x37,R24
(0371) while(TimeOutFlag==0);
    002E6 9020 02D9 LDS	R2,TimeOutFlag
    002E8 2022      TST	R2
    002E9 F3E1      BEQ	0x02E6
(0372) TIMSK&=0xFE;//关定时器0中断
    002EA B787      IN	R24,0x37
    002EB 7F8E      ANDI	R24,0xFE
    002EC BF87      OUT	0x37,R24
(0373) 
(0374) }
(0375) 
(0376) UCSR1B&=0x7f;//关串口接收中断
    002ED 9180 009A LDS	R24,0x9A
    002EF 778F      ANDI	R24,0x7F
    002F0 9380 009A STS	0x9A,R24
    002F2 9149      LD	R20,Y+
    002F3 9508      RET
(0377) }
(0378) 
(0379) 
(0380) 
(0381) 
(0382) //TIMER3 initialize - prescale:1
(0383) // WGM: 0) Normal, TOP=0xFFFF
(0384) // desired value: 19200Hz
(0385) // actual value: 19230.769Hz (0.2%)
(0386) void timer3_init(void)
(0387) {
(0388)  
(0389)  ETIMSK&=0xfb;//禁止time3溢出中断   
_timer3_init:
    002F4 9180 007D LDS	R24,0x7D
    002F6 7F8B      ANDI	R24,0xFB
    002F7 9380 007D STS	0x7D,R24
(0390)  ETIFR&=0xfb;  //清timer3中断标志  
    002F9 9180 007C LDS	R24,0x7C
    002FB 7F8B      ANDI	R24,0xFB
    002FC 9380 007C STS	0x7C,R24
(0391)  TCCR3B = 0x00; //stop
    002FE 2422      CLR	R2
    002FF 9220 008A STS	0x8A,R2
(0392)  TPSBAUD
    00301 EF8E      LDI	R24,0xFE
    00302 9380 0089 STS	0x89,R24
    00304 E680      LDI	R24,0x60
    00305 9380 0088 STS	0x88,R24
(0393)  TCCR3B = 0x01; //start Timer
    00307 E081      LDI	R24,1
    00308 9380 008A STS	0x8A,R24
(0394)  ETIFR&=0xfb;           //清timer3中断标志
    0030A 9180 007C LDS	R24,0x7C
    0030C 7F8B      ANDI	R24,0xFB
    0030D 9380 007C STS	0x7C,R24
    0030F 9508      RET
_SendTPS:
  i                    --> R20
  tx_buf               --> R10
    00310 92AA      ST	-Y,R10
    00311 934A      ST	-Y,R20
    00312 2EA0      MOV	R10,R16
(0395) }
(0396) 
(0397) void SendTPS(unsigned char tx_buf)
(0398) {
(0399)     unsigned char i;
(0400) 	
(0401)     timer3_init();   
    00313 DFE0      RCALL	_timer3_init
(0402) 	
(0403) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00314 9180 007C LDS	R24,0x7C
    00316 7F8B      ANDI	R24,0xFB
    00317 F3E1      BEQ	0x0314
(0404) 	TPSBAUD
    00318 EF8E      LDI	R24,0xFE
    00319 9380 0089 STS	0x89,R24
    0031B E680      LDI	R24,0x60
    0031C 9380 0088 STS	0x88,R24
(0405) 	ETIFR&=0xfb;           //清timer3中断标志
    0031E 9180 007C LDS	R24,0x7C
    00320 7F8B      ANDI	R24,0xFB
    00321 9380 007C STS	0x7C,R24
(0406)     SET_TX();//同步位
    00323 9A96      SBI	0x12,6
(0407) 	
(0408) 	for(i=0; i<8;i++)
    00324 2744      CLR	R20
    00325 C01C      RJMP	0x0342
(0409) 	{
(0410) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00326 9180 007C LDS	R24,0x7C
    00328 7F8B      ANDI	R24,0xFB
    00329 F3E1      BEQ	0x0326
(0411) 	TPSBAUD
    0032A EF8E      LDI	R24,0xFE
    0032B 9380 0089 STS	0x89,R24
    0032D E680      LDI	R24,0x60
    0032E 9380 0088 STS	0x88,R24
(0412) 	ETIFR&=0xfb;           //清timer3中断标志
    00330 9180 007C LDS	R24,0x7C
    00332 7F8B      ANDI	R24,0xFB
    00333 9380 007C STS	0x7C,R24
(0413) 	if (tx_buf & (1 << i))  
    00335 E001      LDI	R16,1
    00336 2F14      MOV	R17,R20
    00337 940E 208C CALL	lsl8
    00339 2C2A      MOV	R2,R10
    0033A 2220      AND	R2,R16
    0033B F021      BEQ	0x0340
(0414)        {CLR_TX();}
    0033C B382      IN	R24,0x12
    0033D 7B8F      ANDI	R24,0xBF
    0033E BB82      OUT	0x12,R24
    0033F C001      RJMP	0x0341
(0415)     else
(0416)        {SET_TX();}
    00340 9A96      SBI	0x12,6
    00341 9543      INC	R20
    00342 3048      CPI	R20,0x8
    00343 F310      BCS	0x0326
(0417) 	}
(0418) 	  
(0419) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00344 9180 007C LDS	R24,0x7C
    00346 7F8B      ANDI	R24,0xFB
    00347 F3E1      BEQ	0x0344
(0420) 	TPSBAUD
    00348 EF8E      LDI	R24,0xFE
    00349 9380 0089 STS	0x89,R24
    0034B E680      LDI	R24,0x60
    0034C 9380 0088 STS	0x88,R24
(0421) 	CLR_TX();//结束位
    0034E B382      IN	R24,0x12
    0034F 7B8F      ANDI	R24,0xBF
    00350 BB82      OUT	0x12,R24
(0422) 	
(0423) 	//以下是等结束位结束后，再多等待2位，防止连续发送时接收方忙不过来
(0424) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00351 9180 007C LDS	R24,0x7C
    00353 7F8B      ANDI	R24,0xFB
    00354 F3E1      BEQ	0x0351
(0425) 	TPSBAUD
    00355 EF8E      LDI	R24,0xFE
    00356 9380 0089 STS	0x89,R24
    00358 E680      LDI	R24,0x60
    00359 9380 0088 STS	0x88,R24
(0426) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    0035B 9180 007C LDS	R24,0x7C
    0035D 7F8B      ANDI	R24,0xFB
    0035E F3E1      BEQ	0x035B
(0427) 	TPSBAUD
    0035F EF8E      LDI	R24,0xFE
    00360 9380 0089 STS	0x89,R24
    00362 E680      LDI	R24,0x60
    00363 9380 0088 STS	0x88,R24
(0428) 	while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00365 9180 007C LDS	R24,0x7C
    00367 7F8B      ANDI	R24,0xFB
    00368 F3E1      BEQ	0x0365
(0429) 	TPSBAUD
    00369 EF8E      LDI	R24,0xFE
    0036A 9380 0089 STS	0x89,R24
    0036C E680      LDI	R24,0x60
    0036D 9380 0088 STS	0x88,R24
(0430) 	
(0431) 	TCCR3B = 0x00; //stop  
    0036F 2422      CLR	R2
    00370 9220 008A STS	0x8A,R2
(0432) 	ETIFR&=0xfb;           //清timer3中断标志
    00372 9180 007C LDS	R24,0x7C
    00374 7F8B      ANDI	R24,0xFB
    00375 9380 007C STS	0x7C,R24
    00377 9149      LD	R20,Y+
    00378 90A9      LD	R10,Y+
    00379 9508      RET
_ReceiveTPS:
  i                    --> Y,+1
  rx_buf               --> R20
    0037A 934A      ST	-Y,R20
(0433)     
(0434) }
(0435) 
(0436) unsigned char ReceiveTPS(void)
(0437) {
(0438)     unsigned char i,rx_buf;
(0439) 	
(0440) 	rx_buf=0xff;
    0037B EF4F      LDI	R20,0xFF
(0441) 	TCCR1B = 0x00; //stop
    0037C 2422      CLR	R2
    0037D BC2E      OUT	0x2E,R2
(0442)     TCNT1 = 65380;  //定时20ms，9600波特率下接收一个字节实际只需耗时1.04ms，压力板返回时故意延迟了2ms，但有时遇到采集中断则需要10ms以上
    0037E E684      LDI	R24,0x64
    0037F EF9F      LDI	R25,0xFF
    00380 BD9D      OUT	0x2D,R25
    00381 BD8C      OUT	0x2C,R24
(0443) 	TIFR|=0x04; //清定时器1中断标志 
    00382 B786      IN	R24,0x36
    00383 6084      ORI	R24,4
    00384 BF86      OUT	0x36,R24
(0444)  	TCCR1B = 0x05; //1024分频
    00385 E085      LDI	R24,5
    00386 BD8E      OUT	0x2E,R24
    00387 C0C2      RJMP	0x044A
(0445) 	
(0446) 	//DDRG|=0x01;
(0447) 	//PORTG|=0x01;  
(0448) 	//PORTG&=0xfe; 
(0449)     while((TIFR&0x04)==0x00) 
(0450) 	{
(0451) 	   if (!GET_RX())//检测到了低电平的起始位
    00388 9981      SBIC	0x10,1
    00389 C0C0      RJMP	0x044A
(0452) 	     {  PORTG|=0x01;    
    0038A 9180 0065 LDS	R24,0x65
    0038C 6081      ORI	R24,1
    0038D 9380 0065 STS	0x65,R24
(0453)             timer3_init(); 
    0038F DF64      RCALL	_timer3_init
(0454) 	 /*
(0455) 			for(i=0; i<8;i++)
(0456) 			{
(0457) 	 		  while((ETIFR&0xfb)==0);//等待 timer3中断标志
(0458) 			  PORTG&=0xfe;
(0459) 			  TPSBAUD
(0460) 			  ETIFR&=0xfb;           //清timer3中断标志
(0461) 			  if (GET_RX())           //根据端口电平, 写接收缓冲相应位 
(0462)                 {rx_buf |= (1 << i);}
(0463)               else
(0464)                 {rx_buf &= ~(1 << i);}
(0465) 		    }
(0466) 			*/
(0467) 			
(0468) 			 while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00390 9180 007C LDS	R24,0x7C
    00392 7F8B      ANDI	R24,0xFB
    00393 F3E1      BEQ	0x0390
(0469) 			 // PORTG&=0xfe;
(0470) 			  TPSBAUD
    00394 EF8E      LDI	R24,0xFE
    00395 9380 0089 STS	0x89,R24
    00397 E680      LDI	R24,0x60
    00398 9380 0088 STS	0x88,R24
(0471) 			  ETIFR&=0xfb;           //清timer3中断标志
    0039A 9180 007C LDS	R24,0x7C
    0039C 7F8B      ANDI	R24,0xFB
    0039D 9380 007C STS	0x7C,R24
(0472) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    0039F 9B81      SBIS	0x10,1
    003A0 C002      RJMP	0x03A3
(0473)                 {rx_buf |= (1 << 0);}
    003A1 6041      ORI	R20,1
    003A2 C001      RJMP	0x03A4
(0474)               else
(0475)                 {rx_buf &= ~(1 << 0);}
    003A3 7F4E      ANDI	R20,0xFE
(0476) 			
(0477) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    003A4 9180 007C LDS	R24,0x7C
    003A6 7F8B      ANDI	R24,0xFB
    003A7 F3E1      BEQ	0x03A4
(0478) 			//  PORTG|=0x01; 
(0479) 			  TPSBAUD
    003A8 EF8E      LDI	R24,0xFE
    003A9 9380 0089 STS	0x89,R24
    003AB E680      LDI	R24,0x60
    003AC 9380 0088 STS	0x88,R24
(0480) 			  ETIFR&=0xfb;           //清timer3中断标志
    003AE 9180 007C LDS	R24,0x7C
    003B0 7F8B      ANDI	R24,0xFB
    003B1 9380 007C STS	0x7C,R24
(0481) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    003B3 9B81      SBIS	0x10,1
    003B4 C002      RJMP	0x03B7
(0482)                 {rx_buf |= (1 << 1);}
    003B5 6042      ORI	R20,2
    003B6 C001      RJMP	0x03B8
(0483)               else
(0484)                 {rx_buf &= ~(1 << 1);}
    003B7 7F4D      ANDI	R20,0xFD
(0485) 				
(0486) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    003B8 9180 007C LDS	R24,0x7C
    003BA 7F8B      ANDI	R24,0xFB
    003BB F3E1      BEQ	0x03B8
(0487) 			//  PORTG&=0xfe;
(0488) 			  TPSBAUD
    003BC EF8E      LDI	R24,0xFE
    003BD 9380 0089 STS	0x89,R24
    003BF E680      LDI	R24,0x60
    003C0 9380 0088 STS	0x88,R24
(0489) 			  ETIFR&=0xfb;           //清timer3中断标志
    003C2 9180 007C LDS	R24,0x7C
    003C4 7F8B      ANDI	R24,0xFB
    003C5 9380 007C STS	0x7C,R24
(0490) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    003C7 9B81      SBIS	0x10,1
    003C8 C002      RJMP	0x03CB
(0491)                 {rx_buf |= (1 << 2);}
    003C9 6044      ORI	R20,4
    003CA C001      RJMP	0x03CC
(0492)               else
(0493)                 {rx_buf &= ~(1 << 2);}
    003CB 7F4B      ANDI	R20,0xFB
(0494) 			
(0495) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    003CC 9180 007C LDS	R24,0x7C
    003CE 7F8B      ANDI	R24,0xFB
    003CF F3E1      BEQ	0x03CC
(0496) 			 // PORTG|=0x01; 
(0497) 			  TPSBAUD
    003D0 EF8E      LDI	R24,0xFE
    003D1 9380 0089 STS	0x89,R24
    003D3 E680      LDI	R24,0x60
    003D4 9380 0088 STS	0x88,R24
(0498) 			  ETIFR&=0xfb;           //清timer3中断标志
    003D6 9180 007C LDS	R24,0x7C
    003D8 7F8B      ANDI	R24,0xFB
    003D9 9380 007C STS	0x7C,R24
(0499) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    003DB 9B81      SBIS	0x10,1
    003DC C002      RJMP	0x03DF
(0500)                 {rx_buf |= (1 << 3);}
    003DD 6048      ORI	R20,0x8
    003DE C001      RJMP	0x03E0
(0501)               else
(0502)                 {rx_buf &= ~(1 << 3);}
    003DF 7F47      ANDI	R20,0xF7
(0503) 			
(0504) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    003E0 9180 007C LDS	R24,0x7C
    003E2 7F8B      ANDI	R24,0xFB
    003E3 F3E1      BEQ	0x03E0
(0505) 			//  PORTG&=0xfe;
(0506) 			  TPSBAUD
    003E4 EF8E      LDI	R24,0xFE
    003E5 9380 0089 STS	0x89,R24
    003E7 E680      LDI	R24,0x60
    003E8 9380 0088 STS	0x88,R24
(0507) 			  ETIFR&=0xfb;           //清timer3中断标志
    003EA 9180 007C LDS	R24,0x7C
    003EC 7F8B      ANDI	R24,0xFB
    003ED 9380 007C STS	0x7C,R24
(0508) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    003EF 9B81      SBIS	0x10,1
    003F0 C002      RJMP	0x03F3
(0509)                 {rx_buf |= (1 << 4);}
    003F1 6140      ORI	R20,0x10
    003F2 C001      RJMP	0x03F4
(0510)               else
(0511)                 {rx_buf &= ~(1 << 4);}
    003F3 7E4F      ANDI	R20,0xEF
(0512) 			
(0513) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    003F4 9180 007C LDS	R24,0x7C
    003F6 7F8B      ANDI	R24,0xFB
    003F7 F3E1      BEQ	0x03F4
(0514) 			 // PORTG|=0x01; 
(0515) 			  TPSBAUD
    003F8 EF8E      LDI	R24,0xFE
    003F9 9380 0089 STS	0x89,R24
    003FB E680      LDI	R24,0x60
    003FC 9380 0088 STS	0x88,R24
(0516) 			  ETIFR&=0xfb;           //清timer3中断标志
    003FE 9180 007C LDS	R24,0x7C
    00400 7F8B      ANDI	R24,0xFB
    00401 9380 007C STS	0x7C,R24
(0517) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    00403 9B81      SBIS	0x10,1
    00404 C002      RJMP	0x0407
(0518)                 {rx_buf |= (1 << 5);}
    00405 6240      ORI	R20,0x20
    00406 C001      RJMP	0x0408
(0519)               else
(0520)                 {rx_buf &= ~(1 << 5);}
    00407 7D4F      ANDI	R20,0xDF
(0521) 			
(0522) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00408 9180 007C LDS	R24,0x7C
    0040A 7F8B      ANDI	R24,0xFB
    0040B F3E1      BEQ	0x0408
(0523) 			 // PORTG&=0xfe;
(0524) 			  TPSBAUD
    0040C EF8E      LDI	R24,0xFE
    0040D 9380 0089 STS	0x89,R24
    0040F E680      LDI	R24,0x60
    00410 9380 0088 STS	0x88,R24
(0525) 			  ETIFR&=0xfb;           //清timer3中断标志
    00412 9180 007C LDS	R24,0x7C
    00414 7F8B      ANDI	R24,0xFB
    00415 9380 007C STS	0x7C,R24
(0526) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    00417 9B81      SBIS	0x10,1
    00418 C002      RJMP	0x041B
(0527)                 {rx_buf |= (1 << 6);}
    00419 6440      ORI	R20,0x40
    0041A C001      RJMP	0x041C
(0528)               else
(0529)                 {rx_buf &= ~(1 << 6);}
    0041B 7B4F      ANDI	R20,0xBF
(0530) 			
(0531) 			while((ETIFR&0xfb)==0);//等待 timer3中断标志
    0041C 9180 007C LDS	R24,0x7C
    0041E 7F8B      ANDI	R24,0xFB
    0041F F3E1      BEQ	0x041C
(0532) 			 // PORTG|=0x01; 
(0533) 			  TPSBAUD
    00420 EF8E      LDI	R24,0xFE
    00421 9380 0089 STS	0x89,R24
    00423 E680      LDI	R24,0x60
    00424 9380 0088 STS	0x88,R24
(0534) 			  ETIFR&=0xfb;           //清timer3中断标志
    00426 9180 007C LDS	R24,0x7C
    00428 7F8B      ANDI	R24,0xFB
    00429 9380 007C STS	0x7C,R24
(0535) 			  if (GET_RX())           /* 根据端口电平, 写接收缓冲相应位 */
    0042B 9B81      SBIS	0x10,1
    0042C C002      RJMP	0x042F
(0536)                 {rx_buf |= (1 << 7);}
    0042D 6840      ORI	R20,0x80
    0042E C001      RJMP	0x0430
(0537)               else
(0538)                 {rx_buf &= ~(1 << 7);}
    0042F 774F      ANDI	R20,0x7F
(0539) 						
(0540) 			 while((ETIFR&0xfb)==0);//等待 timer3中断标志
    00430 9180 007C LDS	R24,0x7C
    00432 7F8B      ANDI	R24,0xFB
    00433 F3E1      BEQ	0x0430
(0541) 			// PORTG&=0xfe; 
(0542) 			 TPSBAUD
    00434 EF8E      LDI	R24,0xFE
    00435 9380 0089 STS	0x89,R24
    00437 E680      LDI	R24,0x60
    00438 9380 0088 STS	0x88,R24
(0543) 			 ETIFR&=0xfb;           //清timer3中断标志
    0043A 9180 007C LDS	R24,0x7C
    0043C 7F8B      ANDI	R24,0xFB
    0043D 9380 007C STS	0x7C,R24
(0544) 			 
(0545) 			 TCCR3B = 0x00; //stop  
    0043F 2422      CLR	R2
    00440 9220 008A STS	0x8A,R2
(0546) 	         ETIFR&=0xfb;           //清timer3中断标志
    00442 9180 007C LDS	R24,0x7C
    00444 7F8B      ANDI	R24,0xFB
    00445 9380 007C STS	0x7C,R24
(0547) 			  
(0548) 			if (GET_RX()) //检测到了高电平结束位
    00447 9B81      SBIS	0x10,1
    00448 C001      RJMP	0x044A
(0549) 			 {break;}
    00449 C003      RJMP	0x044D
    0044A B626      IN	R2,0x36
    0044B FE22      SBRS	R2,2
    0044C CF3B      RJMP	0x0388
(0550) 		 }
(0551) 	}
(0552) 	TCCR1B = 0x00; //stop
    0044D 2422      CLR	R2
    0044E BC2E      OUT	0x2E,R2
(0553) 	TIFR|=0x04; //清定时器1中断标志 
    0044F B786      IN	R24,0x36
    00450 6084      ORI	R24,4
    00451 BF86      OUT	0x36,R24
(0554) 	
(0555) 	return rx_buf;
    00452 2F04      MOV	R16,R20
    00453 9149      LD	R20,Y+
    00454 9508      RET
_SampleTPS:
  rx_fifo              --> Y,+0
  cmd                  --> R10
    00455 92AA      ST	-Y,R10
    00456 2EA0      MOV	R10,R16
    00457 9724      SBIW	R28,4
(0556) }
(0557) 
(0558) void SampleTPS(unsigned char cmd)
(0559) {   
(0560)     unsigned char rx_fifo[4];
(0561)    
(0562) 	SendTPS(cmd);  //采样第2路压力温度，数字量或工程量
    00458 2D0A      MOV	R16,R10
    00459 DEB6      RCALL	_SendTPS
(0563) 
(0564) 	rx_fifo[0]=ReceiveTPS();
    0045A DF1F      RCALL	_ReceiveTPS
    0045B 8308      ST	Y,R16
(0565) 	rx_fifo[1]=ReceiveTPS();
    0045C DF1D      RCALL	_ReceiveTPS
    0045D 8309      STD	Y+1,R16
(0566) 	rx_fifo[2]=ReceiveTPS();
    0045E DF1B      RCALL	_ReceiveTPS
    0045F 2EA0      MOV	R10,R16
    00460 82AA      STD	Y+2,R10
(0567) 	rx_fifo[3]=ReceiveTPS();
    00461 DF18      RCALL	_ReceiveTPS
    00462 2EA0      MOV	R10,R16
    00463 82AB      STD	Y+3,R10
(0568) 	
(0569) 	TPS_PData=rx_fifo[1];
    00464 8029      LDD	R2,Y+1
    00465 2433      CLR	R3
    00466 9230 02DE STS	TPS_PData+1,R3
    00468 9220 02DD STS	TPS_PData,R2
(0570) 	TPS_PData<<=8;
    0046A 2C32      MOV	R3,R2
    0046B 2422      CLR	R2
    0046C 9230 02DE STS	TPS_PData+1,R3
    0046E 9220 02DD STS	TPS_PData,R2
(0571) 	TPS_PData|=rx_fifo[0];
    00470 8028      LD	R2,Y
    00471 2433      CLR	R3
    00472 9040 02DD LDS	R4,TPS_PData
    00474 9050 02DE LDS	R5,TPS_PData+1
    00476 2842      OR	R4,R2
    00477 2853      OR	R5,R3
    00478 9250 02DE STS	TPS_PData+1,R5
    0047A 9240 02DD STS	TPS_PData,R4
(0572) 	TPS_TData=rx_fifo[3];
    0047C 2C2A      MOV	R2,R10
    0047D 2433      CLR	R3
    0047E 9230 02DC STS	TPS_TData+1,R3
    00480 9220 02DB STS	TPS_TData,R2
(0573) 	TPS_TData<<=8;
    00482 2C32      MOV	R3,R2
    00483 2422      CLR	R2
    00484 9230 02DC STS	TPS_TData+1,R3
    00486 9220 02DB STS	TPS_TData,R2
(0574) 	TPS_TData|=rx_fifo[2];
    00488 802A      LDD	R2,Y+2
    00489 2433      CLR	R3
    0048A 9040 02DB LDS	R4,TPS_TData
    0048C 9050 02DC LDS	R5,TPS_TData+1
    0048E 2842      OR	R4,R2
    0048F 2853      OR	R5,R3
    00490 9250 02DC STS	TPS_TData+1,R5
    00492 9240 02DB STS	TPS_TData,R4
    00494 9624      ADIW	R28,4
    00495 90A9      LD	R10,Y+
    00496 9508      RET
(0575) }
(0576) 
(0577) 
(0578) //UART0 initialize
(0579) // desired baud rate: 57600
(0580) // actual: baud rate:58824 (2.1%)
(0581) // char size: 8 bit
(0582) // parity: Disabled
(0583) void uart0_init(void)
(0584) {
(0585)  UCSR0B = 0x00; //disable while setting baud rate
_uart0_init:
    00497 2422      CLR	R2
    00498 B82A      OUT	0x0A,R2
(0586)  UCSR0A = 0x02;
    00499 E082      LDI	R24,2
    0049A B98B      OUT	0x0B,R24
(0587)  UCSR0C = 0x06;
    0049B E086      LDI	R24,6
    0049C 9380 0095 STS	0x95,R24
(0588)  UBRR0L = 0x10; //set baud rate lo 57600
    0049E E180      LDI	R24,0x10
    0049F B989      OUT	0x09,R24
(0589)  UBRR0H = 0x00; //set baud rate hi
    004A0 9220 0090 STS	0x90,R2
(0590)  UCSR0B = 0x98;
    004A2 E988      LDI	R24,0x98
    004A3 B98A      OUT	0x0A,R24
    004A4 9508      RET
_uart0_rx_isr:
    004A5 922A      ST	-Y,R2
    004A6 938A      ST	-Y,R24
    004A7 939A      ST	-Y,R25
    004A8 93EA      ST	-Y,R30
    004A9 93FA      ST	-Y,R31
    004AA B62F      IN	R2,0x3F
    004AB 922A      ST	-Y,R2
(0591) }
(0592) 
(0593) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0594) void uart0_rx_isr(void)//串口0接收中断
(0595) {
(0596)     if(Uart0RxCounter<74)
    004AC 9180 02FA LDS	R24,Uart0RxCounter
    004AE 348A      CPI	R24,0x4A
    004AF F470      BCC	0x04BE
(0597) 	{
(0598)     Uart0RxData[Uart0RxCounter]=UDR0;//接收串口数据,同时清空串口接收中断标志
    004B0 EF8B      LDI	R24,0xFB
    004B1 E092      LDI	R25,2
    004B2 91E0 02FA LDS	R30,Uart0RxCounter
    004B4 27FF      CLR	R31
    004B5 0FE8      ADD	R30,R24
    004B6 1FF9      ADC	R31,R25
    004B7 B02C      IN	R2,0x0C
    004B8 8220      ST	Z,R2
(0599)  	Uart0RxCounter++;
    004B9 9180 02FA LDS	R24,Uart0RxCounter
    004BB 5F8F      SUBI	R24,0xFF
    004BC 9380 02FA STS	Uart0RxCounter,R24
(0600) 	}
    004BE 9029      LD	R2,Y+
    004BF BE2F      OUT	0x3F,R2
    004C0 91F9      LD	R31,Y+
    004C1 91E9      LD	R30,Y+
    004C2 9199      LD	R25,Y+
    004C3 9189      LD	R24,Y+
    004C4 9029      LD	R2,Y+
    004C5 9518      RETI
_timer0_ovf_isr:
    004C6 922A      ST	-Y,R2
    004C7 938A      ST	-Y,R24
    004C8 939A      ST	-Y,R25
    004C9 B62F      IN	R2,0x3F
    004CA 922A      ST	-Y,R2
(0601) }
(0602) 
(0603) #pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
(0604) void timer0_ovf_isr(void)
(0605) {
(0606) Timer0Counter--;
    004CB 9180 0345 LDS	R24,Timer0Counter
    004CD 9190 0346 LDS	R25,Timer0Counter+1
    004CF 9701      SBIW	R24,1
    004D0 9390 0346 STS	Timer0Counter+1,R25
    004D2 9380 0345 STS	Timer0Counter,R24
(0607) if(Timer0Counter==0)
    004D4 3080      CPI	R24,0
    004D5 0789      CPC	R24,R25
    004D6 F461      BNE	0x04E3
(0608) {
(0609)  TCNT0=0;
    004D7 2422      CLR	R2
    004D8 BE22      OUT	0x32,R2
(0610)  TimeOutFlag=1;
    004D9 E081      LDI	R24,1
    004DA 9380 02D9 STS	TimeOutFlag,R24
(0611)  TIMSK&=0xFE;//关定时器0中断
    004DC B787      IN	R24,0x37
    004DD 7F8E      ANDI	R24,0xFE
    004DE BF87      OUT	0x37,R24
(0612)  UCSR0B&=0x7f;//关串口接收中断
    004DF B18A      IN	R24,0x0A
    004E0 778F      ANDI	R24,0x7F
    004E1 B98A      OUT	0x0A,R24
(0613)  }
    004E2 C002      RJMP	0x04E5
(0614)  else
(0615)  {
(0616)  TCNT0=0x06;//定时8ms
    004E3 E086      LDI	R24,6
    004E4 BF82      OUT	0x32,R24
(0617)  }
    004E5 9029      LD	R2,Y+
    004E6 BE2F      OUT	0x3F,R2
    004E7 9199      LD	R25,Y+
    004E8 9189      LD	R24,Y+
    004E9 9029      LD	R2,Y+
    004EA 9518      RETI
_SendUart0_2:
  t                    --> R20
  i                    --> R22
  s                    --> R18
  len                  --> R16
    004EB 934A      ST	-Y,R20
    004EC 936A      ST	-Y,R22
(0618) }
(0619) 
(0620)  
(0621) 
(0622) void SendUart0_2(unsigned char len,unsigned int s)   //串口发送数据
(0623) {//要求流量板在s个8ms内通过串口返回数据
(0624) unsigned char t,i; 	
(0625) 
(0626) for(t=0;t<74;t++)
    004ED 2744      CLR	R20
    004EE C009      RJMP	0x04F8
(0627)   Uart0RxData[t]=0xff;
    004EF EF8B      LDI	R24,0xFB
    004F0 E092      LDI	R25,2
    004F1 2FE4      MOV	R30,R20
    004F2 27FF      CLR	R31
    004F3 0FE8      ADD	R30,R24
    004F4 1FF9      ADC	R31,R25
    004F5 EF8F      LDI	R24,0xFF
    004F6 8380      ST	Z,R24
    004F7 9543      INC	R20
    004F8 344A      CPI	R20,0x4A
    004F9 F3A8      BCS	0x04EF
(0628)   
(0629) Uart0RxCounter=0; //清串口接受计数  
    004FA 2422      CLR	R2
    004FB 9220 02FA STS	Uart0RxCounter,R2
(0630) 
(0631) for(t=0;t<len;t++)
    004FD 2744      CLR	R20
    004FE C010      RJMP	0x050F
(0632) {
(0633) while(!(UCSR0A&(1<<UDRE0)));   // 等待发送缓冲器为空
    004FF 9B5D      SBIS	0x0B,5
    00500 CFFE      RJMP	0x04FF
(0634) for(i=0;i<200;i++);
    00501 2766      CLR	R22
    00502 C001      RJMP	0x0504
    00503 9563      INC	R22
    00504 3C68      CPI	R22,0xC8
    00505 F3E8      BCS	0x0503
(0635) UDR0=Uart0TxData[t];  
    00506 E28F      LDI	R24,0x2F
    00507 E091      LDI	R25,1
    00508 2FE4      MOV	R30,R20
    00509 27FF      CLR	R31
    0050A 0FE8      ADD	R30,R24
    0050B 1FF9      ADC	R31,R25
    0050C 8020      LD	R2,Z
    0050D B82C      OUT	0x0C,R2
    0050E 9543      INC	R20
    0050F 1740      CP	R20,R16
    00510 F370      BCS	0x04FF
(0636) }
(0637)                   
(0638) if(s>0)
    00511 3020      CPI	R18,0
    00512 0723      CPC	R18,R19
    00513 F0F1      BEQ	0x0532
(0639) {
(0640)  //超时设定
(0641) TimeOutFlag=0; //超时标志置0
    00514 2422      CLR	R2
    00515 9220 02D9 STS	TimeOutFlag,R2
(0642) Timer0Counter=s; //8ms定时循环次数
    00517 9330 0346 STS	Timer0Counter+1,R19
    00519 9320 0345 STS	Timer0Counter,R18
(0643) TCNT0=0x06;//定时8ms
    0051B E086      LDI	R24,6
    0051C BF82      OUT	0x32,R24
(0644) TCCR0|=0x06;//256分频
    0051D B783      IN	R24,0x33
    0051E 6086      ORI	R24,6
    0051F BF83      OUT	0x33,R24
(0645) TIFR|=0x01; //清定时器0中断标志
    00520 B786      IN	R24,0x36
    00521 6081      ORI	R24,1
    00522 BF86      OUT	0x36,R24
(0646) TIMSK|=0x01;//使能定时器0中断
    00523 B787      IN	R24,0x37
    00524 6081      ORI	R24,1
    00525 BF87      OUT	0x37,R24
(0647) t=UDR0;//开串口接收中断前读空缓存
    00526 B14C      IN	R20,0x0C
(0648) UCSR0B|=0x80;//开串口接收中断
    00527 9A57      SBI	0x0A,7
(0649) while(TimeOutFlag==0);
    00528 9020 02D9 LDS	R2,TimeOutFlag
    0052A 2022      TST	R2
    0052B F3E1      BEQ	0x0528
(0650) TIMSK&=0xFE;//关定时器0中断
    0052C B787      IN	R24,0x37
    0052D 7F8E      ANDI	R24,0xFE
    0052E BF87      OUT	0x37,R24
(0651) UCSR0B&=0x7f;//关串口接收中断
    0052F B18A      IN	R24,0x0A
    00530 778F      ANDI	R24,0x7F
    00531 B98A      OUT	0x0A,R24
(0652) }
    00532 9169      LD	R22,Y+
    00533 9149      LD	R20,Y+
    00534 9508      RET
_SendUart0_3:
  t                    --> R20
  i                    --> R22
  cn                   --> R10
  s                    --> R18
  len                  --> R16
    00535 940E 2057 CALL	push_xgsetF00C
    00537 80AE      LDD	R10,Y+6
(0653) }
(0654) 
(0655) void SendUart0_3(unsigned char len,unsigned int s,unsigned char cn)   //串口发送数据，不死等，收到采集板返回的cn个字节后即退出，如一直没收到cn个字节，则超时时间s*8ms到后也退出
(0656) {//要求流量板在s个8ms内通过串口返回数据
(0657) unsigned char t,i; 	
(0658) 
(0659) for(t=0;t<74;t++)
    00538 2744      CLR	R20
    00539 C009      RJMP	0x0543
(0660)   Uart0RxData[t]=0xff;
    0053A EF8B      LDI	R24,0xFB
    0053B E092      LDI	R25,2
    0053C 2FE4      MOV	R30,R20
    0053D 27FF      CLR	R31
    0053E 0FE8      ADD	R30,R24
    0053F 1FF9      ADC	R31,R25
    00540 EF8F      LDI	R24,0xFF
    00541 8380      ST	Z,R24
    00542 9543      INC	R20
    00543 344A      CPI	R20,0x4A
    00544 F3A8      BCS	0x053A
(0661)   
(0662) Uart0RxCounter=0; //清串口接受计数  
    00545 2422      CLR	R2
    00546 9220 02FA STS	Uart0RxCounter,R2
(0663) 
(0664) for(t=0;t<len;t++)
    00548 2744      CLR	R20
    00549 C010      RJMP	0x055A
(0665) {
(0666) while(!(UCSR0A&(1<<UDRE0)));   // 等待发送缓冲器为空
    0054A 9B5D      SBIS	0x0B,5
    0054B CFFE      RJMP	0x054A
(0667) for(i=0;i<200;i++);
    0054C 2766      CLR	R22
    0054D C001      RJMP	0x054F
    0054E 9563      INC	R22
    0054F 3C68      CPI	R22,0xC8
    00550 F3E8      BCS	0x054E
(0668) UDR0=Uart0TxData[t];  
    00551 E28F      LDI	R24,0x2F
    00552 E091      LDI	R25,1
    00553 2FE4      MOV	R30,R20
    00554 27FF      CLR	R31
    00555 0FE8      ADD	R30,R24
    00556 1FF9      ADC	R31,R25
    00557 8020      LD	R2,Z
    00558 B82C      OUT	0x0C,R2
    00559 9543      INC	R20
    0055A 1740      CP	R20,R16
    0055B F370      BCS	0x054A
(0669) }
(0670)                   
(0671) if(s>0)
    0055C 3020      CPI	R18,0
    0055D 0723      CPC	R18,R19
    0055E F121      BEQ	0x0583
(0672) {
(0673)  //超时设定
(0674) TimeOutFlag=0; //超时标志置0
    0055F 2422      CLR	R2
    00560 9220 02D9 STS	TimeOutFlag,R2
(0675) Timer0Counter=s; //8ms定时循环次数
    00562 9330 0346 STS	Timer0Counter+1,R19
    00564 9320 0345 STS	Timer0Counter,R18
(0676) TCNT0=0x06;//定时8ms
    00566 E086      LDI	R24,6
    00567 BF82      OUT	0x32,R24
(0677) TCCR0|=0x06;//256分频
    00568 B783      IN	R24,0x33
    00569 6086      ORI	R24,6
    0056A BF83      OUT	0x33,R24
(0678) TIFR|=0x01; //清定时器0中断标志
    0056B B786      IN	R24,0x36
    0056C 6081      ORI	R24,1
    0056D BF86      OUT	0x36,R24
(0679) TIMSK|=0x01;//使能定时器0中断
    0056E B787      IN	R24,0x37
    0056F 6081      ORI	R24,1
    00570 BF87      OUT	0x37,R24
(0680) t=UDR0;//开串口接收中断前读空缓存
    00571 B14C      IN	R20,0x0C
(0681) UCSR0B|=0x80;//开串口接收中断
    00572 9A57      SBI	0x0A,7
    00573 C005      RJMP	0x0579
(0682) while(TimeOutFlag==0)
(0683) {
(0684)  if(Uart0RxCounter>=cn)
    00574 9020 02FA LDS	R2,Uart0RxCounter
    00576 142A      CP	R2,R10
    00577 F008      BCS	0x0579
(0685)    break;
    00578 C004      RJMP	0x057D
    00579 9020 02D9 LDS	R2,TimeOutFlag
    0057B 2022      TST	R2
    0057C F3B9      BEQ	0x0574
(0686) }
(0687) TIMSK&=0xFE;//关定时器0中断
    0057D B787      IN	R24,0x37
    0057E 7F8E      ANDI	R24,0xFE
    0057F BF87      OUT	0x37,R24
(0688) UCSR0B&=0x7f;//关串口接收中断
    00580 B18A      IN	R24,0x0A
    00581 778F      ANDI	R24,0x7F
    00582 B98A      OUT	0x0A,R24
(0689) }
    00583 940C 205E JMP	pop_xgsetF00C
_SampleADC:
  adcl                 --> Y,+0
  c                    --> R10
  ADdata               --> R12
  ch                   --> R10
    00585 940E 2065 CALL	push_xgsetF03C
    00587 2EA0      MOV	R10,R16
    00588 9724      SBIW	R28,4
(0690) }
(0691) 
(0692)  
(0693)    
(0694) unsigned char SampleADC(unsigned char ch)//耗时约5ms
(0695) {     unsigned char c;
(0696)       unsigned long adcl;
(0697) 	  unsigned int ADdata;
(0698) 
(0699) 	  ADMUX  = (0xc0+ch);//片内2.56V基准，选择单端输入通道 
    00589 2D8A      MOV	R24,R10
    0058A 5480      SUBI	R24,0x40
    0058B B987      OUT	0x07,R24
(0700) 	  ADCSRA =0xC3;//ADC使能，ADC开始转换，ADC自动触发使能（连续转换模式），8分频 
    0058C EC83      LDI	R24,0xC3
    0058D B986      OUT	0x06,R24
(0701)    
(0702) 	  //第一次采样值不要
(0703) 	  for(ADdata=0;ADdata<100;ADdata++);
    0058E 24CC      CLR	R12
    0058F 24DD      CLR	R13
    00590 C003      RJMP	0x0594
    00591 01C6      MOVW	R24,R12
    00592 9601      ADIW	R24,1
    00593 016C      MOVW	R12,R24
    00594 01C6      MOVW	R24,R12
    00595 3684      CPI	R24,0x64
    00596 E0E0      LDI	R30,0
    00597 079E      CPC	R25,R30
    00598 F3C0      BCS	0x0591
(0704) 	  while((ADCSRA&0x40)==0x40);//等待转换完成
    00599 B186      IN	R24,0x06
    0059A 7480      ANDI	R24,0x40
    0059B 3480      CPI	R24,0x40
    0059C F3E1      BEQ	0x0599
(0705) 	  ADdata=ADCL;
    0059D B0C4      IN	R12,0x04
    0059E 24DD      CLR	R13
(0706) 	  ADdata=ADCH;  
    0059F B0C5      IN	R12,0x05
    005A0 24DD      CLR	R13
(0707)   
(0708) 	  adcl=0;
    005A1 E080      LDI	R24,0
    005A2 8388      ST	Y,R24
    005A3 8389      STD	Y+1,R24
    005A4 838A      STD	Y+2,R24
    005A5 838B      STD	Y+3,R24
(0709) 	  for(c=0;c<32;c++)//32次值取平均
    005A6 24AA      CLR	R10
    005A7 C02C      RJMP	0x05D4
(0710) 	  {
(0711) 	   ADCSRA = 0xC3;//ADC使能，ADC开始转换，ADC自动触发使能（连续转换模式），8分频 
    005A8 EC83      LDI	R24,0xC3
    005A9 B986      OUT	0x06,R24
(0712) 	   for(ADdata=0;ADdata<100;ADdata++);
    005AA 24CC      CLR	R12
    005AB 24DD      CLR	R13
    005AC C003      RJMP	0x05B0
    005AD 01C6      MOVW	R24,R12
    005AE 9601      ADIW	R24,1
    005AF 016C      MOVW	R12,R24
    005B0 01C6      MOVW	R24,R12
    005B1 3684      CPI	R24,0x64
    005B2 E0E0      LDI	R30,0
    005B3 079E      CPC	R25,R30
    005B4 F3C0      BCS	0x05AD
(0713) 	   while((ADCSRA&0x40)==0x40);//等待转换完成	
    005B5 B186      IN	R24,0x06
    005B6 7480      ANDI	R24,0x40
    005B7 3480      CPI	R24,0x40
    005B8 F3E1      BEQ	0x05B5
(0714) 	   ADdata=ADCL;   
    005B9 B0C4      IN	R12,0x04
    005BA 24DD      CLR	R13
(0715) 	   ADdata|=(ADCH<<8);
    005BB B025      IN	R2,0x05
    005BC 2433      CLR	R3
    005BD 2C32      MOV	R3,R2
    005BE 2422      CLR	R2
    005BF 28C2      OR	R12,R2
    005C0 28D3      OR	R13,R3
(0716) 	   ADdata&=0x03ff;//10位有效转换结果
    005C1 01C6      MOVW	R24,R12
    005C2 7093      ANDI	R25,3
    005C3 016C      MOVW	R12,R24
(0717) 	   adcl+=ADdata;
    005C4 011C      MOVW	R2,R24
    005C5 2444      CLR	R4
    005C6 2455      CLR	R5
    005C7 8068      LD	R6,Y
    005C8 8079      LDD	R7,Y+1
    005C9 808A      LDD	R8,Y+2
    005CA 809B      LDD	R9,Y+3
    005CB 0C62      ADD	R6,R2
    005CC 1C73      ADC	R7,R3
    005CD 1C84      ADC	R8,R4
    005CE 1C95      ADC	R9,R5
    005CF 8268      ST	Y,R6
    005D0 8279      STD	Y+1,R7
    005D1 828A      STD	Y+2,R8
    005D2 829B      STD	Y+3,R9
    005D3 94A3      INC	R10
    005D4 2D8A      MOV	R24,R10
    005D5 3280      CPI	R24,0x20
    005D6 F288      BCS	0x05A8
(0718) 	  }
(0719) 
(0720) 	  adcl>>=7;//除以32，再除以4，相当于8位AD
    005D7 E087      LDI	R24,7
    005D8 E090      LDI	R25,0
    005D9 8108      LD	R16,Y
    005DA 8119      LDD	R17,Y+1
    005DB 812A      LDD	R18,Y+2
    005DC 813B      LDD	R19,Y+3
    005DD 938A      ST	-Y,R24
    005DE 940E 2099 CALL	lsr32
    005E0 8308      ST	Y,R16
    005E1 8319      STD	Y+1,R17
    005E2 832A      STD	Y+2,R18
    005E3 833B      STD	Y+3,R19
(0721) 	  return (adcl&0x000000ff);//取8位有效位
    005E4 EF4F      LDI	R20,0xFF
    005E5 E050      LDI	R21,0
    005E6 E060      LDI	R22,0
    005E7 E070      LDI	R23,0
    005E8 8028      LD	R2,Y
    005E9 8039      LDD	R3,Y+1
    005EA 804A      LDD	R4,Y+2
    005EB 805B      LDD	R5,Y+3
    005EC 2224      AND	R2,R20
    005ED 2235      AND	R3,R21
    005EE 2246      AND	R4,R22
    005EF 2257      AND	R5,R23
    005F0 2D02      MOV	R16,R2
    005F1 9624      ADIW	R28,4
    005F2 940C 206E JMP	pop_xgsetF03C
_Delay_ms:
  a                    --> Y,+1
  n                    --> R10
  f                    --> Y,+0
  t                    --> R10
    005F4 940E 2057 CALL	push_xgsetF00C
    005F6 0158      MOVW	R10,R16
    005F7 9724      SBIW	R28,4
(0722) }
(0723) 
(0724) void Delay_ms(unsigned int t)//最大定时8388ms
(0725) {   
(0726)     float f;
(0727) 	unsigned char a;
(0728)     unsigned int n;
(0729) 	
(0730) 	if(t==0){return;}
    005F8 20AA      TST	R10
    005F9 F419      BNE	0x05FD
    005FA 20BB      TST	R11
    005FB F409      BNE	0x05FD
    005FC C03A      RJMP	0x0637
(0731) 	
(0732)     TCCR1B = 0x00; //stop
    005FD 2422      CLR	R2
    005FE BC2E      OUT	0x2E,R2
(0733) 	if(t>8388)
    005FF EC84      LDI	R24,0xC4
    00600 E290      LDI	R25,0x20
    00601 158A      CP	R24,R10
    00602 059B      CPC	R25,R11
    00603 F408      BCC	0x0605
(0734) 	   t=8388;
    00604 015C      MOVW	R10,R24
(0735) 	f=t;
    00605 0185      MOVW	R16,R10
    00606 940E 20D7 CALL	uint2fp
    00608 8308      ST	Y,R16
    00609 8319      STD	Y+1,R17
    0060A 832A      STD	Y+2,R18
    0060B 833B      STD	Y+3,R19
(0736) 	f*=7.8125;
    0060C E908      LDI	R16,0x98
    0060D E010      LDI	R17,0
    0060E 940E 202D CALL	elpm32
    00610 01CE      MOVW	R24,R28
    00611 939A      ST	-Y,R25
    00612 938A      ST	-Y,R24
    00613 940E 2274 CALL	fpmule1
    00615 8308      ST	Y,R16
    00616 8319      STD	Y+1,R17
    00617 832A      STD	Y+2,R18
    00618 833B      STD	Y+3,R19
(0737) 	n=f;
    00619 8108      LD	R16,Y
    0061A 8119      LDD	R17,Y+1
    0061B 812A      LDD	R18,Y+2
    0061C 813B      LDD	R19,Y+3
    0061D 940E 20A5 CALL	fpint
    0061F 0158      MOVW	R10,R16
(0738)     TCNT1 = 65535-n;  
    00620 0115      MOVW	R2,R10
    00621 2444      CLR	R4
    00622 2455      CLR	R5
    00623 EF4F      LDI	R20,0xFF
    00624 EF5F      LDI	R21,0xFF
    00625 E060      LDI	R22,0
    00626 E070      LDI	R23,0
    00627 1942      SUB	R20,R2
    00628 0953      SBC	R21,R3
    00629 0964      SBC	R22,R4
    0062A 0975      SBC	R23,R5
    0062B BD5D      OUT	0x2D,R21
    0062C BD4C      OUT	0x2C,R20
(0739) 	TIFR|=0x04; //清定时器1中断标志 
    0062D B786      IN	R24,0x36
    0062E 6084      ORI	R24,4
    0062F BF86      OUT	0x36,R24
(0740)  	TCCR1B = 0x05; //1024分频
    00630 E085      LDI	R24,5
    00631 BD8E      OUT	0x2E,R24
(0741)     while((TIFR&0x04)==0x00) ; 
    00632 B626      IN	R2,0x36
    00633 FE22      SBRS	R2,2
    00634 CFFD      RJMP	0x0632
(0742)     TCCR1B = 0x00; //stop
    00635 2422      CLR	R2
    00636 BC2E      OUT	0x2E,R2
    00637 9624      ADIW	R28,4
    00638 940C 205E JMP	pop_xgsetF00C
(0743) }
(0744) 
(0745) 
(0746) void Start(void)
(0747) {
(0748)  InitialIO();
_Start:
    0063A DC35      RCALL	_InitialIO
(0749)  uart0_init();
    0063B DE5B      RCALL	_uart0_init
(0750)  uart1_init();
    0063C DC42      RCALL	_uart1_init
(0751) 
(0752)  IntFlag=0;//无接收帧中断
    0063D 2422      CLR	R2
    0063E 9220 02BF STS	IntFlag,R2
(0753)  DataFlag=0;//无标定系数下发 
    00640 2433      CLR	R3
    00641 9230 02C2 STS	DataFlag+1,R3
    00643 9220 02C1 STS	DataFlag,R2
(0754)  coeff_len=0;
    00645 9230 012D STS	coeff_len+1,R3
    00647 9220 012C STS	coeff_len,R2
(0755)  coeff_count=0;//标定系数计数
    00649 9230 012B STS	coeff_count+1,R3
    0064B 9220 012A STS	coeff_count,R2
(0756)  
(0757) 
(0758)  
(0759) 	EICRA|=0x03; //INT0上升沿触发 ，每2位控制一个中断，共4个中断，0-低电平触发，1-保留，2-下降沿触发，3-上升沿触发 
    0064D 9180 006A LDS	R24,0x6A
    0064F 6083      ORI	R24,3
    00650 9380 006A STS	0x6A,R24
(0760) 	MANINT_CLR
    00652 B788      IN	R24,0x38
    00653 6081      ORI	R24,1
    00654 BF88      OUT	0x38,R24
(0761) 	MANINT_EN
    00655 B789      IN	R24,0x39
    00656 6081      ORI	R24,1
    00657 BF89      OUT	0x39,R24
(0762) 	INT_EN
    00658 9478      BSET	7
    00659 9508      RET
_main:
  pt                   --> Y,+2
  mk                   --> Y,+2
  at                   --> Y,+2
  add                  --> Y,+2
  f                    --> Y,+5
  TestDataBlockCount   --> R12
  TestDataBlockIndex   --> R10
  i                    --> R10
  l                    --> Y,+1
  j                    --> R10
    0065A 9729      SBIW	R28,0x9
(0763) }
(0764) 
(0765)  
(0766) 
(0767) void main(void)
(0768) { 
(0769)   unsigned char i;
(0770)   unsigned int add,at,mk,pt,j;
(0771)   unsigned long l;
(0772)   unsigned int TestDataBlockIndex,TestDataBlockCount;
(0773)   float f;
(0774)  
(0775) 	for(l=0;l<1000;l++)
    0065B E080      LDI	R24,0
    0065C 8389      STD	Y+1,R24
    0065D 838A      STD	Y+2,R24
    0065E 838B      STD	Y+3,R24
    0065F 838C      STD	Y+4,R24
    00660 C01B      RJMP	0x067C
(0776) 	{
(0777) 		for(j=0;j<1000;j++);
    00661 24AA      CLR	R10
    00662 24BB      CLR	R11
    00663 C003      RJMP	0x0667
    00664 01C5      MOVW	R24,R10
    00665 9601      ADIW	R24,1
    00666 015C      MOVW	R10,R24
    00667 01C5      MOVW	R24,R10
    00668 3E88      CPI	R24,0xE8
    00669 E0E3      LDI	R30,3
    0066A 079E      CPC	R25,R30
    0066B F3C0      BCS	0x0664
    0066C E041      LDI	R20,1
    0066D E050      LDI	R21,0
    0066E E060      LDI	R22,0
    0066F E070      LDI	R23,0
    00670 8029      LDD	R2,Y+1
    00671 803A      LDD	R3,Y+2
    00672 804B      LDD	R4,Y+3
    00673 805C      LDD	R5,Y+4
    00674 0E24      ADD	R2,R20
    00675 1E35      ADC	R3,R21
    00676 1E46      ADC	R4,R22
    00677 1E57      ADC	R5,R23
    00678 8229      STD	Y+1,R2
    00679 823A      STD	Y+2,R3
    0067A 824B      STD	Y+3,R4
    0067B 825C      STD	Y+4,R5
    0067C EE48      LDI	R20,0xE8
    0067D E053      LDI	R21,3
    0067E E060      LDI	R22,0
    0067F E070      LDI	R23,0
    00680 8029      LDD	R2,Y+1
    00681 803A      LDD	R3,Y+2
    00682 804B      LDD	R4,Y+3
    00683 805C      LDD	R5,Y+4
    00684 1624      CP	R2,R20
    00685 0635      CPC	R3,R21
    00686 0646      CPC	R4,R22
    00687 0657      CPC	R5,R23
    00688 F2C0      BCS	0x0661
(0778) 	}
(0779) 
(0780) 	Start();
    00689 DFB0      RCALL	_Start
(0781) 
(0782)    Delay_ms(50); 
    0068A E302      LDI	R16,0x32
    0068B E010      LDI	R17,0
    0068C DF67      RCALL	_Delay_ms
(0783) 
(0784) 
(0785)    
(0786) 	//采集总线电压，判断是否进入存储状态  
(0787) 	if(SampleADC(0)<30)//Cable端的电压低于30V 
    0068D 2700      CLR	R16
    0068E DEF6      RCALL	_SampleADC
    0068F 310E      CPI	R16,0x1E
    00690 F010      BCS	0x0693
    00691 940C 1B82 JMP	0x1B82
(0788) 	{	  
(0789) 		UCSR0B = 0x00;
    00693 2422      CLR	R2
    00694 B82A      OUT	0x0A,R2
(0790) 		PORTE&=0xFD;
    00695 B183      IN	R24,0x03
    00696 7F8D      ANDI	R24,0xFD
    00697 B983      OUT	0x03,R24
(0791) 		DDRE|=0x02;
    00698 9A11      SBI	0x02,1
(0792) 		PORTE&=0xFD;	 
    00699 B183      IN	R24,0x03
    0069A 7F8D      ANDI	R24,0xFD
    0069B B983      OUT	0x03,R24
(0793) 		while(1); 
    0069C CFFF      RJMP	0x069C
(0794) 	}
(0795) 	     
(0796) 	while(1)//若Cable端为高电压，则进入正常的通讯状态
(0797) 	{ 
(0798) 		 
(0799) 
(0800) 		if(IntFlag==2)//校验位错误，不上传任何响应，上位机按超时处理
    0069D 9180 02BF LDS	R24,IntFlag
    0069F 3082      CPI	R24,2
    006A0 F459      BNE	0x06AC
(0801) 		{ 
(0802) 			IntFlag=0;//无命令帧
    006A1 2422      CLR	R2
    006A2 9220 02BF STS	IntFlag,R2
(0803) 			EIFR|=0x01;//清INT0中断标志
    006A4 B788      IN	R24,0x38
    006A5 6081      ORI	R24,1
    006A6 BF88      OUT	0x38,R24
(0804) 			EIMSK|=0x01;//使能INT0中断	 
    006A7 B789      IN	R24,0x39
    006A8 6081      ORI	R24,1
    006A9 BF89      OUT	0x39,R24
(0805) 		}
    006AA 940C 1B82 JMP	0x1B82
(0806) 		else if(IntFlag==1)//接收到了正常命令帧
    006AC 9180 02BF LDS	R24,IntFlag
    006AE 3081      CPI	R24,1
    006AF F011      BEQ	0x06B2
    006B0 940C 1B82 JMP	0x1B82
(0807) 		{
(0808) 			if(DataFlag)
    006B2 9020 02C1 LDS	R2,DataFlag
    006B4 9030 02C2 LDS	R3,DataFlag+1
    006B6 2022      TST	R2
    006B7 F419      BNE	0x06BB
    006B8 2033      TST	R3
    006B9 F409      BNE	0x06BB
    006BA C4B4      RJMP	0x0B6F
(0809) 			{ 		  
(0810) 				coeffdata[coeff_count]=R_dat;
    006BB E789      LDI	R24,0x79
    006BC E091      LDI	R25,1
    006BD 91E0 012A LDS	R30,coeff_count
    006BF 91F0 012B LDS	R31,coeff_count+1
    006C1 0FE8      ADD	R30,R24
    006C2 1FF9      ADC	R31,R25
    006C3 9020 02DF LDS	R2,R_dat
    006C5 9030 02E0 LDS	R3,R_dat+1
    006C7 8220      ST	Z,R2
(0811) 				coeff_count++;	  
    006C8 9180 012A LDS	R24,coeff_count
    006CA 9190 012B LDS	R25,coeff_count+1
    006CC 9601      ADIW	R24,1
    006CD 9390 012B STS	coeff_count+1,R25
    006CF 9380 012A STS	coeff_count,R24
(0812) 
(0813) 				if(coeff_count==coeff_len)
    006D1 9020 012C LDS	R2,coeff_len
    006D3 9030 012D LDS	R3,coeff_len+1
    006D5 1582      CP	R24,R2
    006D6 0593      CPC	R25,R3
    006D7 F011      BEQ	0x06DA
    006D8 940C 1B79 JMP	0x1B79
(0814) 				{
(0815) 					if(DataFlag==1)//下发压力温度系数
    006DA 9180 02C1 LDS	R24,DataFlag
    006DC 9190 02C2 LDS	R25,DataFlag+1
    006DE 3081      CPI	R24,1
    006DF E0E0      LDI	R30,0
    006E0 079E      CPC	R25,R30
    006E1 F009      BEQ	0x06E3
    006E2 C0E5      RJMP	0x07C8
(0816) 					{
(0817) 						Uart0TxData[0]=0xE8;
    006E3 EE88      LDI	R24,0xE8
    006E4 9380 012F STS	Uart0TxData,R24
(0818) 						Uart0TxData[1]=0x40;
    006E6 E480      LDI	R24,0x40
    006E7 9380 0130 STS	Uart0TxData+1,R24
(0819) 						Uart0TxData[2]=0x88;
    006E9 E888      LDI	R24,0x88
    006EA 9380 0131 STS	Uart0TxData+2,R24
(0820) 						Uart0TxData[3]=0;//压力温度系数包0
    006EC 2422      CLR	R2
    006ED 9220 0132 STS	Uart0TxData+3,R2
(0821) 						Uart0TxData[4]=0x21;
    006EF E281      LDI	R24,0x21
    006F0 9380 0133 STS	Uart0TxData+4,R24
(0822) 						Uart0TxData[5]=0x22;
    006F2 E282      LDI	R24,0x22
    006F3 9380 0134 STS	Uart0TxData+5,R24
(0823) 						Uart0TxData[6]=0x23;
    006F5 E283      LDI	R24,0x23
    006F6 9380 0135 STS	Uart0TxData+6,R24
(0824) 						Uart0TxData[7]=0x24;
    006F8 E284      LDI	R24,0x24
    006F9 9380 0136 STS	Uart0TxData+7,R24
(0825) 						Uart0TxData[8]=0x32;	 
    006FB E382      LDI	R24,0x32
    006FC 9380 0137 STS	Uart0TxData+8,R24
(0826) 						for(k=0;k<64;k++)
    006FE 2433      CLR	R3
    006FF 9230 02BC STS	k+1,R3
    00701 9220 02BB STS	k,R2
    00703 C01A      RJMP	0x071E
(0827) 						{
(0828) 							Uart0TxData[9+k]=coeffdata[k];  
    00704 9040 02BB LDS	R4,k
    00706 9050 02BC LDS	R5,k+1
    00708 E789      LDI	R24,0x79
    00709 E091      LDI	R25,1
    0070A 01F2      MOVW	R30,R4
    0070B 0FE8      ADD	R30,R24
    0070C 1FF9      ADC	R31,R25
    0070D 8020      LD	R2,Z
    0070E E28F      LDI	R24,0x2F
    0070F E091      LDI	R25,1
    00710 01F2      MOVW	R30,R4
    00711 9639      ADIW	R30,0x9
    00712 0FE8      ADD	R30,R24
    00713 1FF9      ADC	R31,R25
    00714 8220      ST	Z,R2
    00715 9180 02BB LDS	R24,k
    00717 9190 02BC LDS	R25,k+1
    00719 9601      ADIW	R24,1
    0071A 9390 02BC STS	k+1,R25
    0071C 9380 02BB STS	k,R24
    0071E 9180 02BB LDS	R24,k
    00720 9190 02BC LDS	R25,k+1
    00722 3480      CPI	R24,0x40
    00723 E0E0      LDI	R30,0
    00724 079E      CPC	R25,R30
    00725 F2F0      BCS	0x0704
(0829) 						}		 
(0830) 						SendUart0_2(74,20);//超时160ms
    00726 E124      LDI	R18,0x14
    00727 E030      LDI	R19,0
    00728 E40A      LDI	R16,0x4A
    00729 DDC1      RCALL	_SendUart0_2
(0831) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x88))
    0072A 9180 02FA LDS	R24,Uart0RxCounter
    0072C 3089      CPI	R24,0x9
    0072D F4B1      BNE	0x0744
    0072E 9180 02FB LDS	R24,Uart0RxData
    00730 3585      CPI	R24,0x55
    00731 F491      BNE	0x0744
    00732 9180 02FC LDS	R24,Uart0RxData+1
    00734 3480      CPI	R24,0x40
    00735 F471      BNE	0x0744
    00736 9180 02FD LDS	R24,Uart0RxData+2
    00738 3888      CPI	R24,0x88
    00739 F451      BNE	0x0744
(0832) 						{T_dat&=0xff00; }
    0073A 9180 02E1 LDS	R24,T_dat
    0073C 9190 02E2 LDS	R25,T_dat+1
    0073E 7080      ANDI	R24,0
    0073F 9390 02E2 STS	T_dat+1,R25
    00741 9380 02E1 STS	T_dat,R24
    00743 C006      RJMP	0x074A
(0833) 						else
(0834) 						{T_dat=0x00aa; }
    00744 EA8A      LDI	R24,0xAA
    00745 E090      LDI	R25,0
    00746 9390 02E2 STS	T_dat+1,R25
    00748 9380 02E1 STS	T_dat,R24
(0835) 
(0836) 						Uart0TxData[0]=0xE8;
    0074A EE88      LDI	R24,0xE8
    0074B 9380 012F STS	Uart0TxData,R24
(0837) 						Uart0TxData[1]=0x40;
    0074D E480      LDI	R24,0x40
    0074E 9380 0130 STS	Uart0TxData+1,R24
(0838) 						Uart0TxData[2]=0x88;
    00750 E888      LDI	R24,0x88
    00751 9380 0131 STS	Uart0TxData+2,R24
(0839) 						Uart0TxData[3]=1;//压力温度系数包1
    00753 E081      LDI	R24,1
    00754 9380 0132 STS	Uart0TxData+3,R24
(0840) 						Uart0TxData[4]=0x21;
    00756 E281      LDI	R24,0x21
    00757 9380 0133 STS	Uart0TxData+4,R24
(0841) 						Uart0TxData[5]=0x22;
    00759 E282      LDI	R24,0x22
    0075A 9380 0134 STS	Uart0TxData+5,R24
(0842) 						Uart0TxData[6]=0x23;
    0075C E283      LDI	R24,0x23
    0075D 9380 0135 STS	Uart0TxData+6,R24
(0843) 						Uart0TxData[7]=0x24;
    0075F E284      LDI	R24,0x24
    00760 9380 0136 STS	Uart0TxData+7,R24
(0844) 						Uart0TxData[8]=0x32;	 
    00762 E382      LDI	R24,0x32
    00763 9380 0137 STS	Uart0TxData+8,R24
(0845) 						for(k=0;k<64;k++)
    00765 2422      CLR	R2
    00766 2433      CLR	R3
    00767 9230 02BC STS	k+1,R3
    00769 9220 02BB STS	k,R2
    0076B C01C      RJMP	0x0788
(0846) 						{
(0847) 							Uart0TxData[9+k]=coeffdata[k+64];  
    0076C 90A0 02BB LDS	R10,k
    0076E 90B0 02BC LDS	R11,k+1
    00770 E789      LDI	R24,0x79
    00771 E091      LDI	R25,1
    00772 01F5      MOVW	R30,R10
    00773 5CE0      SUBI	R30,0xC0
    00774 4FFF      SBCI	R31,0xFF
    00775 0FE8      ADD	R30,R24
    00776 1FF9      ADC	R31,R25
    00777 8020      LD	R2,Z
    00778 E28F      LDI	R24,0x2F
    00779 E091      LDI	R25,1
    0077A 01F5      MOVW	R30,R10
    0077B 9639      ADIW	R30,0x9
    0077C 0FE8      ADD	R30,R24
    0077D 1FF9      ADC	R31,R25
    0077E 8220      ST	Z,R2
    0077F 9180 02BB LDS	R24,k
    00781 9190 02BC LDS	R25,k+1
    00783 9601      ADIW	R24,1
    00784 9390 02BC STS	k+1,R25
    00786 9380 02BB STS	k,R24
    00788 9180 02BB LDS	R24,k
    0078A 9190 02BC LDS	R25,k+1
    0078C 3480      CPI	R24,0x40
    0078D E0E0      LDI	R30,0
    0078E 079E      CPC	R25,R30
    0078F F2E0      BCS	0x076C
(0848) 						}		 
(0849) 						SendUart0_2(74,20);//超时160ms
    00790 E124      LDI	R18,0x14
    00791 E030      LDI	R19,0
    00792 E40A      LDI	R16,0x4A
    00793 DD57      RCALL	_SendUart0_2
(0850) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x88))
    00794 9180 02FA LDS	R24,Uart0RxCounter
    00796 3089      CPI	R24,0x9
    00797 F4B1      BNE	0x07AE
    00798 9180 02FB LDS	R24,Uart0RxData
    0079A 3585      CPI	R24,0x55
    0079B F491      BNE	0x07AE
    0079C 9180 02FC LDS	R24,Uart0RxData+1
    0079E 3480      CPI	R24,0x40
    0079F F471      BNE	0x07AE
    007A0 9180 02FD LDS	R24,Uart0RxData+2
    007A2 3888      CPI	R24,0x88
    007A3 F451      BNE	0x07AE
(0851) 						{T_dat&=0x00ff; }
    007A4 9180 02E1 LDS	R24,T_dat
    007A6 9190 02E2 LDS	R25,T_dat+1
    007A8 7090      ANDI	R25,0
    007A9 9390 02E2 STS	T_dat+1,R25
    007AB 9380 02E1 STS	T_dat,R24
    007AD C009      RJMP	0x07B7
(0852) 						else
(0853) 						{T_dat|=0x5500; }
    007AE 9180 02E1 LDS	R24,T_dat
    007B0 9190 02E2 LDS	R25,T_dat+1
    007B2 6595      ORI	R25,0x55
    007B3 9390 02E2 STS	T_dat+1,R25
    007B5 9380 02E1 STS	T_dat,R24
(0854) 
(0855) 						DataFlag=0;
    007B7 2422      CLR	R2
    007B8 2433      CLR	R3
    007B9 9230 02C2 STS	DataFlag+1,R3
    007BB 9220 02C1 STS	DataFlag,R2
(0856) 						coeff_len=0;	
    007BD 9230 012D STS	coeff_len+1,R3
    007BF 9220 012C STS	coeff_len,R2
(0857) 						T_com=0x0A;
    007C1 E08A      LDI	R24,0xA
    007C2 9380 02DA STS	T_com,R24
(0858) 						SendManchester();		
    007C4 940E 1B86 CALL	_SendManchester
(0859) 					}
    007C6 940C 1B79 JMP	0x1B79
(0860) 					else if(DataFlag==2)//下发流量系数
    007C8 9180 02C1 LDS	R24,DataFlag
    007CA 9190 02C2 LDS	R25,DataFlag+1
    007CC 3082      CPI	R24,2
    007CD E0E0      LDI	R30,0
    007CE 079E      CPC	R25,R30
    007CF F009      BEQ	0x07D1
    007D0 C0E6      RJMP	0x08B7
(0861) 					{
(0862) 						Uart0TxData[0]=0xE8;
    007D1 EE88      LDI	R24,0xE8
    007D2 9380 012F STS	Uart0TxData,R24
(0863) 						Uart0TxData[1]=0x40;
    007D4 E480      LDI	R24,0x40
    007D5 9380 0130 STS	Uart0TxData+1,R24
(0864) 						Uart0TxData[2]=0x88;
    007D7 E888      LDI	R24,0x88
    007D8 9380 0131 STS	Uart0TxData+2,R24
(0865) 						Uart0TxData[3]=2;//流量系数包2
    007DA E082      LDI	R24,2
    007DB 9380 0132 STS	Uart0TxData+3,R24
(0866) 						Uart0TxData[4]=0x21;
    007DD E281      LDI	R24,0x21
    007DE 9380 0133 STS	Uart0TxData+4,R24
(0867) 						Uart0TxData[5]=0x22;
    007E0 E282      LDI	R24,0x22
    007E1 9380 0134 STS	Uart0TxData+5,R24
(0868) 						Uart0TxData[6]=0x23;
    007E3 E283      LDI	R24,0x23
    007E4 9380 0135 STS	Uart0TxData+6,R24
(0869) 						Uart0TxData[7]=0x24;
    007E6 E284      LDI	R24,0x24
    007E7 9380 0136 STS	Uart0TxData+7,R24
(0870) 						Uart0TxData[8]=0x32;	 
    007E9 E382      LDI	R24,0x32
    007EA 9380 0137 STS	Uart0TxData+8,R24
(0871) 						for(k=0;k<64;k++)
    007EC 2422      CLR	R2
    007ED 2433      CLR	R3
    007EE 9230 02BC STS	k+1,R3
    007F0 9220 02BB STS	k,R2
    007F2 C01A      RJMP	0x080D
(0872) 						{
(0873) 							Uart0TxData[9+k]=coeffdata[k];  
    007F3 90A0 02BB LDS	R10,k
    007F5 90B0 02BC LDS	R11,k+1
    007F7 E789      LDI	R24,0x79
    007F8 E091      LDI	R25,1
    007F9 01F5      MOVW	R30,R10
    007FA 0FE8      ADD	R30,R24
    007FB 1FF9      ADC	R31,R25
    007FC 8020      LD	R2,Z
    007FD E28F      LDI	R24,0x2F
    007FE E091      LDI	R25,1
    007FF 01F5      MOVW	R30,R10
    00800 9639      ADIW	R30,0x9
    00801 0FE8      ADD	R30,R24
    00802 1FF9      ADC	R31,R25
    00803 8220      ST	Z,R2
    00804 9180 02BB LDS	R24,k
    00806 9190 02BC LDS	R25,k+1
    00808 9601      ADIW	R24,1
    00809 9390 02BC STS	k+1,R25
    0080B 9380 02BB STS	k,R24
    0080D 9180 02BB LDS	R24,k
    0080F 9190 02BC LDS	R25,k+1
    00811 3480      CPI	R24,0x40
    00812 E0E0      LDI	R30,0
    00813 079E      CPC	R25,R30
    00814 F2F0      BCS	0x07F3
(0874) 						}		 
(0875) 						SendUart0_2(74,20);//超时160ms
    00815 E124      LDI	R18,0x14
    00816 E030      LDI	R19,0
    00817 E40A      LDI	R16,0x4A
    00818 DCD2      RCALL	_SendUart0_2
(0876) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x88))
    00819 9180 02FA LDS	R24,Uart0RxCounter
    0081B 3089      CPI	R24,0x9
    0081C F4B1      BNE	0x0833
    0081D 9180 02FB LDS	R24,Uart0RxData
    0081F 3585      CPI	R24,0x55
    00820 F491      BNE	0x0833
    00821 9180 02FC LDS	R24,Uart0RxData+1
    00823 3480      CPI	R24,0x40
    00824 F471      BNE	0x0833
    00825 9180 02FD LDS	R24,Uart0RxData+2
    00827 3888      CPI	R24,0x88
    00828 F451      BNE	0x0833
(0877) 						{T_dat&=0xff00; }
    00829 9180 02E1 LDS	R24,T_dat
    0082B 9190 02E2 LDS	R25,T_dat+1
    0082D 7080      ANDI	R24,0
    0082E 9390 02E2 STS	T_dat+1,R25
    00830 9380 02E1 STS	T_dat,R24
    00832 C006      RJMP	0x0839
(0878) 						else
(0879) 						{T_dat=0x00aa; }
    00833 EA8A      LDI	R24,0xAA
    00834 E090      LDI	R25,0
    00835 9390 02E2 STS	T_dat+1,R25
    00837 9380 02E1 STS	T_dat,R24
(0880) 
(0881) 						Uart0TxData[0]=0xE8;
    00839 EE88      LDI	R24,0xE8
    0083A 9380 012F STS	Uart0TxData,R24
(0882) 						Uart0TxData[1]=0x40;
    0083C E480      LDI	R24,0x40
    0083D 9380 0130 STS	Uart0TxData+1,R24
(0883) 						Uart0TxData[2]=0x88;
    0083F E888      LDI	R24,0x88
    00840 9380 0131 STS	Uart0TxData+2,R24
(0884) 						Uart0TxData[3]=3;//流量系数包3
    00842 E083      LDI	R24,3
    00843 9380 0132 STS	Uart0TxData+3,R24
(0885) 						Uart0TxData[4]=0x21;
    00845 E281      LDI	R24,0x21
    00846 9380 0133 STS	Uart0TxData+4,R24
(0886) 						Uart0TxData[5]=0x22;
    00848 E282      LDI	R24,0x22
    00849 9380 0134 STS	Uart0TxData+5,R24
(0887) 						Uart0TxData[6]=0x23;
    0084B E283      LDI	R24,0x23
    0084C 9380 0135 STS	Uart0TxData+6,R24
(0888) 						Uart0TxData[7]=0x24;
    0084E E284      LDI	R24,0x24
    0084F 9380 0136 STS	Uart0TxData+7,R24
(0889) 						Uart0TxData[8]=0x32;	 
    00851 E382      LDI	R24,0x32
    00852 9380 0137 STS	Uart0TxData+8,R24
(0890) 						for(k=0;k<64;k++)
    00854 2422      CLR	R2
    00855 2433      CLR	R3
    00856 9230 02BC STS	k+1,R3
    00858 9220 02BB STS	k,R2
    0085A C01C      RJMP	0x0877
(0891) 						{
(0892) 							Uart0TxData[9+k]=coeffdata[k+64];  
    0085B 90A0 02BB LDS	R10,k
    0085D 90B0 02BC LDS	R11,k+1
    0085F E789      LDI	R24,0x79
    00860 E091      LDI	R25,1
    00861 01F5      MOVW	R30,R10
    00862 5CE0      SUBI	R30,0xC0
    00863 4FFF      SBCI	R31,0xFF
    00864 0FE8      ADD	R30,R24
    00865 1FF9      ADC	R31,R25
    00866 8020      LD	R2,Z
    00867 E28F      LDI	R24,0x2F
    00868 E091      LDI	R25,1
    00869 01F5      MOVW	R30,R10
    0086A 9639      ADIW	R30,0x9
    0086B 0FE8      ADD	R30,R24
    0086C 1FF9      ADC	R31,R25
    0086D 8220      ST	Z,R2
    0086E 9180 02BB LDS	R24,k
    00870 9190 02BC LDS	R25,k+1
    00872 9601      ADIW	R24,1
    00873 9390 02BC STS	k+1,R25
    00875 9380 02BB STS	k,R24
    00877 9180 02BB LDS	R24,k
    00879 9190 02BC LDS	R25,k+1
    0087B 3480      CPI	R24,0x40
    0087C E0E0      LDI	R30,0
    0087D 079E      CPC	R25,R30
    0087E F2E0      BCS	0x085B
(0893) 						}		 
(0894) 						SendUart0_2(74,20);//超时160ms
    0087F E124      LDI	R18,0x14
    00880 E030      LDI	R19,0
    00881 E40A      LDI	R16,0x4A
    00882 DC68      RCALL	_SendUart0_2
(0895) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x88))
    00883 9180 02FA LDS	R24,Uart0RxCounter
    00885 3089      CPI	R24,0x9
    00886 F4B1      BNE	0x089D
    00887 9180 02FB LDS	R24,Uart0RxData
    00889 3585      CPI	R24,0x55
    0088A F491      BNE	0x089D
    0088B 9180 02FC LDS	R24,Uart0RxData+1
    0088D 3480      CPI	R24,0x40
    0088E F471      BNE	0x089D
    0088F 9180 02FD LDS	R24,Uart0RxData+2
    00891 3888      CPI	R24,0x88
    00892 F451      BNE	0x089D
(0896) 						{T_dat&=0x00ff; }
    00893 9180 02E1 LDS	R24,T_dat
    00895 9190 02E2 LDS	R25,T_dat+1
    00897 7090      ANDI	R25,0
    00898 9390 02E2 STS	T_dat+1,R25
    0089A 9380 02E1 STS	T_dat,R24
    0089C C009      RJMP	0x08A6
(0897) 						else
(0898) 						{T_dat|=0x5500; }
    0089D 9180 02E1 LDS	R24,T_dat
    0089F 9190 02E2 LDS	R25,T_dat+1
    008A1 6595      ORI	R25,0x55
    008A2 9390 02E2 STS	T_dat+1,R25
    008A4 9380 02E1 STS	T_dat,R24
(0899) 
(0900) 						DataFlag=0;
    008A6 2422      CLR	R2
    008A7 2433      CLR	R3
    008A8 9230 02C2 STS	DataFlag+1,R3
    008AA 9220 02C1 STS	DataFlag,R2
(0901) 						coeff_len=0;	
    008AC 9230 012D STS	coeff_len+1,R3
    008AE 9220 012C STS	coeff_len,R2
(0902) 						T_com=0x0B;
    008B0 E08B      LDI	R24,0xB
    008B1 9380 02DA STS	T_com,R24
(0903) 						SendManchester();		
    008B3 940E 1B86 CALL	_SendManchester
(0904) 					}	
    008B5 940C 1B79 JMP	0x1B79
(0905) 					else if(DataFlag==3)//提取测试数据
    008B7 9180 02C1 LDS	R24,DataFlag
    008B9 9190 02C2 LDS	R25,DataFlag+1
    008BB 3083      CPI	R24,3
    008BC E0E0      LDI	R30,0
    008BD 079E      CPC	R25,R30
    008BE F009      BEQ	0x08C0
    008BF C0A4      RJMP	0x0964
(0906) 					{
(0907) 						DataFlag=0;
    008C0 2422      CLR	R2
    008C1 2433      CLR	R3
    008C2 9230 02C2 STS	DataFlag+1,R3
    008C4 9220 02C1 STS	DataFlag,R2
(0908) 						coeff_len=0;	
    008C6 9230 012D STS	coeff_len+1,R3
    008C8 9220 012C STS	coeff_len,R2
(0909) 						T_com=0x09;
    008CA E089      LDI	R24,0x9
    008CB 9380 02DA STS	T_com,R24
(0910) 						TestDataBlockIndex=coeffdata[1];
    008CD 90A0 017A LDS	R10,coeffdata+1
    008CF 24BB      CLR	R11
(0911) 						TestDataBlockIndex<<=8;
    008D0 2CBA      MOV	R11,R10
    008D1 24AA      CLR	R10
(0912) 						TestDataBlockIndex|=coeffdata[0];//首块地址/索引
    008D2 9020 0179 LDS	R2,coeffdata
    008D4 2433      CLR	R3
    008D5 28A2      OR	R10,R2
    008D6 28B3      OR	R11,R3
(0913) 						TestDataBlockCount=coeffdata[3];
    008D7 90C0 017C LDS	R12,coeffdata+3
    008D9 24DD      CLR	R13
(0914) 						TestDataBlockCount<<=8;
    008DA 2CDC      MOV	R13,R12
    008DB 24CC      CLR	R12
(0915) 						TestDataBlockCount|=coeffdata[2];//需提取的总包数，每包64字节，每块4096字节共64包
    008DC 9020 017B LDS	R2,coeffdata+2
    008DE 2433      CLR	R3
    008DF 28C2      OR	R12,R2
    008E0 28D3      OR	R13,R3
(0916) 
(0917) 						for(k=0;k<TestDataBlockCount;k++)//按用户要求分包进行上传，每包64字节传32帧
    008E1 2422      CLR	R2
    008E2 9230 02BC STS	k+1,R3
    008E4 9220 02BB STS	k,R2
    008E6 C073      RJMP	0x095A
(0918) 						{
(0919) 							Uart0TxData[0]=0xE8;
    008E7 EE88      LDI	R24,0xE8
    008E8 9380 012F STS	Uart0TxData,R24
(0920) 							Uart0TxData[1]=0x40;
    008EA E480      LDI	R24,0x40
    008EB 9380 0130 STS	Uart0TxData+1,R24
(0921) 							Uart0TxData[2]=0x9A;//读测试数据
    008ED E98A      LDI	R24,0x9A
    008EE 9380 0131 STS	Uart0TxData+2,R24
(0922) 							Uart0TxData[3]=8;
    008F0 E088      LDI	R24,0x8
    008F1 9380 0132 STS	Uart0TxData+3,R24
(0923) 
(0924) 							//统一块索引
(0925) 							Uart0TxData[4]=(k); 	
    008F3 9020 02BB LDS	R2,k
    008F5 9030 02BC LDS	R3,k+1
    008F7 9220 0133 STS	Uart0TxData+4,R2
(0926) 							Uart0TxData[5]=(k>>8); 	//包索引	
    008F9 2C23      MOV	R2,R3
    008FA 2433      CLR	R3
    008FB 9220 0134 STS	Uart0TxData+5,R2
(0927) 							Uart0TxData[6]=(TestDataBlockIndex);
    008FD 92A0 0135 STS	Uart0TxData+6,R10
(0928) 							Uart0TxData[7]=(TestDataBlockIndex>>8);//首块索引
    008FF 0115      MOVW	R2,R10
    00900 2C23      MOV	R2,R3
    00901 2433      CLR	R3
    00902 9220 0136 STS	Uart0TxData+7,R2
(0929) 
(0930) 							/*
(0931) 							// 单独块索引
(0932) 							Uart0TxData[4]=(k%8); 	
(0933) 							Uart0TxData[5]=0; 	//包索引	
(0934) 							Uart0TxData[6]=(TestDataBlockIndex+k/8);
(0935) 							Uart0TxData[7]=((TestDataBlockIndex+k/8)>>8);//首块索引
(0936) 							*/
(0937) 
(0938) 							SendUart0_2(9,6);//超时48ms
    00904 E026      LDI	R18,6
    00905 E030      LDI	R19,0
    00906 E009      LDI	R16,0x9
    00907 DBE3      RCALL	_SendUart0_2
(0939) 							for(bf=0;bf<32;bf++)
    00908 2422      CLR	R2
    00909 2433      CLR	R3
    0090A 9230 0127 STS	bf+1,R3
    0090C 9220 0126 STS	bf,R2
    0090E C039      RJMP	0x0948
(0940) 							{	   	
(0941) 								T_dat=Uart0RxData[bf*2+1];//高字节
    0090F EF8B      LDI	R24,0xFB
    00910 E092      LDI	R25,2
    00911 91E0 0126 LDS	R30,bf
    00913 91F0 0127 LDS	R31,bf+1
    00915 0FEE      LSL	R30
    00916 1FFF      ROL	R31
    00917 9631      ADIW	R30,1
    00918 0FE8      ADD	R30,R24
    00919 1FF9      ADC	R31,R25
    0091A 8020      LD	R2,Z
    0091B 2433      CLR	R3
    0091C 9230 02E2 STS	T_dat+1,R3
    0091E 9220 02E1 STS	T_dat,R2
(0942) 								T_dat<<=8;
    00920 2C32      MOV	R3,R2
    00921 2422      CLR	R2
    00922 9230 02E2 STS	T_dat+1,R3
    00924 9220 02E1 STS	T_dat,R2
(0943) 								T_dat|=Uart0RxData[bf*2+0];//低字节
    00926 91E0 0126 LDS	R30,bf
    00928 91F0 0127 LDS	R31,bf+1
    0092A 0FEE      LSL	R30
    0092B 1FFF      ROL	R31
    0092C 0FE8      ADD	R30,R24
    0092D 1FF9      ADC	R31,R25
    0092E 8020      LD	R2,Z
    0092F 2433      CLR	R3
    00930 9040 02E1 LDS	R4,T_dat
    00932 9050 02E2 LDS	R5,T_dat+1
    00934 2842      OR	R4,R2
    00935 2853      OR	R5,R3
    00936 9250 02E2 STS	T_dat+1,R5
    00938 9240 02E1 STS	T_dat,R4
(0944) 								SendManchester();	
    0093A 940E 1B86 CALL	_SendManchester
(0945) 								Delay_ms(10);	 
    0093C E00A      LDI	R16,0xA
    0093D E010      LDI	R17,0
    0093E DCB5      RCALL	_Delay_ms
    0093F 9180 0126 LDS	R24,bf
    00941 9190 0127 LDS	R25,bf+1
    00943 9601      ADIW	R24,1
    00944 9390 0127 STS	bf+1,R25
    00946 9380 0126 STS	bf,R24
    00948 9180 0126 LDS	R24,bf
    0094A 9190 0127 LDS	R25,bf+1
    0094C 3280      CPI	R24,0x20
    0094D E0E0      LDI	R30,0
    0094E 079E      CPC	R25,R30
    0094F F408      BCC	0x0951
    00950 CFBE      RJMP	0x090F
    00951 9180 02BB LDS	R24,k
    00953 9190 02BC LDS	R25,k+1
    00955 9601      ADIW	R24,1
    00956 9390 02BC STS	k+1,R25
    00958 9380 02BB STS	k,R24
    0095A 9020 02BB LDS	R2,k
    0095C 9030 02BC LDS	R3,k+1
    0095E 142C      CP	R2,R12
    0095F 043D      CPC	R3,R13
    00960 F408      BCC	0x0962
    00961 CF85      RJMP	0x08E7
(0946) 							}		
(0947) 						}
(0948) 					} 
    00962 940C 1B79 JMP	0x1B79
(0949) 					else if(DataFlag==4)//下发仪器信息
    00964 9180 02C1 LDS	R24,DataFlag
    00966 9190 02C2 LDS	R25,DataFlag+1
    00968 3084      CPI	R24,4
    00969 E0E0      LDI	R30,0
    0096A 079E      CPC	R25,R30
    0096B F011      BEQ	0x096E
    0096C 940C 1B79 JMP	0x1B79
(0950) 					{
(0951) 						T_dat=0x0000;
    0096E 2422      CLR	R2
    0096F 2433      CLR	R3
    00970 9230 02E2 STS	T_dat+1,R3
    00972 9220 02E1 STS	T_dat,R2
(0952) 
(0953) 						Uart0TxData[0]=0xE8;
    00974 EE88      LDI	R24,0xE8
    00975 9380 012F STS	Uart0TxData,R24
(0954) 						Uart0TxData[1]=0x40;
    00977 E480      LDI	R24,0x40
    00978 9380 0130 STS	Uart0TxData+1,R24
(0955) 						Uart0TxData[2]=0x84;
    0097A E884      LDI	R24,0x84
    0097B 9380 0131 STS	Uart0TxData+2,R24
(0956) 						Uart0TxData[3]=0;//包0
    0097D 9220 0132 STS	Uart0TxData+3,R2
(0957) 						Uart0TxData[4]=0x21;
    0097F E281      LDI	R24,0x21
    00980 9380 0133 STS	Uart0TxData+4,R24
(0958) 						Uart0TxData[5]=0x22;
    00982 E282      LDI	R24,0x22
    00983 9380 0134 STS	Uart0TxData+5,R24
(0959) 						Uart0TxData[6]=0x23;
    00985 E283      LDI	R24,0x23
    00986 9380 0135 STS	Uart0TxData+6,R24
(0960) 						Uart0TxData[7]=0x24;
    00988 E284      LDI	R24,0x24
    00989 9380 0136 STS	Uart0TxData+7,R24
(0961) 						Uart0TxData[8]=0x32;	 
    0098B E382      LDI	R24,0x32
    0098C 9380 0137 STS	Uart0TxData+8,R24
(0962) 						for(k=0;k<64;k++)
    0098E 9230 02BC STS	k+1,R3
    00990 9220 02BB STS	k,R2
    00992 C01A      RJMP	0x09AD
(0963) 						{
(0964) 							Uart0TxData[9+k]=coeffdata[k];  
    00993 90A0 02BB LDS	R10,k
    00995 90B0 02BC LDS	R11,k+1
    00997 E789      LDI	R24,0x79
    00998 E091      LDI	R25,1
    00999 01F5      MOVW	R30,R10
    0099A 0FE8      ADD	R30,R24
    0099B 1FF9      ADC	R31,R25
    0099C 8020      LD	R2,Z
    0099D E28F      LDI	R24,0x2F
    0099E E091      LDI	R25,1
    0099F 01F5      MOVW	R30,R10
    009A0 9639      ADIW	R30,0x9
    009A1 0FE8      ADD	R30,R24
    009A2 1FF9      ADC	R31,R25
    009A3 8220      ST	Z,R2
    009A4 9180 02BB LDS	R24,k
    009A6 9190 02BC LDS	R25,k+1
    009A8 9601      ADIW	R24,1
    009A9 9390 02BC STS	k+1,R25
    009AB 9380 02BB STS	k,R24
    009AD 9180 02BB LDS	R24,k
    009AF 9190 02BC LDS	R25,k+1
    009B1 3480      CPI	R24,0x40
    009B2 E0E0      LDI	R30,0
    009B3 079E      CPC	R25,R30
    009B4 F2F0      BCS	0x0993
(0965) 						}		 
(0966) 						SendUart0_2(74,20);//超时160ms
    009B5 E124      LDI	R18,0x14
    009B6 E030      LDI	R19,0
    009B7 E40A      LDI	R16,0x4A
    009B8 DB32      RCALL	_SendUart0_2
(0967) 						if(!((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x84)))
    009B9 9180 02FA LDS	R24,Uart0RxCounter
    009BB 3089      CPI	R24,0x9
    009BC F461      BNE	0x09C9
    009BD 9180 02FB LDS	R24,Uart0RxData
    009BF 3585      CPI	R24,0x55
    009C0 F441      BNE	0x09C9
    009C1 9180 02FC LDS	R24,Uart0RxData+1
    009C3 3480      CPI	R24,0x40
    009C4 F421      BNE	0x09C9
    009C5 9180 02FD LDS	R24,Uart0RxData+2
    009C7 3884      CPI	R24,0x84
    009C8 F049      BEQ	0x09D2
(0968) 						{T_dat|=0x0001; }
    009C9 9180 02E1 LDS	R24,T_dat
    009CB 9190 02E2 LDS	R25,T_dat+1
    009CD 6081      ORI	R24,1
    009CE 9390 02E2 STS	T_dat+1,R25
    009D0 9380 02E1 STS	T_dat,R24
(0969) 
(0970) 						Uart0TxData[0]=0xE8;
    009D2 EE88      LDI	R24,0xE8
    009D3 9380 012F STS	Uart0TxData,R24
(0971) 						Uart0TxData[1]=0x40;
    009D5 E480      LDI	R24,0x40
    009D6 9380 0130 STS	Uart0TxData+1,R24
(0972) 						Uart0TxData[2]=0x84;
    009D8 E884      LDI	R24,0x84
    009D9 9380 0131 STS	Uart0TxData+2,R24
(0973) 						Uart0TxData[3]=1;//包1
    009DB E081      LDI	R24,1
    009DC 9380 0132 STS	Uart0TxData+3,R24
(0974) 						Uart0TxData[4]=0x21;
    009DE E281      LDI	R24,0x21
    009DF 9380 0133 STS	Uart0TxData+4,R24
(0975) 						Uart0TxData[5]=0x22;
    009E1 E282      LDI	R24,0x22
    009E2 9380 0134 STS	Uart0TxData+5,R24
(0976) 						Uart0TxData[6]=0x23;
    009E4 E283      LDI	R24,0x23
    009E5 9380 0135 STS	Uart0TxData+6,R24
(0977) 						Uart0TxData[7]=0x24;
    009E7 E284      LDI	R24,0x24
    009E8 9380 0136 STS	Uart0TxData+7,R24
(0978) 						Uart0TxData[8]=0x32;	 
    009EA E382      LDI	R24,0x32
    009EB 9380 0137 STS	Uart0TxData+8,R24
(0979) 						for(k=0;k<64;k++)
    009ED 2422      CLR	R2
    009EE 2433      CLR	R3
    009EF 9230 02BC STS	k+1,R3
    009F1 9220 02BB STS	k,R2
    009F3 C01C      RJMP	0x0A10
(0980) 						{
(0981) 							Uart0TxData[9+k]=coeffdata[k+64];  
    009F4 90A0 02BB LDS	R10,k
    009F6 90B0 02BC LDS	R11,k+1
    009F8 E789      LDI	R24,0x79
    009F9 E091      LDI	R25,1
    009FA 01F5      MOVW	R30,R10
    009FB 5CE0      SUBI	R30,0xC0
    009FC 4FFF      SBCI	R31,0xFF
    009FD 0FE8      ADD	R30,R24
    009FE 1FF9      ADC	R31,R25
    009FF 8020      LD	R2,Z
    00A00 E28F      LDI	R24,0x2F
    00A01 E091      LDI	R25,1
    00A02 01F5      MOVW	R30,R10
    00A03 9639      ADIW	R30,0x9
    00A04 0FE8      ADD	R30,R24
    00A05 1FF9      ADC	R31,R25
    00A06 8220      ST	Z,R2
    00A07 9180 02BB LDS	R24,k
    00A09 9190 02BC LDS	R25,k+1
    00A0B 9601      ADIW	R24,1
    00A0C 9390 02BC STS	k+1,R25
    00A0E 9380 02BB STS	k,R24
    00A10 9180 02BB LDS	R24,k
    00A12 9190 02BC LDS	R25,k+1
    00A14 3480      CPI	R24,0x40
    00A15 E0E0      LDI	R30,0
    00A16 079E      CPC	R25,R30
    00A17 F2E0      BCS	0x09F4
(0982) 						}		 
(0983) 						SendUart0_2(74,20);//超时160ms
    00A18 E124      LDI	R18,0x14
    00A19 E030      LDI	R19,0
    00A1A E40A      LDI	R16,0x4A
    00A1B DACF      RCALL	_SendUart0_2
(0984) 						if(!((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x84)))
    00A1C 9180 02FA LDS	R24,Uart0RxCounter
    00A1E 3089      CPI	R24,0x9
    00A1F F461      BNE	0x0A2C
    00A20 9180 02FB LDS	R24,Uart0RxData
    00A22 3585      CPI	R24,0x55
    00A23 F441      BNE	0x0A2C
    00A24 9180 02FC LDS	R24,Uart0RxData+1
    00A26 3480      CPI	R24,0x40
    00A27 F421      BNE	0x0A2C
    00A28 9180 02FD LDS	R24,Uart0RxData+2
    00A2A 3884      CPI	R24,0x84
    00A2B F049      BEQ	0x0A35
(0985) 						{T_dat|=0x0002; }
    00A2C 9180 02E1 LDS	R24,T_dat
    00A2E 9190 02E2 LDS	R25,T_dat+1
    00A30 6082      ORI	R24,2
    00A31 9390 02E2 STS	T_dat+1,R25
    00A33 9380 02E1 STS	T_dat,R24
(0986) 
(0987) 						Uart0TxData[0]=0xE8;
    00A35 EE88      LDI	R24,0xE8
    00A36 9380 012F STS	Uart0TxData,R24
(0988) 						Uart0TxData[1]=0x40;
    00A38 E480      LDI	R24,0x40
    00A39 9380 0130 STS	Uart0TxData+1,R24
(0989) 						Uart0TxData[2]=0x84;
    00A3B E884      LDI	R24,0x84
    00A3C 9380 0131 STS	Uart0TxData+2,R24
(0990) 						Uart0TxData[3]=2;//包2
    00A3E E082      LDI	R24,2
    00A3F 9380 0132 STS	Uart0TxData+3,R24
(0991) 						Uart0TxData[4]=0x21;
    00A41 E281      LDI	R24,0x21
    00A42 9380 0133 STS	Uart0TxData+4,R24
(0992) 						Uart0TxData[5]=0x22;
    00A44 E282      LDI	R24,0x22
    00A45 9380 0134 STS	Uart0TxData+5,R24
(0993) 						Uart0TxData[6]=0x23;
    00A47 E283      LDI	R24,0x23
    00A48 9380 0135 STS	Uart0TxData+6,R24
(0994) 						Uart0TxData[7]=0x24;
    00A4A E284      LDI	R24,0x24
    00A4B 9380 0136 STS	Uart0TxData+7,R24
(0995) 						Uart0TxData[8]=0x32;	 
    00A4D E382      LDI	R24,0x32
    00A4E 9380 0137 STS	Uart0TxData+8,R24
(0996) 						for(k=0;k<64;k++)
    00A50 2422      CLR	R2
    00A51 2433      CLR	R3
    00A52 9230 02BC STS	k+1,R3
    00A54 9220 02BB STS	k,R2
    00A56 C01C      RJMP	0x0A73
(0997) 						{
(0998) 							Uart0TxData[9+k]=coeffdata[k+128];  
    00A57 90A0 02BB LDS	R10,k
    00A59 90B0 02BC LDS	R11,k+1
    00A5B E789      LDI	R24,0x79
    00A5C E091      LDI	R25,1
    00A5D 01F5      MOVW	R30,R10
    00A5E 58E0      SUBI	R30,0x80
    00A5F 4FFF      SBCI	R31,0xFF
    00A60 0FE8      ADD	R30,R24
    00A61 1FF9      ADC	R31,R25
    00A62 8020      LD	R2,Z
    00A63 E28F      LDI	R24,0x2F
    00A64 E091      LDI	R25,1
    00A65 01F5      MOVW	R30,R10
    00A66 9639      ADIW	R30,0x9
    00A67 0FE8      ADD	R30,R24
    00A68 1FF9      ADC	R31,R25
    00A69 8220      ST	Z,R2
    00A6A 9180 02BB LDS	R24,k
    00A6C 9190 02BC LDS	R25,k+1
    00A6E 9601      ADIW	R24,1
    00A6F 9390 02BC STS	k+1,R25
    00A71 9380 02BB STS	k,R24
    00A73 9180 02BB LDS	R24,k
    00A75 9190 02BC LDS	R25,k+1
    00A77 3480      CPI	R24,0x40
    00A78 E0E0      LDI	R30,0
    00A79 079E      CPC	R25,R30
    00A7A F2E0      BCS	0x0A57
(0999) 						}		 
(1000) 						SendUart0_2(74,20);//超时160ms
    00A7B E124      LDI	R18,0x14
    00A7C E030      LDI	R19,0
    00A7D E40A      LDI	R16,0x4A
    00A7E DA6C      RCALL	_SendUart0_2
(1001) 						if(!((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x84)))
    00A7F 9180 02FA LDS	R24,Uart0RxCounter
    00A81 3089      CPI	R24,0x9
    00A82 F461      BNE	0x0A8F
    00A83 9180 02FB LDS	R24,Uart0RxData
    00A85 3585      CPI	R24,0x55
    00A86 F441      BNE	0x0A8F
    00A87 9180 02FC LDS	R24,Uart0RxData+1
    00A89 3480      CPI	R24,0x40
    00A8A F421      BNE	0x0A8F
    00A8B 9180 02FD LDS	R24,Uart0RxData+2
    00A8D 3884      CPI	R24,0x84
    00A8E F049      BEQ	0x0A98
(1002) 						{T_dat|=0x0004; }
    00A8F 9180 02E1 LDS	R24,T_dat
    00A91 9190 02E2 LDS	R25,T_dat+1
    00A93 6084      ORI	R24,4
    00A94 9390 02E2 STS	T_dat+1,R25
    00A96 9380 02E1 STS	T_dat,R24
(1003) 
(1004) 						Uart0TxData[0]=0xE8;
    00A98 EE88      LDI	R24,0xE8
    00A99 9380 012F STS	Uart0TxData,R24
(1005) 						Uart0TxData[1]=0x40;
    00A9B E480      LDI	R24,0x40
    00A9C 9380 0130 STS	Uart0TxData+1,R24
(1006) 						Uart0TxData[2]=0x84;
    00A9E E884      LDI	R24,0x84
    00A9F 9380 0131 STS	Uart0TxData+2,R24
(1007) 						Uart0TxData[3]=3;//包3
    00AA1 E083      LDI	R24,3
    00AA2 9380 0132 STS	Uart0TxData+3,R24
(1008) 						Uart0TxData[4]=0x21;
    00AA4 E281      LDI	R24,0x21
    00AA5 9380 0133 STS	Uart0TxData+4,R24
(1009) 						Uart0TxData[5]=0x22;
    00AA7 E282      LDI	R24,0x22
    00AA8 9380 0134 STS	Uart0TxData+5,R24
(1010) 						Uart0TxData[6]=0x23;
    00AAA E283      LDI	R24,0x23
    00AAB 9380 0135 STS	Uart0TxData+6,R24
(1011) 						Uart0TxData[7]=0x24;
    00AAD E284      LDI	R24,0x24
    00AAE 9380 0136 STS	Uart0TxData+7,R24
(1012) 						Uart0TxData[8]=0x32;	 
    00AB0 E382      LDI	R24,0x32
    00AB1 9380 0137 STS	Uart0TxData+8,R24
(1013) 						for(k=0;k<64;k++)
    00AB3 2422      CLR	R2
    00AB4 2433      CLR	R3
    00AB5 9230 02BC STS	k+1,R3
    00AB7 9220 02BB STS	k,R2
    00AB9 C01C      RJMP	0x0AD6
(1014) 						{
(1015) 							Uart0TxData[9+k]=coeffdata[k+192];  
    00ABA 90A0 02BB LDS	R10,k
    00ABC 90B0 02BC LDS	R11,k+1
    00ABE E789      LDI	R24,0x79
    00ABF E091      LDI	R25,1
    00AC0 01F5      MOVW	R30,R10
    00AC1 54E0      SUBI	R30,0x40
    00AC2 4FFF      SBCI	R31,0xFF
    00AC3 0FE8      ADD	R30,R24
    00AC4 1FF9      ADC	R31,R25
    00AC5 8020      LD	R2,Z
    00AC6 E28F      LDI	R24,0x2F
    00AC7 E091      LDI	R25,1
    00AC8 01F5      MOVW	R30,R10
    00AC9 9639      ADIW	R30,0x9
    00ACA 0FE8      ADD	R30,R24
    00ACB 1FF9      ADC	R31,R25
    00ACC 8220      ST	Z,R2
    00ACD 9180 02BB LDS	R24,k
    00ACF 9190 02BC LDS	R25,k+1
    00AD1 9601      ADIW	R24,1
    00AD2 9390 02BC STS	k+1,R25
    00AD4 9380 02BB STS	k,R24
    00AD6 9180 02BB LDS	R24,k
    00AD8 9190 02BC LDS	R25,k+1
    00ADA 3480      CPI	R24,0x40
    00ADB E0E0      LDI	R30,0
    00ADC 079E      CPC	R25,R30
    00ADD F2E0      BCS	0x0ABA
(1016) 						}		 
(1017) 						SendUart0_2(74,20);//超时160ms
    00ADE E124      LDI	R18,0x14
    00ADF E030      LDI	R19,0
    00AE0 E40A      LDI	R16,0x4A
    00AE1 DA09      RCALL	_SendUart0_2
(1018) 						if(!((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x84)))
    00AE2 9180 02FA LDS	R24,Uart0RxCounter
    00AE4 3089      CPI	R24,0x9
    00AE5 F461      BNE	0x0AF2
    00AE6 9180 02FB LDS	R24,Uart0RxData
    00AE8 3585      CPI	R24,0x55
    00AE9 F441      BNE	0x0AF2
    00AEA 9180 02FC LDS	R24,Uart0RxData+1
    00AEC 3480      CPI	R24,0x40
    00AED F421      BNE	0x0AF2
    00AEE 9180 02FD LDS	R24,Uart0RxData+2
    00AF0 3884      CPI	R24,0x84
    00AF1 F049      BEQ	0x0AFB
(1019) 						{T_dat|=0x0008; }
    00AF2 9180 02E1 LDS	R24,T_dat
    00AF4 9190 02E2 LDS	R25,T_dat+1
    00AF6 6088      ORI	R24,0x8
    00AF7 9390 02E2 STS	T_dat+1,R25
    00AF9 9380 02E1 STS	T_dat,R24
(1020) 
(1021) 						Uart0TxData[0]=0xE8;
    00AFB EE88      LDI	R24,0xE8
    00AFC 9380 012F STS	Uart0TxData,R24
(1022) 						Uart0TxData[1]=0x40;
    00AFE E480      LDI	R24,0x40
    00AFF 9380 0130 STS	Uart0TxData+1,R24
(1023) 						Uart0TxData[2]=0x84;
    00B01 E884      LDI	R24,0x84
    00B02 9380 0131 STS	Uart0TxData+2,R24
(1024) 						Uart0TxData[3]=4;//包4
    00B04 E084      LDI	R24,4
    00B05 9380 0132 STS	Uart0TxData+3,R24
(1025) 						Uart0TxData[4]=0x21;
    00B07 E281      LDI	R24,0x21
    00B08 9380 0133 STS	Uart0TxData+4,R24
(1026) 						Uart0TxData[5]=0x22;
    00B0A E282      LDI	R24,0x22
    00B0B 9380 0134 STS	Uart0TxData+5,R24
(1027) 						Uart0TxData[6]=0x23;
    00B0D E283      LDI	R24,0x23
    00B0E 9380 0135 STS	Uart0TxData+6,R24
(1028) 						Uart0TxData[7]=0x24;
    00B10 E284      LDI	R24,0x24
    00B11 9380 0136 STS	Uart0TxData+7,R24
(1029) 						Uart0TxData[8]=0x32;	 
    00B13 E382      LDI	R24,0x32
    00B14 9380 0137 STS	Uart0TxData+8,R24
(1030) 						for(k=0;k<64;k++)
    00B16 2422      CLR	R2
    00B17 2433      CLR	R3
    00B18 9230 02BC STS	k+1,R3
    00B1A 9220 02BB STS	k,R2
    00B1C C01C      RJMP	0x0B39
(1031) 						{
(1032) 							Uart0TxData[9+k]=coeffdata[k+256];  
    00B1D 90A0 02BB LDS	R10,k
    00B1F 90B0 02BC LDS	R11,k+1
    00B21 E789      LDI	R24,0x79
    00B22 E091      LDI	R25,1
    00B23 01F5      MOVW	R30,R10
    00B24 50E0      SUBI	R30,0
    00B25 4FFF      SBCI	R31,0xFF
    00B26 0FE8      ADD	R30,R24
    00B27 1FF9      ADC	R31,R25
    00B28 8020      LD	R2,Z
    00B29 E28F      LDI	R24,0x2F
    00B2A E091      LDI	R25,1
    00B2B 01F5      MOVW	R30,R10
    00B2C 9639      ADIW	R30,0x9
    00B2D 0FE8      ADD	R30,R24
    00B2E 1FF9      ADC	R31,R25
    00B2F 8220      ST	Z,R2
    00B30 9180 02BB LDS	R24,k
    00B32 9190 02BC LDS	R25,k+1
    00B34 9601      ADIW	R24,1
    00B35 9390 02BC STS	k+1,R25
    00B37 9380 02BB STS	k,R24
    00B39 9180 02BB LDS	R24,k
    00B3B 9190 02BC LDS	R25,k+1
    00B3D 3480      CPI	R24,0x40
    00B3E E0E0      LDI	R30,0
    00B3F 079E      CPC	R25,R30
    00B40 F2E0      BCS	0x0B1D
(1033) 						}		 
(1034) 						SendUart0_2(74,20);//超时160ms
    00B41 E124      LDI	R18,0x14
    00B42 E030      LDI	R19,0
    00B43 E40A      LDI	R16,0x4A
    00B44 D9A6      RCALL	_SendUart0_2
(1035) 						if(!((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x84)))
    00B45 9180 02FA LDS	R24,Uart0RxCounter
    00B47 3089      CPI	R24,0x9
    00B48 F461      BNE	0x0B55
    00B49 9180 02FB LDS	R24,Uart0RxData
    00B4B 3585      CPI	R24,0x55
    00B4C F441      BNE	0x0B55
    00B4D 9180 02FC LDS	R24,Uart0RxData+1
    00B4F 3480      CPI	R24,0x40
    00B50 F421      BNE	0x0B55
    00B51 9180 02FD LDS	R24,Uart0RxData+2
    00B53 3884      CPI	R24,0x84
    00B54 F049      BEQ	0x0B5E
(1036) 						{T_dat|=0x0010; }
    00B55 9180 02E1 LDS	R24,T_dat
    00B57 9190 02E2 LDS	R25,T_dat+1
    00B59 6180      ORI	R24,0x10
    00B5A 9390 02E2 STS	T_dat+1,R25
    00B5C 9380 02E1 STS	T_dat,R24
(1037) 
(1038) 						DataFlag=0;
    00B5E 2422      CLR	R2
    00B5F 2433      CLR	R3
    00B60 9230 02C2 STS	DataFlag+1,R3
    00B62 9220 02C1 STS	DataFlag,R2
(1039) 						coeff_len=0;	
    00B64 9230 012D STS	coeff_len+1,R3
    00B66 9220 012C STS	coeff_len,R2
(1040) 						T_com=0x0C;
    00B68 E08C      LDI	R24,0xC
    00B69 9380 02DA STS	T_com,R24
(1041) 						SendManchester();		
    00B6B 940E 1B86 CALL	_SendManchester
(1042) 					}     
(1043) 				}	 
(1044) 			}
    00B6D 940C 1B79 JMP	0x1B79
(1045) 
(1046) 			else//若不是下发标定系数，则进入以下各个命令的子语句
(1047) 			{ 
(1048) 				T_com=(R_dat>>4);
    00B6F 9020 02DF LDS	R2,R_dat
    00B71 9030 02E0 LDS	R3,R_dat+1
    00B73 9435      ASR	R3
    00B74 9427      ROR	R2
    00B75 9435      ASR	R3
    00B76 9427      ROR	R2
    00B77 9435      ASR	R3
    00B78 9427      ROR	R2
    00B79 9435      ASR	R3
    00B7A 9427      ROR	R2
    00B7B 9220 02DA STS	T_com,R2
(1049) 				switch(R_dat&0xf0)
    00B7D 9180 02DF LDS	R24,R_dat
    00B7F 9190 02E0 LDS	R25,R_dat+1
    00B81 7F80      ANDI	R24,0xF0
    00B82 7090      ANDI	R25,0
    00B83 015C      MOVW	R10,R24
    00B84 3780      CPI	R24,0x70
    00B85 E0E0      LDI	R30,0
    00B86 079E      CPC	R25,R30
    00B87 F409      BNE	0x0B89
    00B88 C457      RJMP	0x0FE0
    00B89 E780      LDI	R24,0x70
    00B8A E090      LDI	R25,0
    00B8B 158A      CP	R24,R10
    00B8C 059B      CPC	R25,R11
    00B8D F40C      BGE	0x0B8F
    00B8E C03A      RJMP	0x0BC9
    00B8F 01C5      MOVW	R24,R10
    00B90 3380      CPI	R24,0x30
    00B91 E0E0      LDI	R30,0
    00B92 079E      CPC	R25,R30
    00B93 F409      BNE	0x0B95
    00B94 C0F2      RJMP	0x0C87
    00B95 E380      LDI	R24,0x30
    00B96 E090      LDI	R25,0
    00B97 158A      CP	R24,R10
    00B98 059B      CPC	R25,R11
    00B99 F0A4      BLT	0x0BAE
    00B9A 01C5      MOVW	R24,R10
    00B9B 3180      CPI	R24,0x10
    00B9C E0E0      LDI	R30,0
    00B9D 079E      CPC	R25,R30
    00B9E F409      BNE	0x0BA0
    00B9F C066      RJMP	0x0C06
    00BA0 3180      CPI	R24,0x10
    00BA1 E0E0      LDI	R30,0
    00BA2 079E      CPC	R25,R30
    00BA3 F414      BGE	0x0BA6
    00BA4 940C 1B79 JMP	0x1B79
    00BA6 01C5      MOVW	R24,R10
    00BA7 3280      CPI	R24,0x20
    00BA8 E0E0      LDI	R30,0
    00BA9 079E      CPC	R25,R30
    00BAA F409      BNE	0x0BAC
    00BAB C099      RJMP	0x0C45
    00BAC 940C 1B79 JMP	0x1B79
    00BAE 01C5      MOVW	R24,R10
    00BAF 3580      CPI	R24,0x50
    00BB0 E0E0      LDI	R30,0
    00BB1 079E      CPC	R25,R30
    00BB2 F409      BNE	0x0BB4
    00BB3 C213      RJMP	0x0DC7
    00BB4 E580      LDI	R24,0x50
    00BB5 E090      LDI	R25,0
    00BB6 158A      CP	R24,R10
    00BB7 059B      CPC	R25,R11
    00BB8 F044      BLT	0x0BC1
    00BB9 01C5      MOVW	R24,R10
    00BBA 3480      CPI	R24,0x40
    00BBB E0E0      LDI	R30,0
    00BBC 079E      CPC	R25,R30
    00BBD F409      BNE	0x0BBF
    00BBE C12C      RJMP	0x0CEB
    00BBF 940C 1B79 JMP	0x1B79
    00BC1 01C5      MOVW	R24,R10
    00BC2 3680      CPI	R24,0x60
    00BC3 E0E0      LDI	R30,0
    00BC4 079E      CPC	R25,R30
    00BC5 F409      BNE	0x0BC7
    00BC6 C3E0      RJMP	0x0FA7
    00BC7 940C 1B79 JMP	0x1B79
    00BC9 01C5      MOVW	R24,R10
    00BCA 3A80      CPI	R24,0xA0
    00BCB E0E0      LDI	R30,0
    00BCC 079E      CPC	R25,R30
    00BCD F409      BNE	0x0BCF
    00BCE C7F1      RJMP	0x13C0
    00BCF EA80      LDI	R24,0xA0
    00BD0 E090      LDI	R25,0
    00BD1 158A      CP	R24,R10
    00BD2 059B      CPC	R25,R11
    00BD3 F0A4      BLT	0x0BE8
    00BD4 01C5      MOVW	R24,R10
    00BD5 3880      CPI	R24,0x80
    00BD6 E0E0      LDI	R30,0
    00BD7 079E      CPC	R25,R30
    00BD8 F409      BNE	0x0BDA
    00BD9 C440      RJMP	0x101A
    00BDA 3880      CPI	R24,0x80
    00BDB E0E0      LDI	R30,0
    00BDC 079E      CPC	R25,R30
    00BDD F414      BGE	0x0BE0
    00BDE 940C 1B79 JMP	0x1B79
    00BE0 01C5      MOVW	R24,R10
    00BE1 3980      CPI	R24,0x90
    00BE2 E0E0      LDI	R30,0
    00BE3 079E      CPC	R25,R30
    00BE4 F409      BNE	0x0BE6
    00BE5 C502      RJMP	0x10E8
    00BE6 940C 1B79 JMP	0x1B79
    00BE8 01C5      MOVW	R24,R10
    00BE9 3C80      CPI	R24,0xC0
    00BEA E0E0      LDI	R30,0
    00BEB 079E      CPC	R25,R30
    00BEC F411      BNE	0x0BEF
    00BED 940C 1624 JMP	0x1624
    00BEF EC80      LDI	R24,0xC0
    00BF0 E090      LDI	R25,0
    00BF1 158A      CP	R24,R10
    00BF2 059B      CPC	R25,R11
    00BF3 F04C      BLT	0x0BFD
    00BF4 01C5      MOVW	R24,R10
    00BF5 3B80      CPI	R24,0xB0
    00BF6 E0E0      LDI	R30,0
    00BF7 079E      CPC	R25,R30
    00BF8 F411      BNE	0x0BFB
    00BF9 940C 1488 JMP	0x1488
    00BFB 940C 1B79 JMP	0x1B79
    00BFD 01C5      MOVW	R24,R10
    00BFE 3D80      CPI	R24,0xD0
    00BFF E0E0      LDI	R30,0
    00C00 079E      CPC	R25,R30
    00C01 F411      BNE	0x0C04
    00C02 940C 1B48 JMP	0x1B48
    00C04 940C 1B79 JMP	0x1B79
(1050) 				{ 
(1051) 					case 0x10://复位 	
(1052) 						Uart0TxData[0]=0xE8;
    00C06 EE88      LDI	R24,0xE8
    00C07 9380 012F STS	Uart0TxData,R24
(1053) 						Uart0TxData[1]=0x40;
    00C09 E480      LDI	R24,0x40
    00C0A 9380 0130 STS	Uart0TxData+1,R24
(1054) 						Uart0TxData[2]=0x8D;//流量板握手，超时40ms
    00C0C E88D      LDI	R24,0x8D
    00C0D 9380 0131 STS	Uart0TxData+2,R24
(1055) 						Uart0TxData[3]=31;
    00C0F E18F      LDI	R24,0x1F
    00C10 9380 0132 STS	Uart0TxData+3,R24
(1056) 						SendUart0_2(9,5); 
    00C12 E025      LDI	R18,5
    00C13 E030      LDI	R19,0
    00C14 E009      LDI	R16,0x9
    00C15 D8D5      RCALL	_SendUart0_2
(1057) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x8D))
    00C16 9180 02FA LDS	R24,Uart0RxCounter
    00C18 3089      CPI	R24,0x9
    00C19 F499      BNE	0x0C2D
    00C1A 9180 02FB LDS	R24,Uart0RxData
    00C1C 3585      CPI	R24,0x55
    00C1D F479      BNE	0x0C2D
    00C1E 9180 02FC LDS	R24,Uart0RxData+1
    00C20 3480      CPI	R24,0x40
    00C21 F459      BNE	0x0C2D
    00C22 9180 02FD LDS	R24,Uart0RxData+2
    00C24 388D      CPI	R24,0x8D
    00C25 F439      BNE	0x0C2D
(1058) 						{T_dat=0x00;}
    00C26 2422      CLR	R2
    00C27 2433      CLR	R3
    00C28 9230 02E2 STS	T_dat+1,R3
    00C2A 9220 02E1 STS	T_dat,R2
    00C2C C006      RJMP	0x0C33
(1059) 						else
(1060) 						{T_dat=0xff;}
    00C2D EF8F      LDI	R24,0xFF
    00C2E E090      LDI	R25,0
    00C2F 9390 02E2 STS	T_dat+1,R25
    00C31 9380 02E1 STS	T_dat,R24
(1061) 						T_dat<<=8;
    00C33 9020 02E1 LDS	R2,T_dat
    00C35 9030 02E2 LDS	R3,T_dat+1
    00C37 2C32      MOV	R3,R2
    00C38 2422      CLR	R2
    00C39 9230 02E2 STS	T_dat+1,R3
    00C3B 9220 02E1 STS	T_dat,R2
(1062) 						T_dat|=0x00;
    00C3D 9230 02E2 STS	T_dat+1,R3
    00C3F 9220 02E1 STS	T_dat,R2
(1063) 						SendManchester();	
    00C41 940E 1B86 CALL	_SendManchester
(1064) 						break;
    00C43 940C 1B79 JMP	0x1B79
(1065) 
(1066) 					case 0x20://主控板与采集板版本号
(1067) 						Uart0TxData[0]=0xE8;
    00C45 EE88      LDI	R24,0xE8
    00C46 9380 012F STS	Uart0TxData,R24
(1068) 						Uart0TxData[1]=0x40;
    00C48 E480      LDI	R24,0x40
    00C49 9380 0130 STS	Uart0TxData+1,R24
(1069) 						Uart0TxData[2]=0x8D;//流量板握手，超时40ms
    00C4B E88D      LDI	R24,0x8D
    00C4C 9380 0131 STS	Uart0TxData+2,R24
(1070) 						Uart0TxData[3]=31;
    00C4E E18F      LDI	R24,0x1F
    00C4F 9380 0132 STS	Uart0TxData+3,R24
(1071) 						SendUart0_2(9,5); 
    00C51 E025      LDI	R18,5
    00C52 E030      LDI	R19,0
    00C53 E009      LDI	R16,0x9
    00C54 D896      RCALL	_SendUart0_2
(1072) 						if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x8D))
    00C55 9180 02FA LDS	R24,Uart0RxCounter
    00C57 3089      CPI	R24,0x9
    00C58 F4A1      BNE	0x0C6D
    00C59 9180 02FB LDS	R24,Uart0RxData
    00C5B 3585      CPI	R24,0x55
    00C5C F481      BNE	0x0C6D
    00C5D 9180 02FC LDS	R24,Uart0RxData+1
    00C5F 3480      CPI	R24,0x40
    00C60 F461      BNE	0x0C6D
    00C61 9180 02FD LDS	R24,Uart0RxData+2
    00C63 388D      CPI	R24,0x8D
    00C64 F441      BNE	0x0C6D
(1073) 							{T_dat=Uart0RxData[3];}
    00C65 9020 02FE LDS	R2,Uart0RxData+3
    00C67 2433      CLR	R3
    00C68 9230 02E2 STS	T_dat+1,R3
    00C6A 9220 02E1 STS	T_dat,R2
    00C6C C006      RJMP	0x0C73
(1074) 						else
(1075) 							{T_dat=0xff;}    
    00C6D EF8F      LDI	R24,0xFF
    00C6E E090      LDI	R25,0
    00C6F 9390 02E2 STS	T_dat+1,R25
    00C71 9380 02E1 STS	T_dat,R24
(1076) 						T_dat<<=8;
    00C73 9020 02E1 LDS	R2,T_dat
    00C75 9030 02E2 LDS	R3,T_dat+1
    00C77 2C32      MOV	R3,R2
    00C78 2422      CLR	R2
    00C79 9230 02E2 STS	T_dat+1,R3
    00C7B 9220 02E1 STS	T_dat,R2
(1077) 						T_dat|=BB;
    00C7D 01C1      MOVW	R24,R2
    00C7E 6181      ORI	R24,0x11
    00C7F 9390 02E2 STS	T_dat+1,R25
    00C81 9380 02E1 STS	T_dat,R24
(1078) 						SendManchester();				
    00C83 940E 1B86 CALL	_SendManchester
(1079) 						break;
    00C85 940C 1B79 JMP	0x1B79
(1080) 
(1081) 					case 0x30://Cable电压,电机电压
(1082) 						Delay_ms(30);   
    00C87 E10E      LDI	R16,0x1E
    00C88 E010      LDI	R17,0
    00C89 D96A      RCALL	_Delay_ms
(1083) 						f=SampleADC(0);//Cable 
    00C8A 2700      CLR	R16
    00C8B D8F9      RCALL	_SampleADC
    00C8C 2EA0      MOV	R10,R16
    00C8D 2711      CLR	R17
    00C8E 940E 20D9 CALL	int2fp
    00C90 830D      STD	Y+5,R16
    00C91 831E      STD	Y+6,R17
    00C92 832F      STD	Y+7,R18
    00C93 8738      STD	Y+8,R19
(1084) 						f=f*2.56;
    00C94 E904      LDI	R16,0x94
    00C95 E010      LDI	R17,0
    00C96 940E 202D CALL	elpm32
    00C98 01CE      MOVW	R24,R28
    00C99 9605      ADIW	R24,5
    00C9A 939A      ST	-Y,R25
    00C9B 938A      ST	-Y,R24
    00C9C 940E 2274 CALL	fpmule1
    00C9E 830D      STD	Y+5,R16
    00C9F 831E      STD	Y+6,R17
    00CA0 832F      STD	Y+7,R18
    00CA1 8738      STD	Y+8,R19
(1085) 						f=f*101;
    00CA2 E900      LDI	R16,0x90
    00CA3 E010      LDI	R17,0
    00CA4 940E 202D CALL	elpm32
    00CA6 01CE      MOVW	R24,R28
    00CA7 9605      ADIW	R24,5
    00CA8 939A      ST	-Y,R25
    00CA9 938A      ST	-Y,R24
    00CAA 940E 2274 CALL	fpmule1
    00CAC 830D      STD	Y+5,R16
    00CAD 831E      STD	Y+6,R17
    00CAE 832F      STD	Y+7,R18
    00CAF 8738      STD	Y+8,R19
(1086) 						f=f/256;
    00CB0 802D      LDD	R2,Y+5
    00CB1 803E      LDD	R3,Y+6
    00CB2 804F      LDD	R4,Y+7
    00CB3 8458      LDD	R5,Y+8
    00CB4 E80C      LDI	R16,0x8C
    00CB5 E010      LDI	R17,0
    00CB6 940E 202D CALL	elpm32
    00CB8 933A      ST	-Y,R19
    00CB9 932A      ST	-Y,R18
    00CBA 931A      ST	-Y,R17
    00CBB 930A      ST	-Y,R16
    00CBC 0181      MOVW	R16,R2
    00CBD 0192      MOVW	R18,R4
    00CBE 940E 2104 CALL	fpdiv2
    00CC0 830D      STD	Y+5,R16
    00CC1 831E      STD	Y+6,R17
    00CC2 832F      STD	Y+7,R18
    00CC3 8738      STD	Y+8,R19
(1087) 						T_dat=f;
    00CC4 810D      LDD	R16,Y+5
    00CC5 811E      LDD	R17,Y+6
    00CC6 812F      LDD	R18,Y+7
    00CC7 8538      LDD	R19,Y+8
    00CC8 940E 20A5 CALL	fpint
    00CCA 9310 02E2 STS	T_dat+1,R17
    00CCC 9300 02E1 STS	T_dat,R16
(1088) 						T_dat<<=8;  
    00CCE 0118      MOVW	R2,R16
    00CCF 2C32      MOV	R3,R2
    00CD0 2422      CLR	R2
    00CD1 9230 02E2 STS	T_dat+1,R3
    00CD3 9220 02E1 STS	T_dat,R2
(1089) 						
(1090) 						SendUart1(0x30,4);//读电机电压，32ms超时
    00CD5 E024      LDI	R18,4
    00CD6 E030      LDI	R19,0
    00CD7 E300      LDI	R16,0x30
    00CD8 940E 02B3 CALL	_SendUart1
(1091) 						T_dat|=Uart1RxData[0];
    00CDA 9020 02F6 LDS	R2,Uart1RxData
    00CDC 2433      CLR	R3
    00CDD 9040 02E1 LDS	R4,T_dat
    00CDF 9050 02E2 LDS	R5,T_dat+1
    00CE1 2842      OR	R4,R2
    00CE2 2853      OR	R5,R3
    00CE3 9250 02E2 STS	T_dat+1,R5
    00CE5 9240 02E1 STS	T_dat,R4
(1092) 
(1093) 						SendManchester();   
    00CE7 940E 1B86 CALL	_SendManchester
(1094) 						break;
    00CE9 940C 1B79 JMP	0x1B79
(1095) 
(1096) 					case 0x40: //采集板压力和温度
(1097) 					    if(R_dat==0x4f)// 采集第2个压力温度的数字量，再多发2帧共4字节
    00CEB 9180 02DF LDS	R24,R_dat
    00CED 9190 02E0 LDS	R25,R_dat+1
    00CEF 348F      CPI	R24,0x4F
    00CF0 E0E0      LDI	R30,0
    00CF1 079E      CPC	R25,R30
    00CF2 F529      BNE	0x0D18
(1098) 						{
(1099) 						  Delay_ms(30);//等总线稳定，否则会影响到内部总线，则第一个字节收不正常
    00CF3 E10E      LDI	R16,0x1E
    00CF4 E010      LDI	R17,0
    00CF5 D8FE      RCALL	_Delay_ms
(1100) 						  
(1101) 						  SampleTPS(R_dat);//最快5ms返回，没有挂压力短节时最多20ms返回
    00CF6 9100 02DF LDS	R16,R_dat
    00CF8 9110 02E0 LDS	R17,R_dat+1
    00CFA 940E 0455 CALL	_SampleTPS
(1102) 						  
(1103) 						  Delay_ms(30);	
    00CFC E10E      LDI	R16,0x1E
    00CFD E010      LDI	R17,0
    00CFE D8F5      RCALL	_Delay_ms
(1104) 						  T_dat=TPS_PData;
    00CFF 9020 02DD LDS	R2,TPS_PData
    00D01 9030 02DE LDS	R3,TPS_PData+1
    00D03 9230 02E2 STS	T_dat+1,R3
    00D05 9220 02E1 STS	T_dat,R2
(1105) 						  SendManchester();//压力2
    00D07 940E 1B86 CALL	_SendManchester
(1106) 						  
(1107) 						  Delay_ms(30);	
    00D09 E10E      LDI	R16,0x1E
    00D0A E010      LDI	R17,0
    00D0B D8E8      RCALL	_Delay_ms
(1108) 						  T_dat=TPS_TData;
    00D0C 9020 02DB LDS	R2,TPS_TData
    00D0E 9030 02DC LDS	R3,TPS_TData+1
    00D10 9230 02E2 STS	T_dat+1,R3
    00D12 9220 02E1 STS	T_dat,R2
(1109) 						  SendManchester();//温度2
    00D14 940E 1B86 CALL	_SendManchester
(1110) 						}
    00D16 940C 1B79 JMP	0x1B79
(1111) 						else//采集流量板上的压力温度
(1112) 						{
(1113) 						  Uart0TxData[0]=0xE8;
    00D18 EE88      LDI	R24,0xE8
    00D19 9380 012F STS	Uart0TxData,R24
(1114) 						  Uart0TxData[1]=0x40;
    00D1B E480      LDI	R24,0x40
    00D1C 9380 0130 STS	Uart0TxData+1,R24
(1115) 						  Uart0TxData[2]=0x89;
    00D1E E889      LDI	R24,0x89
    00D1F 9380 0131 STS	Uart0TxData+2,R24
(1116) 						  Uart0TxData[3]=9;
    00D21 E089      LDI	R24,0x9
    00D22 9380 0132 STS	Uart0TxData+3,R24
(1117) 						  SendUart0_2(9,50);//流量板直读检测，超时400ms
    00D24 E322      LDI	R18,0x32
    00D25 E030      LDI	R19,0
    00D26 E009      LDI	R16,0x9
    00D27 940E 04EB CALL	_SendUart0_2
(1118) 						  
(1119) 						 if((Uart0RxCounter==16)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x0c)&&(Uart0RxData[2]==0x89))//绝对时间差法流量板，严格按帧格式返回16字节（含12字节有效数据）
    00D29 9180 02FA LDS	R24,Uart0RxCounter
    00D2B 3180      CPI	R24,0x10
    00D2C F009      BEQ	0x0D2E
    00D2D C054      RJMP	0x0D82
    00D2E 9180 02FB LDS	R24,Uart0RxData
    00D30 3585      CPI	R24,0x55
    00D31 F009      BEQ	0x0D33
    00D32 C04F      RJMP	0x0D82
    00D33 9180 02FC LDS	R24,Uart0RxData+1
    00D35 308C      CPI	R24,0xC
    00D36 F009      BEQ	0x0D38
    00D37 C04A      RJMP	0x0D82
    00D38 9180 02FD LDS	R24,Uart0RxData+2
    00D3A 3889      CPI	R24,0x89
    00D3B F009      BEQ	0x0D3D
    00D3C C045      RJMP	0x0D82
(1120) 						 {
(1121) 						  T_dat=Uart0RxData[4];
    00D3D 9020 02FF LDS	R2,Uart0RxData+4
    00D3F 2433      CLR	R3
    00D40 9230 02E2 STS	T_dat+1,R3
    00D42 9220 02E1 STS	T_dat,R2
(1122) 						  T_dat<<=8;
    00D44 9020 02E1 LDS	R2,T_dat
    00D46 9030 02E2 LDS	R3,T_dat+1
    00D48 2C32      MOV	R3,R2
    00D49 2422      CLR	R2
    00D4A 9230 02E2 STS	T_dat+1,R3
    00D4C 9220 02E1 STS	T_dat,R2
(1123) 						  T_dat|=Uart0RxData[3];
    00D4E 9020 02FE LDS	R2,Uart0RxData+3
    00D50 2433      CLR	R3
    00D51 9040 02E1 LDS	R4,T_dat
    00D53 9050 02E2 LDS	R5,T_dat+1
    00D55 2842      OR	R4,R2
    00D56 2853      OR	R5,R3
    00D57 9250 02E2 STS	T_dat+1,R5
    00D59 9240 02E1 STS	T_dat,R4
(1124) 						  SendManchester();//压力
    00D5B 940E 1B86 CALL	_SendManchester
(1125) 
(1126) 						  Delay_ms(30);	
    00D5D E10E      LDI	R16,0x1E
    00D5E E010      LDI	R17,0
    00D5F D894      RCALL	_Delay_ms
(1127) 						  T_dat=Uart0RxData[6];
    00D60 9020 0301 LDS	R2,Uart0RxData+6
    00D62 2433      CLR	R3
    00D63 9230 02E2 STS	T_dat+1,R3
    00D65 9220 02E1 STS	T_dat,R2
(1128) 						  T_dat<<=8;
    00D67 9020 02E1 LDS	R2,T_dat
    00D69 9030 02E2 LDS	R3,T_dat+1
    00D6B 2C32      MOV	R3,R2
    00D6C 2422      CLR	R2
    00D6D 9230 02E2 STS	T_dat+1,R3
    00D6F 9220 02E1 STS	T_dat,R2
(1129) 						  T_dat|=Uart0RxData[5];
    00D71 9020 0300 LDS	R2,Uart0RxData+5
    00D73 2433      CLR	R3
    00D74 9040 02E1 LDS	R4,T_dat
    00D76 9050 02E2 LDS	R5,T_dat+1
    00D78 2842      OR	R4,R2
    00D79 2853      OR	R5,R3
    00D7A 9250 02E2 STS	T_dat+1,R5
    00D7C 9240 02E1 STS	T_dat,R4
(1130) 						  SendManchester();//温度
    00D7E 940E 1B86 CALL	_SendManchester
(1131) 						 }
    00D80 940C 1B79 JMP	0x1B79
(1132) 						 else//常规流量板
(1133) 						 {
(1134) 						  T_dat=Uart0RxData[1];
    00D82 9020 02FC LDS	R2,Uart0RxData+1
    00D84 2433      CLR	R3
    00D85 9230 02E2 STS	T_dat+1,R3
    00D87 9220 02E1 STS	T_dat,R2
(1135) 						  T_dat<<=8;
    00D89 9020 02E1 LDS	R2,T_dat
    00D8B 9030 02E2 LDS	R3,T_dat+1
    00D8D 2C32      MOV	R3,R2
    00D8E 2422      CLR	R2
    00D8F 9230 02E2 STS	T_dat+1,R3
    00D91 9220 02E1 STS	T_dat,R2
(1136) 						  T_dat|=Uart0RxData[0];
    00D93 9020 02FB LDS	R2,Uart0RxData
    00D95 2433      CLR	R3
    00D96 9040 02E1 LDS	R4,T_dat
    00D98 9050 02E2 LDS	R5,T_dat+1
    00D9A 2842      OR	R4,R2
    00D9B 2853      OR	R5,R3
    00D9C 9250 02E2 STS	T_dat+1,R5
    00D9E 9240 02E1 STS	T_dat,R4
(1137) 						  SendManchester();//压力
    00DA0 940E 1B86 CALL	_SendManchester
(1138) 
(1139) 						  Delay_ms(30);	
    00DA2 E10E      LDI	R16,0x1E
    00DA3 E010      LDI	R17,0
    00DA4 D84F      RCALL	_Delay_ms
(1140) 						  T_dat=Uart0RxData[3];
    00DA5 9020 02FE LDS	R2,Uart0RxData+3
    00DA7 2433      CLR	R3
    00DA8 9230 02E2 STS	T_dat+1,R3
    00DAA 9220 02E1 STS	T_dat,R2
(1141) 						  T_dat<<=8;
    00DAC 9020 02E1 LDS	R2,T_dat
    00DAE 9030 02E2 LDS	R3,T_dat+1
    00DB0 2C32      MOV	R3,R2
    00DB1 2422      CLR	R2
    00DB2 9230 02E2 STS	T_dat+1,R3
    00DB4 9220 02E1 STS	T_dat,R2
(1142) 						  T_dat|=Uart0RxData[2];
    00DB6 9020 02FD LDS	R2,Uart0RxData+2
    00DB8 2433      CLR	R3
    00DB9 9040 02E1 LDS	R4,T_dat
    00DBB 9050 02E2 LDS	R5,T_dat+1
    00DBD 2842      OR	R4,R2
    00DBE 2853      OR	R5,R3
    00DBF 9250 02E2 STS	T_dat+1,R5
    00DC1 9240 02E1 STS	T_dat,R4
(1143) 						  SendManchester();//温度
    00DC3 940E 1B86 CALL	_SendManchester
(1144) 						 }
(1145) 						}
(1146) 						
(1147) 						break;
    00DC5 940C 1B79 JMP	0x1B79
(1148) 
(1149) 					case 0x50://流量采样	    	          	  	   	  	 
(1150) 
(1151) 						Uart0TxData[0]=0xE8;
    00DC7 EE88      LDI	R24,0xE8
    00DC8 9380 012F STS	Uart0TxData,R24
(1152) 						Uart0TxData[1]=0x40;
    00DCA E480      LDI	R24,0x40
    00DCB 9380 0130 STS	Uart0TxData+1,R24
(1153) 						Uart0TxData[2]=0x89;
    00DCD E889      LDI	R24,0x89
    00DCE 9380 0131 STS	Uart0TxData+2,R24
(1154) 						Uart0TxData[3]=9;
    00DD0 E089      LDI	R24,0x9
    00DD1 9380 0132 STS	Uart0TxData+3,R24
(1155) 						SendUart0_2(9,50);//流量板直读检测，超时400ms
    00DD3 E322      LDI	R18,0x32
    00DD4 E030      LDI	R19,0
    00DD5 E009      LDI	R16,0x9
    00DD6 940E 04EB CALL	_SendUart0_2
(1156) 						
(1157) 						if((Uart0RxCounter==16)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x0c)&&(Uart0RxData[2]==0x89))//绝对时间差法流量板，严格按帧格式返回16字节（含12字节有效数据）
    00DD8 9180 02FA LDS	R24,Uart0RxCounter
    00DDA 3180      CPI	R24,0x10
    00DDB F009      BEQ	0x0DDD
    00DDC C094      RJMP	0x0E71
    00DDD 9180 02FB LDS	R24,Uart0RxData
    00DDF 3585      CPI	R24,0x55
    00DE0 F009      BEQ	0x0DE2
    00DE1 C08F      RJMP	0x0E71
    00DE2 9180 02FC LDS	R24,Uart0RxData+1
    00DE4 308C      CPI	R24,0xC
    00DE5 F009      BEQ	0x0DE7
    00DE6 C08A      RJMP	0x0E71
    00DE7 9180 02FD LDS	R24,Uart0RxData+2
    00DE9 3889      CPI	R24,0x89
    00DEA F009      BEQ	0x0DEC
    00DEB C085      RJMP	0x0E71
(1158) 						{
(1159) 						//顺流时间，浮点数
(1160) 						myFIB.b[0]=Uart0RxData[7];
    00DEC 9020 0302 LDS	R2,Uart0RxData+7
    00DEE 9220 0348 STS	myFIB,R2
(1161) 						myFIB.b[1]=Uart0RxData[8];
    00DF0 9020 0303 LDS	R2,Uart0RxData+8
    00DF2 9220 0349 STS	myFIB+1,R2
(1162) 						myFIB.b[2]=Uart0RxData[9];
    00DF4 9020 0304 LDS	R2,Uart0RxData+9
    00DF6 9220 034A STS	myFIB+2,R2
(1163) 						myFIB.b[3]=Uart0RxData[10];
    00DF8 9020 0305 LDS	R2,Uart0RxData+10
    00DFA 9220 034B STS	myFIB+3,R2
(1164) 						 
(1165) 						T_dat=myFIB.i[1];
    00DFC 9020 034A LDS	R2,myFIB+2
    00DFE 9030 034B LDS	R3,myFIB+3
    00E00 9230 02E2 STS	T_dat+1,R3
    00E02 9220 02E1 STS	T_dat,R2
(1166) 						SendManchester();//顺流时间
    00E04 940E 1B86 CALL	_SendManchester
(1167) 						crc16array[0]=(unsigned char)(T_dat);
    00E06 9020 02E1 LDS	R2,T_dat
    00E08 9030 02E2 LDS	R3,T_dat+1
    00E0A 9220 0100 STS	crc16array,R2
(1168) 						crc16array[1]=(unsigned char)(T_dat>>8);
    00E0C 2C23      MOV	R2,R3
    00E0D 2433      CLR	R3
    00E0E FC27      SBRC	R2,7
    00E0F 9430      COM	R3
    00E10 9220 0101 STS	crc16array+1,R2
(1169) 
(1170) 						Delay_ms(30);	
    00E12 E10E      LDI	R16,0x1E
    00E13 E010      LDI	R17,0
    00E14 940E 05F4 CALL	_Delay_ms
(1171) 						T_dat=myFIB.i[0];
    00E16 9020 0348 LDS	R2,myFIB
    00E18 9030 0349 LDS	R3,myFIB+1
    00E1A 9230 02E2 STS	T_dat+1,R3
    00E1C 9220 02E1 STS	T_dat,R2
(1172) 						SendManchester();//顺流时间
    00E1E 940E 1B86 CALL	_SendManchester
(1173) 						crc16array[2]=(unsigned char)(T_dat);
    00E20 9020 02E1 LDS	R2,T_dat
    00E22 9030 02E2 LDS	R3,T_dat+1
    00E24 9220 0102 STS	crc16array+2,R2
(1174) 						crc16array[3]=(unsigned char)(T_dat>>8);
    00E26 2C23      MOV	R2,R3
    00E27 2433      CLR	R3
    00E28 FC27      SBRC	R2,7
    00E29 9430      COM	R3
    00E2A 9220 0103 STS	crc16array+3,R2
(1175) 
(1176) 						Delay_ms(30);	
    00E2C E10E      LDI	R16,0x1E
    00E2D E010      LDI	R17,0
    00E2E 940E 05F4 CALL	_Delay_ms
(1177) 
(1178) 						//逆流时间，浮点数
(1179) 						myFIB.b[0]=Uart0RxData[11];
    00E30 9020 0306 LDS	R2,Uart0RxData+11
    00E32 9220 0348 STS	myFIB,R2
(1180) 						myFIB.b[1]=Uart0RxData[12];
    00E34 9020 0307 LDS	R2,Uart0RxData+12
    00E36 9220 0349 STS	myFIB+1,R2
(1181) 						myFIB.b[2]=Uart0RxData[13];
    00E38 9020 0308 LDS	R2,Uart0RxData+13
    00E3A 9220 034A STS	myFIB+2,R2
(1182) 						myFIB.b[3]=Uart0RxData[14];
    00E3C 9020 0309 LDS	R2,Uart0RxData+14
    00E3E 9220 034B STS	myFIB+3,R2
(1183) 
(1184) 						T_dat=myFIB.i[1];
    00E40 9020 034A LDS	R2,myFIB+2
    00E42 9030 034B LDS	R3,myFIB+3
    00E44 9230 02E2 STS	T_dat+1,R3
    00E46 9220 02E1 STS	T_dat,R2
(1185) 						SendManchester();//逆流时间
    00E48 940E 1B86 CALL	_SendManchester
(1186) 						crc16array[4]=(unsigned char)(T_dat);
    00E4A 9020 02E1 LDS	R2,T_dat
    00E4C 9030 02E2 LDS	R3,T_dat+1
    00E4E 9220 0104 STS	crc16array+4,R2
(1187) 						crc16array[5]=(unsigned char)(T_dat>>8);
    00E50 2C23      MOV	R2,R3
    00E51 2433      CLR	R3
    00E52 FC27      SBRC	R2,7
    00E53 9430      COM	R3
    00E54 9220 0105 STS	crc16array+5,R2
(1188) 
(1189) 
(1190) 						Delay_ms(30);	
    00E56 E10E      LDI	R16,0x1E
    00E57 E010      LDI	R17,0
    00E58 940E 05F4 CALL	_Delay_ms
(1191) 						T_dat=myFIB.i[0];
    00E5A 9020 0348 LDS	R2,myFIB
    00E5C 9030 0349 LDS	R3,myFIB+1
    00E5E 9230 02E2 STS	T_dat+1,R3
    00E60 9220 02E1 STS	T_dat,R2
(1192) 						SendManchester();//逆流时间
    00E62 940E 1B86 CALL	_SendManchester
(1193) 						crc16array[6]=(unsigned char)(T_dat);
    00E64 9020 02E1 LDS	R2,T_dat
    00E66 9030 02E2 LDS	R3,T_dat+1
    00E68 9220 0106 STS	crc16array+6,R2
(1194) 						crc16array[7]=(unsigned char)(T_dat>>8);
    00E6A 2C23      MOV	R2,R3
    00E6B 2433      CLR	R3
    00E6C FC27      SBRC	R2,7
    00E6D 9430      COM	R3
    00E6E 9220 0107 STS	crc16array+7,R2
(1195) 						}
    00E70 C10A      RJMP	0x0F7B
(1196) 						else // 常规流量采样
(1197) 						{
(1198) 						lfib=Uart0RxData[5];
    00E71 9020 0300 LDS	R2,Uart0RxData+5
    00E73 2433      CLR	R3
    00E74 2444      CLR	R4
    00E75 2455      CLR	R5
    00E76 9230 0123 STS	lfib+1,R3
    00E78 9220 0122 STS	lfib,R2
    00E7A 9250 0125 STS	lfib+3,R5
    00E7C 9240 0124 STS	lfib+2,R4
(1199) 						lfib<<=8;
    00E7E E088      LDI	R24,0x8
    00E7F E090      LDI	R25,0
    00E80 9120 0124 LDS	R18,lfib+2
    00E82 9130 0125 LDS	R19,lfib+3
    00E84 9100 0122 LDS	R16,lfib
    00E86 9110 0123 LDS	R17,lfib+1
    00E88 938A      ST	-Y,R24
    00E89 940E 2080 CALL	lsl32
    00E8B 9310 0123 STS	lfib+1,R17
    00E8D 9300 0122 STS	lfib,R16
    00E8F 9330 0125 STS	lfib+3,R19
    00E91 9320 0124 STS	lfib+2,R18
(1200) 						lfib|=Uart0RxData[4];
    00E93 9020 02FF LDS	R2,Uart0RxData+4
    00E95 2433      CLR	R3
    00E96 2444      CLR	R4
    00E97 2455      CLR	R5
    00E98 0138      MOVW	R6,R16
    00E99 0149      MOVW	R8,R18
    00E9A 2862      OR	R6,R2
    00E9B 2873      OR	R7,R3
    00E9C 2884      OR	R8,R4
    00E9D 2895      OR	R9,R5
    00E9E 9270 0123 STS	lfib+1,R7
    00EA0 9260 0122 STS	lfib,R6
    00EA2 9290 0125 STS	lfib+3,R9
    00EA4 9280 0124 STS	lfib+2,R8
(1201) 						lfib&=0x0000ffff;
    00EA6 EF4F      LDI	R20,0xFF
    00EA7 EF5F      LDI	R21,0xFF
    00EA8 E060      LDI	R22,0
    00EA9 E070      LDI	R23,0
    00EAA 0113      MOVW	R2,R6
    00EAB 0124      MOVW	R4,R8
    00EAC 2224      AND	R2,R20
    00EAD 2235      AND	R3,R21
    00EAE 2246      AND	R4,R22
    00EAF 2257      AND	R5,R23
    00EB0 9230 0123 STS	lfib+1,R3
    00EB2 9220 0122 STS	lfib,R2
    00EB4 9250 0125 STS	lfib+3,R5
    00EB6 9240 0124 STS	lfib+2,R4
(1202) 						myFIB.f=(unsigned long)lfib; 
    00EB8 0181      MOVW	R16,R2
    00EB9 0192      MOVW	R18,R4
    00EBA 940E 20E2 CALL	ulong2fp
    00EBC 9310 0349 STS	myFIB+1,R17
    00EBE 9300 0348 STS	myFIB,R16
    00EC0 9330 034B STS	myFIB+3,R19
    00EC2 9320 034A STS	myFIB+2,R18
(1203) 
(1204) 						T_dat=myFIB.i[1];
    00EC4 9020 034A LDS	R2,myFIB+2
    00EC6 9030 034B LDS	R3,myFIB+3
    00EC8 9230 02E2 STS	T_dat+1,R3
    00ECA 9220 02E1 STS	T_dat,R2
(1205) 						SendManchester();//流量-时间
    00ECC 940E 1B86 CALL	_SendManchester
(1206) 						crc16array[0]=(unsigned char)(T_dat);
    00ECE 9020 02E1 LDS	R2,T_dat
    00ED0 9030 02E2 LDS	R3,T_dat+1
    00ED2 9220 0100 STS	crc16array,R2
(1207) 						crc16array[1]=(unsigned char)(T_dat>>8);
    00ED4 2C23      MOV	R2,R3
    00ED5 2433      CLR	R3
    00ED6 FC27      SBRC	R2,7
    00ED7 9430      COM	R3
    00ED8 9220 0101 STS	crc16array+1,R2
(1208) 
(1209) 						Delay_ms(30);	
    00EDA E10E      LDI	R16,0x1E
    00EDB E010      LDI	R17,0
    00EDC 940E 05F4 CALL	_Delay_ms
(1210) 						T_dat=myFIB.i[0];
    00EDE 9020 0348 LDS	R2,myFIB
    00EE0 9030 0349 LDS	R3,myFIB+1
    00EE2 9230 02E2 STS	T_dat+1,R3
    00EE4 9220 02E1 STS	T_dat,R2
(1211) 						SendManchester();//流量-时间
    00EE6 940E 1B86 CALL	_SendManchester
(1212) 						crc16array[2]=(unsigned char)(T_dat);
    00EE8 9020 02E1 LDS	R2,T_dat
    00EEA 9030 02E2 LDS	R3,T_dat+1
    00EEC 9220 0102 STS	crc16array+2,R2
(1213) 						crc16array[3]=(unsigned char)(T_dat>>8);
    00EEE 2C23      MOV	R2,R3
    00EEF 2433      CLR	R3
    00EF0 FC27      SBRC	R2,7
    00EF1 9430      COM	R3
    00EF2 9220 0103 STS	crc16array+3,R2
(1214) 
(1215) 						Delay_ms(30);	
    00EF4 E10E      LDI	R16,0x1E
    00EF5 E010      LDI	R17,0
    00EF6 940E 05F4 CALL	_Delay_ms
(1216) 
(1217) 						lfib=Uart0RxData[7];
    00EF8 9020 0302 LDS	R2,Uart0RxData+7
    00EFA 2433      CLR	R3
    00EFB 2444      CLR	R4
    00EFC 2455      CLR	R5
    00EFD 9230 0123 STS	lfib+1,R3
    00EFF 9220 0122 STS	lfib,R2
    00F01 9250 0125 STS	lfib+3,R5
    00F03 9240 0124 STS	lfib+2,R4
(1218) 						lfib<<=8;
    00F05 E088      LDI	R24,0x8
    00F06 E090      LDI	R25,0
    00F07 9120 0124 LDS	R18,lfib+2
    00F09 9130 0125 LDS	R19,lfib+3
    00F0B 9100 0122 LDS	R16,lfib
    00F0D 9110 0123 LDS	R17,lfib+1
    00F0F 938A      ST	-Y,R24
    00F10 940E 2080 CALL	lsl32
    00F12 9310 0123 STS	lfib+1,R17
    00F14 9300 0122 STS	lfib,R16
    00F16 9330 0125 STS	lfib+3,R19
    00F18 9320 0124 STS	lfib+2,R18
(1219) 						lfib|=Uart0RxData[6];
    00F1A 9020 0301 LDS	R2,Uart0RxData+6
    00F1C 2433      CLR	R3
    00F1D 2444      CLR	R4
    00F1E 2455      CLR	R5
    00F1F 0138      MOVW	R6,R16
    00F20 0149      MOVW	R8,R18
    00F21 2862      OR	R6,R2
    00F22 2873      OR	R7,R3
    00F23 2884      OR	R8,R4
    00F24 2895      OR	R9,R5
    00F25 9270 0123 STS	lfib+1,R7
    00F27 9260 0122 STS	lfib,R6
    00F29 9290 0125 STS	lfib+3,R9
    00F2B 9280 0124 STS	lfib+2,R8
(1220) 						lfib&=0x0000ffff;
    00F2D EF4F      LDI	R20,0xFF
    00F2E EF5F      LDI	R21,0xFF
    00F2F E060      LDI	R22,0
    00F30 E070      LDI	R23,0
    00F31 0113      MOVW	R2,R6
    00F32 0124      MOVW	R4,R8
    00F33 2224      AND	R2,R20
    00F34 2235      AND	R3,R21
    00F35 2246      AND	R4,R22
    00F36 2257      AND	R5,R23
    00F37 9230 0123 STS	lfib+1,R3
    00F39 9220 0122 STS	lfib,R2
    00F3B 9250 0125 STS	lfib+3,R5
    00F3D 9240 0124 STS	lfib+2,R4
(1221) 						myFIB.f=(unsigned long)lfib; 
    00F3F 0181      MOVW	R16,R2
    00F40 0192      MOVW	R18,R4
    00F41 940E 20E2 CALL	ulong2fp
    00F43 9310 0349 STS	myFIB+1,R17
    00F45 9300 0348 STS	myFIB,R16
    00F47 9330 034B STS	myFIB+3,R19
    00F49 9320 034A STS	myFIB+2,R18
(1222) 
(1223) 						T_dat=myFIB.i[1];
    00F4B 9020 034A LDS	R2,myFIB+2
    00F4D 9030 034B LDS	R3,myFIB+3
    00F4F 9230 02E2 STS	T_dat+1,R3
    00F51 9220 02E1 STS	T_dat,R2
(1224) 						SendManchester();//流量-相位1
    00F53 940E 1B86 CALL	_SendManchester
(1225) 						crc16array[4]=(unsigned char)(T_dat);
    00F55 9020 02E1 LDS	R2,T_dat
    00F57 9030 02E2 LDS	R3,T_dat+1
    00F59 9220 0104 STS	crc16array+4,R2
(1226) 						crc16array[5]=(unsigned char)(T_dat>>8);
    00F5B 2C23      MOV	R2,R3
    00F5C 2433      CLR	R3
    00F5D FC27      SBRC	R2,7
    00F5E 9430      COM	R3
    00F5F 9220 0105 STS	crc16array+5,R2
(1227) 
(1228) 
(1229) 						Delay_ms(30);	
    00F61 E10E      LDI	R16,0x1E
    00F62 E010      LDI	R17,0
    00F63 940E 05F4 CALL	_Delay_ms
(1230) 						T_dat=myFIB.i[0];
    00F65 9020 0348 LDS	R2,myFIB
    00F67 9030 0349 LDS	R3,myFIB+1
    00F69 9230 02E2 STS	T_dat+1,R3
    00F6B 9220 02E1 STS	T_dat,R2
(1231) 						SendManchester();//流量-相位2
    00F6D 940E 1B86 CALL	_SendManchester
(1232) 						crc16array[6]=(unsigned char)(T_dat);
    00F6F 9020 02E1 LDS	R2,T_dat
    00F71 9030 02E2 LDS	R3,T_dat+1
    00F73 9220 0106 STS	crc16array+6,R2
(1233) 						crc16array[7]=(unsigned char)(T_dat>>8);
    00F75 2C23      MOV	R2,R3
    00F76 2433      CLR	R3
    00F77 FC27      SBRC	R2,7
    00F78 9430      COM	R3
    00F79 9220 0107 STS	crc16array+7,R2
(1234) 						}
(1235) 
(1236) 						Delay_ms(30);	
    00F7B E10E      LDI	R16,0x1E
    00F7C E010      LDI	R17,0
    00F7D 940E 05F4 CALL	_Delay_ms
(1237) 						crc16(crc16array,8);//0.75ms
    00F7F E028      LDI	R18,0x8
    00F80 E030      LDI	R19,0
    00F81 E000      LDI	R16,0
    00F82 E011      LDI	R17,1
    00F83 940E 1FCE CALL	_crc16
(1238) 						T_dat=crc16hi;
    00F85 9020 0121 LDS	R2,crc16hi
    00F87 2433      CLR	R3
    00F88 9230 02E2 STS	T_dat+1,R3
    00F8A 9220 02E1 STS	T_dat,R2
(1239) 						T_dat<<=8;
    00F8C 9020 02E1 LDS	R2,T_dat
    00F8E 9030 02E2 LDS	R3,T_dat+1
    00F90 2C32      MOV	R3,R2
    00F91 2422      CLR	R2
    00F92 9230 02E2 STS	T_dat+1,R3
    00F94 9220 02E1 STS	T_dat,R2
(1240) 						T_dat|=crc16lo;	  
    00F96 9020 0120 LDS	R2,crc16lo
    00F98 2433      CLR	R3
    00F99 9040 02E1 LDS	R4,T_dat
    00F9B 9050 02E2 LDS	R5,T_dat+1
    00F9D 2842      OR	R4,R2
    00F9E 2853      OR	R5,R3
    00F9F 9250 02E2 STS	T_dat+1,R5
    00FA1 9240 02E1 STS	T_dat,R4
(1241) 						SendManchester();//上传CRC校验共2字节
    00FA3 940E 1B86 CALL	_SendManchester
(1242) 						break;
    00FA5 940C 1B79 JMP	0x1B79
(1243) 					
(1244) 					//收放电机 
(1245) 					case 0x60:  
(1246) 						if( !(((R_dat)==0x61)  || ((R_dat)==0x62) ) )//既不是正转，也不是反转，则立即返回且不响应上位机
    00FA7 90A0 02DF LDS	R10,R_dat
    00FA9 90B0 02E0 LDS	R11,R_dat+1
    00FAB 01C5      MOVW	R24,R10
    00FAC 3681      CPI	R24,0x61
    00FAD E0E0      LDI	R30,0
    00FAE 079E      CPC	R25,R30
    00FAF F031      BEQ	0x0FB6
    00FB0 3682      CPI	R24,0x62
    00FB1 E0E0      LDI	R30,0
    00FB2 079E      CPC	R25,R30
    00FB3 F011      BEQ	0x0FB6
(1247) 							break;
    00FB4 940C 1B79 JMP	0x1B79
(1248) 
(1249) 					    SendUart1(R_dat,200);//1600ms超时
    00FB6 EC28      LDI	R18,0xC8
    00FB7 E030      LDI	R19,0
    00FB8 9100 02DF LDS	R16,R_dat
    00FBA 9110 02E0 LDS	R17,R_dat+1
    00FBC 940E 02B3 CALL	_SendUart1
(1250) 						T_dat=Uart1RxData[1];
    00FBE 9020 02F7 LDS	R2,Uart1RxData+1
    00FC0 2433      CLR	R3
    00FC1 9230 02E2 STS	T_dat+1,R3
    00FC3 9220 02E1 STS	T_dat,R2
(1251) 						T_dat<<=8;
    00FC5 9020 02E1 LDS	R2,T_dat
    00FC7 9030 02E2 LDS	R3,T_dat+1
    00FC9 2C32      MOV	R3,R2
    00FCA 2422      CLR	R2
    00FCB 9230 02E2 STS	T_dat+1,R3
    00FCD 9220 02E1 STS	T_dat,R2
(1252) 						T_dat|=Uart1RxData[0];//返回电机状态
    00FCF 9020 02F6 LDS	R2,Uart1RxData
    00FD1 2433      CLR	R3
    00FD2 9040 02E1 LDS	R4,T_dat
    00FD4 9050 02E2 LDS	R5,T_dat+1
    00FD6 2842      OR	R4,R2
    00FD7 2853      OR	R5,R3
    00FD8 9250 02E2 STS	T_dat+1,R5
    00FDA 9240 02E1 STS	T_dat,R4
(1253) 						SendManchester();	 
    00FDC 940E 1B86 CALL	_SendManchester
(1254) 
(1255) 						break;
    00FDE 940C 1B79 JMP	0x1B79
(1256) 
(1257) 					case 0x70://调节电机   
(1258) 						if( ((R_dat)<0x71)  || ((R_dat)>0x7c)  )//既不是调大，也不是调小，也不微调大，也不是微调小，则立即返回且不响应上位机
    00FE0 90A0 02DF LDS	R10,R_dat
    00FE2 90B0 02E0 LDS	R11,R_dat+1
    00FE4 01C5      MOVW	R24,R10
    00FE5 3781      CPI	R24,0x71
    00FE6 E0E0      LDI	R30,0
    00FE7 079E      CPC	R25,R30
    00FE8 F02C      BLT	0x0FEE
    00FE9 E78C      LDI	R24,0x7C
    00FEA E090      LDI	R25,0
    00FEB 158A      CP	R24,R10
    00FEC 059B      CPC	R25,R11
    00FED F414      BGE	0x0FF0
(1259) 						break;
    00FEE 940C 1B79 JMP	0x1B79
(1260) 
(1261) 				        SendUart1(R_dat,200);//1600ms超时
    00FF0 EC28      LDI	R18,0xC8
    00FF1 E030      LDI	R19,0
    00FF2 9100 02DF LDS	R16,R_dat
    00FF4 9110 02E0 LDS	R17,R_dat+1
    00FF6 940E 02B3 CALL	_SendUart1
(1262) 						T_dat=Uart1RxData[1];
    00FF8 9020 02F7 LDS	R2,Uart1RxData+1
    00FFA 2433      CLR	R3
    00FFB 9230 02E2 STS	T_dat+1,R3
    00FFD 9220 02E1 STS	T_dat,R2
(1263) 						T_dat<<=8;
    00FFF 9020 02E1 LDS	R2,T_dat
    01001 9030 02E2 LDS	R3,T_dat+1
    01003 2C32      MOV	R3,R2
    01004 2422      CLR	R2
    01005 9230 02E2 STS	T_dat+1,R3
    01007 9220 02E1 STS	T_dat,R2
(1264) 						T_dat|=Uart1RxData[0];
    01009 9020 02F6 LDS	R2,Uart1RxData
    0100B 2433      CLR	R3
    0100C 9040 02E1 LDS	R4,T_dat
    0100E 9050 02E2 LDS	R5,T_dat+1
    01010 2842      OR	R4,R2
    01011 2853      OR	R5,R3
    01012 9250 02E2 STS	T_dat+1,R5
    01014 9240 02E1 STS	T_dat,R4
(1265) 						SendManchester();	 
    01016 940E 1B86 CALL	_SendManchester
(1266) 						break;
    01018 940C 1B79 JMP	0x1B79
(1267) 
(1268) 					case 0x80://电机相关
(1269) 						if(R_dat==0x80)//只开电机电源，不开电机
    0101A 9180 02DF LDS	R24,R_dat
    0101C 9190 02E0 LDS	R25,R_dat+1
    0101E 3880      CPI	R24,0x80
    0101F E0E0      LDI	R30,0
    01020 079E      CPC	R25,R30
    01021 F481      BNE	0x1032
(1270) 						{        	  
(1271) 							SendUart1(0x80,4);//32ms超时
    01022 E024      LDI	R18,4
    01023 E030      LDI	R19,0
    01024 E800      LDI	R16,0x80
    01025 940E 02B3 CALL	_SendUart1
(1272) 						    T_dat=Uart1RxData[0];
    01027 9020 02F6 LDS	R2,Uart1RxData
    01029 2433      CLR	R3
    0102A 9230 02E2 STS	T_dat+1,R3
    0102C 9220 02E1 STS	T_dat,R2
(1273) 							SendManchester();
    0102E 940E 1B86 CALL	_SendManchester
(1274) 						}	  
    01030 940C 1B79 JMP	0x1B79
(1275) 						else if(R_dat==0x81)//获取电机状态	
    01032 9180 02DF LDS	R24,R_dat
    01034 9190 02E0 LDS	R25,R_dat+1
    01036 3881      CPI	R24,0x81
    01037 E0E0      LDI	R30,0
    01038 079E      CPC	R25,R30
    01039 F009      BEQ	0x103B
    0103A C04B      RJMP	0x1086
(1276) 						{ 
(1277) 						    SendUart1(0x81,4);//32ms超时
    0103B E024      LDI	R18,4
    0103C E030      LDI	R19,0
    0103D E801      LDI	R16,0x81
    0103E 940E 02B3 CALL	_SendUart1
(1278) 						
(1279) 							//先处理收放电机
(1280) 							T_dat=Uart1RxData[1];
    01040 9020 02F7 LDS	R2,Uart1RxData+1
    01042 2433      CLR	R3
    01043 9230 02E2 STS	T_dat+1,R3
    01045 9220 02E1 STS	T_dat,R2
(1281) 						    T_dat<<=8;
    01047 9020 02E1 LDS	R2,T_dat
    01049 9030 02E2 LDS	R3,T_dat+1
    0104B 2C32      MOV	R3,R2
    0104C 2422      CLR	R2
    0104D 9230 02E2 STS	T_dat+1,R3
    0104F 9220 02E1 STS	T_dat,R2
(1282) 						    T_dat|=Uart1RxData[0];
    01051 9020 02F6 LDS	R2,Uart1RxData
    01053 2433      CLR	R3
    01054 9040 02E1 LDS	R4,T_dat
    01056 9050 02E2 LDS	R5,T_dat+1
    01058 2842      OR	R4,R2
    01059 2853      OR	R5,R3
    0105A 9250 02E2 STS	T_dat+1,R5
    0105C 9240 02E1 STS	T_dat,R4
(1283) 							SendManchester();
    0105E 940E 1B86 CALL	_SendManchester
(1284) 
(1285) 							//再处理调节电机 
(1286) 							Delay_ms(30);//延迟10ms  
    01060 E10E      LDI	R16,0x1E
    01061 E010      LDI	R17,0
    01062 940E 05F4 CALL	_Delay_ms
(1287) 							T_dat=Uart1RxData[3];
    01064 9020 02F9 LDS	R2,Uart1RxData+3
    01066 2433      CLR	R3
    01067 9230 02E2 STS	T_dat+1,R3
    01069 9220 02E1 STS	T_dat,R2
(1288) 						    T_dat<<=8;
    0106B 9020 02E1 LDS	R2,T_dat
    0106D 9030 02E2 LDS	R3,T_dat+1
    0106F 2C32      MOV	R3,R2
    01070 2422      CLR	R2
    01071 9230 02E2 STS	T_dat+1,R3
    01073 9220 02E1 STS	T_dat,R2
(1289) 						    T_dat|=Uart1RxData[2];
    01075 9020 02F8 LDS	R2,Uart1RxData+2
    01077 2433      CLR	R3
    01078 9040 02E1 LDS	R4,T_dat
    0107A 9050 02E2 LDS	R5,T_dat+1
    0107C 2842      OR	R4,R2
    0107D 2853      OR	R5,R3
    0107E 9250 02E2 STS	T_dat+1,R5
    01080 9240 02E1 STS	T_dat,R4
(1290) 							SendManchester();
    01082 940E 1B86 CALL	_SendManchester
(1291) 						}	  
    01084 940C 1B79 JMP	0x1B79
(1292) 						else if(R_dat==0x82)//电机停止，同时停止二个电机
    01086 9180 02DF LDS	R24,R_dat
    01088 9190 02E0 LDS	R25,R_dat+1
    0108A 3882      CPI	R24,0x82
    0108B E0E0      LDI	R30,0
    0108C 079E      CPC	R25,R30
    0108D F481      BNE	0x109E
(1293) 						{	 
(1294) 							SendUart1(0x82,30);//240ms超时
    0108E E12E      LDI	R18,0x1E
    0108F E030      LDI	R19,0
    01090 E802      LDI	R16,0x82
    01091 940E 02B3 CALL	_SendUart1
(1295) 						    T_dat=Uart1RxData[0];
    01093 9020 02F6 LDS	R2,Uart1RxData
    01095 2433      CLR	R3
    01096 9230 02E2 STS	T_dat+1,R3
    01098 9220 02E1 STS	T_dat,R2
(1296) 							SendManchester(); 
    0109A 940E 1B86 CALL	_SendManchester
(1297) 						}
    0109C 940C 1B79 JMP	0x1B79
(1298) 						else if(R_dat==0x83)//读取电机堵转电流档位和断路档位
    0109E 9180 02DF LDS	R24,R_dat
    010A0 9190 02E0 LDS	R25,R_dat+1
    010A2 3883      CPI	R24,0x83
    010A3 E0E0      LDI	R30,0
    010A4 079E      CPC	R25,R30
    010A5 F539      BNE	0x10CD
(1299) 						{
(1300) 							SendUart1(0x83,4);//32ms超时
    010A6 E024      LDI	R18,4
    010A7 E030      LDI	R19,0
    010A8 E803      LDI	R16,0x83
    010A9 940E 02B3 CALL	_SendUart1
(1301) 							T_dat=Uart1RxData[1];
    010AB 9020 02F7 LDS	R2,Uart1RxData+1
    010AD 2433      CLR	R3
    010AE 9230 02E2 STS	T_dat+1,R3
    010B0 9220 02E1 STS	T_dat,R2
(1302) 						    T_dat<<=8;
    010B2 9020 02E1 LDS	R2,T_dat
    010B4 9030 02E2 LDS	R3,T_dat+1
    010B6 2C32      MOV	R3,R2
    010B7 2422      CLR	R2
    010B8 9230 02E2 STS	T_dat+1,R3
    010BA 9220 02E1 STS	T_dat,R2
(1303) 						    T_dat|=Uart1RxData[0];
    010BC 9020 02F6 LDS	R2,Uart1RxData
    010BE 2433      CLR	R3
    010BF 9040 02E1 LDS	R4,T_dat
    010C1 9050 02E2 LDS	R5,T_dat+1
    010C3 2842      OR	R4,R2
    010C4 2853      OR	R5,R3
    010C5 9250 02E2 STS	T_dat+1,R5
    010C7 9240 02E1 STS	T_dat,R4
(1304) 							SendManchester();
    010C9 940E 1B86 CALL	_SendManchester
(1305) 						}	
    010CB 940C 1B79 JMP	0x1B79
(1306) 						else if(R_dat>0x83)//还剩12档，用于设置电机堵转电流, 收放电机和调节电机各6档
    010CD E883      LDI	R24,0x83
    010CE E090      LDI	R25,0
    010CF 9020 02DF LDS	R2,R_dat
    010D1 9030 02E0 LDS	R3,R_dat+1
    010D3 1582      CP	R24,R2
    010D4 0593      CPC	R25,R3
    010D5 F014      BLT	0x10D8
    010D6 940C 1B79 JMP	0x1B79
(1307) 						{
(1308) 							SendUart1(R_dat,4);//32ms超时
    010D8 E024      LDI	R18,4
    010D9 E030      LDI	R19,0
    010DA 0181      MOVW	R16,R2
    010DB 940E 02B3 CALL	_SendUart1
(1309) 						    T_dat=Uart1RxData[0];
    010DD 9020 02F6 LDS	R2,Uart1RxData
    010DF 2433      CLR	R3
    010E0 9230 02E2 STS	T_dat+1,R3
    010E2 9220 02E1 STS	T_dat,R2
(1310) 							SendManchester();
    010E4 940E 1B86 CALL	_SendManchester
(1311) 						}	  
(1312) 						break;
    010E6 940C 1B79 JMP	0x1B79
(1313) 
(1314) 
(1315) 
(1316) 					case 0x90: //标定数据
(1317) 						if(R_dat==0x90)//提取测试信息
    010E8 9180 02DF LDS	R24,R_dat
    010EA 9190 02E0 LDS	R25,R_dat+1
    010EC 3980      CPI	R24,0x90
    010ED E0E0      LDI	R30,0
    010EE 079E      CPC	R25,R30
    010EF F009      BEQ	0x10F1
    010F0 C116      RJMP	0x1207
(1318) 						{
(1319) 							Uart0TxData[0]=0xE8;
    010F1 EE88      LDI	R24,0xE8
    010F2 9380 012F STS	Uart0TxData,R24
(1320) 							Uart0TxData[1]=0x40;
    010F4 E480      LDI	R24,0x40
    010F5 9380 0130 STS	Uart0TxData+1,R24
(1321) 							Uart0TxData[2]=0xc8;
    010F7 EC88      LDI	R24,0xC8
    010F8 9380 0131 STS	Uart0TxData+2,R24
(1322) 							Uart0TxData[3]=0;//测试信息包0
    010FA 2422      CLR	R2
    010FB 9220 0132 STS	Uart0TxData+3,R2
(1323) 							SendUart0_2(9,4);// 超时32ms	 
    010FD E024      LDI	R18,4
    010FE E030      LDI	R19,0
    010FF E009      LDI	R16,0x9
    01100 940E 04EB CALL	_SendUart0_2
(1324) 							for(i=0;i<32;i++)
    01102 24AA      CLR	R10
    01103 C02F      RJMP	0x1133
(1325) 							{
(1326) 								Delay_ms(20);
    01104 E104      LDI	R16,0x14
    01105 E010      LDI	R17,0
    01106 940E 05F4 CALL	_Delay_ms
(1327) 								T_dat=Uart0RxData[i*2+1];//高字节
    01108 EF8C      LDI	R24,0xFC
    01109 E092      LDI	R25,2
    0110A 2DEA      MOV	R30,R10
    0110B 27FF      CLR	R31
    0110C 0FEE      LSL	R30
    0110D 1FFF      ROL	R31
    0110E 0FE8      ADD	R30,R24
    0110F 1FF9      ADC	R31,R25
    01110 8020      LD	R2,Z
    01111 2433      CLR	R3
    01112 9230 02E2 STS	T_dat+1,R3
    01114 9220 02E1 STS	T_dat,R2
(1328) 								T_dat<<=8;
    01116 2C32      MOV	R3,R2
    01117 2422      CLR	R2
    01118 9230 02E2 STS	T_dat+1,R3
    0111A 9220 02E1 STS	T_dat,R2
(1329) 								T_dat|=Uart0RxData[i*2+0];//低字节
    0111C EF8B      LDI	R24,0xFB
    0111D E092      LDI	R25,2
    0111E 2DEA      MOV	R30,R10
    0111F 27FF      CLR	R31
    01120 0FEE      LSL	R30
    01121 1FFF      ROL	R31
    01122 0FE8      ADD	R30,R24
    01123 1FF9      ADC	R31,R25
    01124 8020      LD	R2,Z
    01125 2433      CLR	R3
    01126 9040 02E1 LDS	R4,T_dat
    01128 9050 02E2 LDS	R5,T_dat+1
    0112A 2842      OR	R4,R2
    0112B 2853      OR	R5,R3
    0112C 9250 02E2 STS	T_dat+1,R5
    0112E 9240 02E1 STS	T_dat,R4
(1330) 								SendManchester();		 
    01130 940E 1B86 CALL	_SendManchester
    01132 94A3      INC	R10
    01133 2D8A      MOV	R24,R10
    01134 3280      CPI	R24,0x20
    01135 F270      BCS	0x1104
(1331) 							}		
(1332) 
(1333) 							Uart0TxData[0]=0xE8;
    01136 EE88      LDI	R24,0xE8
    01137 9380 012F STS	Uart0TxData,R24
(1334) 							Uart0TxData[1]=0x40;
    01139 E480      LDI	R24,0x40
    0113A 9380 0130 STS	Uart0TxData+1,R24
(1335) 							Uart0TxData[2]=0xc8;
    0113C EC88      LDI	R24,0xC8
    0113D 9380 0131 STS	Uart0TxData+2,R24
(1336) 							Uart0TxData[3]=1;//测试信息包1
    0113F E081      LDI	R24,1
    01140 9380 0132 STS	Uart0TxData+3,R24
(1337) 							SendUart0_2(9,4);// 超时32ms	 
    01142 E024      LDI	R18,4
    01143 E030      LDI	R19,0
    01144 E009      LDI	R16,0x9
    01145 940E 04EB CALL	_SendUart0_2
(1338) 							for(i=0;i<32;i++)
    01147 24AA      CLR	R10
    01148 C02F      RJMP	0x1178
(1339) 							{
(1340) 								T_dat=Uart0RxData[i*2+1];//高字节
    01149 EF8C      LDI	R24,0xFC
    0114A E092      LDI	R25,2
    0114B 2DEA      MOV	R30,R10
    0114C 27FF      CLR	R31
    0114D 0FEE      LSL	R30
    0114E 1FFF      ROL	R31
    0114F 0FE8      ADD	R30,R24
    01150 1FF9      ADC	R31,R25
    01151 8020      LD	R2,Z
    01152 2433      CLR	R3
    01153 9230 02E2 STS	T_dat+1,R3
    01155 9220 02E1 STS	T_dat,R2
(1341) 								T_dat<<=8;
    01157 2C32      MOV	R3,R2
    01158 2422      CLR	R2
    01159 9230 02E2 STS	T_dat+1,R3
    0115B 9220 02E1 STS	T_dat,R2
(1342) 								T_dat|=Uart0RxData[i*2+0];//低字节
    0115D EF8B      LDI	R24,0xFB
    0115E E092      LDI	R25,2
    0115F 2DEA      MOV	R30,R10
    01160 27FF      CLR	R31
    01161 0FEE      LSL	R30
    01162 1FFF      ROL	R31
    01163 0FE8      ADD	R30,R24
    01164 1FF9      ADC	R31,R25
    01165 8020      LD	R2,Z
    01166 2433      CLR	R3
    01167 9040 02E1 LDS	R4,T_dat
    01169 9050 02E2 LDS	R5,T_dat+1
    0116B 2842      OR	R4,R2
    0116C 2853      OR	R5,R3
    0116D 9250 02E2 STS	T_dat+1,R5
    0116F 9240 02E1 STS	T_dat,R4
(1343) 								SendManchester();
    01171 940E 1B86 CALL	_SendManchester
(1344) 								Delay_ms(20);
    01173 E104      LDI	R16,0x14
    01174 E010      LDI	R17,0
    01175 940E 05F4 CALL	_Delay_ms
    01177 94A3      INC	R10
    01178 2D8A      MOV	R24,R10
    01179 3280      CPI	R24,0x20
    0117A F270      BCS	0x1149
(1345) 							}	
(1346) 
(1347) 							Uart0TxData[0]=0xE8;
    0117B EE88      LDI	R24,0xE8
    0117C 9380 012F STS	Uart0TxData,R24
(1348) 							Uart0TxData[1]=0x40;
    0117E E480      LDI	R24,0x40
    0117F 9380 0130 STS	Uart0TxData+1,R24
(1349) 							Uart0TxData[2]=0xc8;
    01181 EC88      LDI	R24,0xC8
    01182 9380 0131 STS	Uart0TxData+2,R24
(1350) 							Uart0TxData[3]=2;//测试信息包2
    01184 E082      LDI	R24,2
    01185 9380 0132 STS	Uart0TxData+3,R24
(1351) 							SendUart0_2(9,4);// 超时32ms	 
    01187 E024      LDI	R18,4
    01188 E030      LDI	R19,0
    01189 E009      LDI	R16,0x9
    0118A 940E 04EB CALL	_SendUart0_2
(1352) 							for(i=0;i<32;i++)
    0118C 24AA      CLR	R10
    0118D C02F      RJMP	0x11BD
(1353) 							{
(1354) 								T_dat=Uart0RxData[i*2+1];//高字节
    0118E EF8C      LDI	R24,0xFC
    0118F E092      LDI	R25,2
    01190 2DEA      MOV	R30,R10
    01191 27FF      CLR	R31
    01192 0FEE      LSL	R30
    01193 1FFF      ROL	R31
    01194 0FE8      ADD	R30,R24
    01195 1FF9      ADC	R31,R25
    01196 8020      LD	R2,Z
    01197 2433      CLR	R3
    01198 9230 02E2 STS	T_dat+1,R3
    0119A 9220 02E1 STS	T_dat,R2
(1355) 								T_dat<<=8;
    0119C 2C32      MOV	R3,R2
    0119D 2422      CLR	R2
    0119E 9230 02E2 STS	T_dat+1,R3
    011A0 9220 02E1 STS	T_dat,R2
(1356) 								T_dat|=Uart0RxData[i*2+0];//低字节
    011A2 EF8B      LDI	R24,0xFB
    011A3 E092      LDI	R25,2
    011A4 2DEA      MOV	R30,R10
    011A5 27FF      CLR	R31
    011A6 0FEE      LSL	R30
    011A7 1FFF      ROL	R31
    011A8 0FE8      ADD	R30,R24
    011A9 1FF9      ADC	R31,R25
    011AA 8020      LD	R2,Z
    011AB 2433      CLR	R3
    011AC 9040 02E1 LDS	R4,T_dat
    011AE 9050 02E2 LDS	R5,T_dat+1
    011B0 2842      OR	R4,R2
    011B1 2853      OR	R5,R3
    011B2 9250 02E2 STS	T_dat+1,R5
    011B4 9240 02E1 STS	T_dat,R4
(1357) 								SendManchester();
    011B6 940E 1B86 CALL	_SendManchester
(1358) 								Delay_ms(20);
    011B8 E104      LDI	R16,0x14
    011B9 E010      LDI	R17,0
    011BA 940E 05F4 CALL	_Delay_ms
    011BC 94A3      INC	R10
    011BD 2D8A      MOV	R24,R10
    011BE 3280      CPI	R24,0x20
    011BF F270      BCS	0x118E
(1359) 							}		
(1360) 
(1361) 							Uart0TxData[0]=0xE8;
    011C0 EE88      LDI	R24,0xE8
    011C1 9380 012F STS	Uart0TxData,R24
(1362) 							Uart0TxData[1]=0x40;
    011C3 E480      LDI	R24,0x40
    011C4 9380 0130 STS	Uart0TxData+1,R24
(1363) 							Uart0TxData[2]=0xc8;
    011C6 EC88      LDI	R24,0xC8
    011C7 9380 0131 STS	Uart0TxData+2,R24
(1364) 							Uart0TxData[3]=3;//测试信息包3
    011C9 E083      LDI	R24,3
    011CA 9380 0132 STS	Uart0TxData+3,R24
(1365) 							SendUart0_2(9,4);// 超时32ms	 
    011CC E024      LDI	R18,4
    011CD E030      LDI	R19,0
    011CE E009      LDI	R16,0x9
    011CF 940E 04EB CALL	_SendUart0_2
(1366) 							for(i=0;i<32;i++)
    011D1 24AA      CLR	R10
    011D2 C02F      RJMP	0x1202
(1367) 							{
(1368) 								T_dat=Uart0RxData[i*2+1];//高字节
    011D3 EF8C      LDI	R24,0xFC
    011D4 E092      LDI	R25,2
    011D5 2DEA      MOV	R30,R10
    011D6 27FF      CLR	R31
    011D7 0FEE      LSL	R30
    011D8 1FFF      ROL	R31
    011D9 0FE8      ADD	R30,R24
    011DA 1FF9      ADC	R31,R25
    011DB 8020      LD	R2,Z
    011DC 2433      CLR	R3
    011DD 9230 02E2 STS	T_dat+1,R3
    011DF 9220 02E1 STS	T_dat,R2
(1369) 								T_dat<<=8;
    011E1 2C32      MOV	R3,R2
    011E2 2422      CLR	R2
    011E3 9230 02E2 STS	T_dat+1,R3
    011E5 9220 02E1 STS	T_dat,R2
(1370) 								T_dat|=Uart0RxData[i*2+0];//低字节
    011E7 EF8B      LDI	R24,0xFB
    011E8 E092      LDI	R25,2
    011E9 2DEA      MOV	R30,R10
    011EA 27FF      CLR	R31
    011EB 0FEE      LSL	R30
    011EC 1FFF      ROL	R31
    011ED 0FE8      ADD	R30,R24
    011EE 1FF9      ADC	R31,R25
    011EF 8020      LD	R2,Z
    011F0 2433      CLR	R3
    011F1 9040 02E1 LDS	R4,T_dat
    011F3 9050 02E2 LDS	R5,T_dat+1
    011F5 2842      OR	R4,R2
    011F6 2853      OR	R5,R3
    011F7 9250 02E2 STS	T_dat+1,R5
    011F9 9240 02E1 STS	T_dat,R4
(1371) 								SendManchester();
    011FB 940E 1B86 CALL	_SendManchester
(1372) 								Delay_ms(20);
    011FD E104      LDI	R16,0x14
    011FE E010      LDI	R17,0
    011FF 940E 05F4 CALL	_Delay_ms
    01201 94A3      INC	R10
    01202 2D8A      MOV	R24,R10
    01203 3280      CPI	R24,0x20
    01204 F270      BCS	0x11D3
(1373) 							}			
(1374) 						}
    01205 940C 1B79 JMP	0x1B79
(1375) 						else if(R_dat==0x91)//上传压力标定数据,20ms/帧 	
    01207 9180 02DF LDS	R24,R_dat
    01209 9190 02E0 LDS	R25,R_dat+1
    0120B 3981      CPI	R24,0x91
    0120C E0E0      LDI	R30,0
    0120D 079E      CPC	R25,R30
    0120E F529      BNE	0x1234
(1376) 						{
(1377) 							//先获取总标定点数    
(1378) 							DataFlag=3;
    0120F E083      LDI	R24,3
    01210 E090      LDI	R25,0
    01211 9390 02C2 STS	DataFlag+1,R25
    01213 9380 02C1 STS	DataFlag,R24
(1379) 							coeff_len=4;//上位机还需传4字节，分别为首块地址和包数
    01215 E084      LDI	R24,4
    01216 9390 012D STS	coeff_len+1,R25
    01218 9380 012C STS	coeff_len,R24
(1380) 							coeff_count=0;
    0121A 2422      CLR	R2
    0121B 2433      CLR	R3
    0121C 9230 012B STS	coeff_count+1,R3
    0121E 9220 012A STS	coeff_count,R2
(1381) 							TimeOutFlag=0;
    01220 9220 02D9 STS	TimeOutFlag,R2
(1382) 							Timer0Counter=200;//1.6s定时
    01222 EC88      LDI	R24,0xC8
    01223 9390 0346 STS	Timer0Counter+1,R25
    01225 9380 0345 STS	Timer0Counter,R24
(1383) 							TCNT0=0x06; //8ms
    01227 E086      LDI	R24,6
    01228 BF82      OUT	0x32,R24
(1384) 							TCCR0|=0x06;//256分频
    01229 B783      IN	R24,0x33
    0122A 6086      ORI	R24,6
    0122B BF83      OUT	0x33,R24
(1385) 							TIFR|=0x01; //清定时器0中断标志
    0122C B786      IN	R24,0x36
    0122D 6081      ORI	R24,1
    0122E BF86      OUT	0x36,R24
(1386) 							TIMSK|=0x01;//使能定时器0中断		
    0122F B787      IN	R24,0x37
    01230 6081      ORI	R24,1
    01231 BF87      OUT	0x37,R24
(1387) 						}
    01232 940C 1B79 JMP	0x1B79
(1388) 						else if(R_dat==0x92)//清空标定数据,整机格式化  
    01234 9180 02DF LDS	R24,R_dat
    01236 9190 02E0 LDS	R25,R_dat+1
    01238 3982      CPI	R24,0x92
    01239 E0E0      LDI	R30,0
    0123A 079E      CPC	R25,R30
    0123B F5F1      BNE	0x127A
(1389) 						{ 	
(1390) 							Uart0TxData[0]=0xE8;
    0123C EE88      LDI	R24,0xE8
    0123D 9380 012F STS	Uart0TxData,R24
(1391) 							Uart0TxData[1]=0x40;
    0123F E480      LDI	R24,0x40
    01240 9380 0130 STS	Uart0TxData+1,R24
(1392) 							Uart0TxData[2]=0x8c;
    01242 E88C      LDI	R24,0x8C
    01243 9380 0131 STS	Uart0TxData+2,R24
(1393) 							Uart0TxData[3]=8;
    01245 E088      LDI	R24,0x8
    01246 9380 0132 STS	Uart0TxData+3,R24
(1394) 							Uart0TxData[4]=0;
    01248 2422      CLR	R2
    01249 9220 0133 STS	Uart0TxData+4,R2
(1395) 							Uart0TxData[5]=0;
    0124B 9220 0134 STS	Uart0TxData+5,R2
(1396) 							Uart0TxData[6]=0xff;
    0124D EF8F      LDI	R24,0xFF
    0124E 9380 0135 STS	Uart0TxData+6,R24
(1397) 							Uart0TxData[7]=0xff;
    01250 9380 0136 STS	Uart0TxData+7,R24
(1398) 							SendUart0_3(9,5000,9);// 最大超时40秒
    01252 E089      LDI	R24,0x9
    01253 8388      ST	Y,R24
    01254 E828      LDI	R18,0x88
    01255 E133      LDI	R19,0x13
    01256 E009      LDI	R16,0x9
    01257 940E 0535 CALL	_SendUart0_3
(1399) 							if((Uart0RxCounter==9)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x40)&&(Uart0RxData[2]==0x8c))
    01259 9180 02FA LDS	R24,Uart0RxCounter
    0125B 3089      CPI	R24,0x9
    0125C F499      BNE	0x1270
    0125D 9180 02FB LDS	R24,Uart0RxData
    0125F 3585      CPI	R24,0x55
    01260 F479      BNE	0x1270
    01261 9180 02FC LDS	R24,Uart0RxData+1
    01263 3480      CPI	R24,0x40
    01264 F459      BNE	0x1270
    01265 9180 02FD LDS	R24,Uart0RxData+2
    01267 388C      CPI	R24,0x8C
    01268 F439      BNE	0x1270
(1400) 								{T_dat=0x0000;}
    01269 2422      CLR	R2
    0126A 2433      CLR	R3
    0126B 9230 02E2 STS	T_dat+1,R3
    0126D 9220 02E1 STS	T_dat,R2
    0126F C006      RJMP	0x1276
(1401) 							else
(1402) 								{T_dat=0xffff;}
    01270 EF8F      LDI	R24,0xFF
    01271 EF9F      LDI	R25,0xFF
    01272 9390 02E2 STS	T_dat+1,R25
    01274 9380 02E1 STS	T_dat,R24
(1403) 							SendManchester();	 
    01276 940E 1B86 CALL	_SendManchester
(1404) 						}
    01278 940C 1B79 JMP	0x1B79
(1405) 						else if(R_dat==0x93)//上传全部系数，共256字节分128帧上传
    0127A 9180 02DF LDS	R24,R_dat
    0127C 9190 02E0 LDS	R25,R_dat+1
    0127E 3983      CPI	R24,0x93
    0127F E0E0      LDI	R30,0
    01280 079E      CPC	R25,R30
    01281 F009      BEQ	0x1283
    01282 C126      RJMP	0x13A9
(1406) 						{
(1407) 							Uart0TxData[0]=0xE8;
    01283 EE88      LDI	R24,0xE8
    01284 9380 012F STS	Uart0TxData,R24
(1408) 							Uart0TxData[1]=0x40;
    01286 E480      LDI	R24,0x40
    01287 9380 0130 STS	Uart0TxData+1,R24
(1409) 							Uart0TxData[2]=0x87;
    01289 E887      LDI	R24,0x87
    0128A 9380 0131 STS	Uart0TxData+2,R24
(1410) 							Uart0TxData[3]=0;//系数包0
    0128C 2422      CLR	R2
    0128D 9220 0132 STS	Uart0TxData+3,R2
(1411) 							SendUart0_2(9,4);// 超时32ms	
    0128F E024      LDI	R18,4
    01290 E030      LDI	R19,0
    01291 E009      LDI	R16,0x9
    01292 940E 04EB CALL	_SendUart0_2
(1412) 							if(Uart0RxCounter==64) 
    01294 9180 02FA LDS	R24,Uart0RxCounter
    01296 3480      CPI	R24,0x40
    01297 F5A1      BNE	0x12CC
(1413) 							{
(1414) 								for(i=0;i<32;i++)
    01298 24AA      CLR	R10
    01299 C02F      RJMP	0x12C9
(1415) 								{
(1416) 									Delay_ms(20);
    0129A E104      LDI	R16,0x14
    0129B E010      LDI	R17,0
    0129C 940E 05F4 CALL	_Delay_ms
(1417) 									T_dat=Uart0RxData[i*2+1];//高字节
    0129E EF8C      LDI	R24,0xFC
    0129F E092      LDI	R25,2
    012A0 2DEA      MOV	R30,R10
    012A1 27FF      CLR	R31
    012A2 0FEE      LSL	R30
    012A3 1FFF      ROL	R31
    012A4 0FE8      ADD	R30,R24
    012A5 1FF9      ADC	R31,R25
    012A6 8020      LD	R2,Z
    012A7 2433      CLR	R3
    012A8 9230 02E2 STS	T_dat+1,R3
    012AA 9220 02E1 STS	T_dat,R2
(1418) 									T_dat<<=8;
    012AC 2C32      MOV	R3,R2
    012AD 2422      CLR	R2
    012AE 9230 02E2 STS	T_dat+1,R3
    012B0 9220 02E1 STS	T_dat,R2
(1419) 									T_dat|=Uart0RxData[i*2+0];//低字节
    012B2 EF8B      LDI	R24,0xFB
    012B3 E092      LDI	R25,2
    012B4 2DEA      MOV	R30,R10
    012B5 27FF      CLR	R31
    012B6 0FEE      LSL	R30
    012B7 1FFF      ROL	R31
    012B8 0FE8      ADD	R30,R24
    012B9 1FF9      ADC	R31,R25
    012BA 8020      LD	R2,Z
    012BB 2433      CLR	R3
    012BC 9040 02E1 LDS	R4,T_dat
    012BE 9050 02E2 LDS	R5,T_dat+1
    012C0 2842      OR	R4,R2
    012C1 2853      OR	R5,R3
    012C2 9250 02E2 STS	T_dat+1,R5
    012C4 9240 02E1 STS	T_dat,R4
(1420) 									SendManchester();		 
    012C6 940E 1B86 CALL	_SendManchester
    012C8 94A3      INC	R10
    012C9 2D8A      MOV	R24,R10
    012CA 3280      CPI	R24,0x20
    012CB F270      BCS	0x129A
(1421) 								}	
(1422) 							}	
(1423) 
(1424) 							Uart0TxData[0]=0xE8;
    012CC EE88      LDI	R24,0xE8
    012CD 9380 012F STS	Uart0TxData,R24
(1425) 							Uart0TxData[1]=0x40;
    012CF E480      LDI	R24,0x40
    012D0 9380 0130 STS	Uart0TxData+1,R24
(1426) 							Uart0TxData[2]=0x87;
    012D2 E887      LDI	R24,0x87
    012D3 9380 0131 STS	Uart0TxData+2,R24
(1427) 							Uart0TxData[3]=1;//系数包1
    012D5 E081      LDI	R24,1
    012D6 9380 0132 STS	Uart0TxData+3,R24
(1428) 							SendUart0_2(9,4);// 超时32ms	 
    012D8 E024      LDI	R18,4
    012D9 E030      LDI	R19,0
    012DA E009      LDI	R16,0x9
    012DB 940E 04EB CALL	_SendUart0_2
(1429) 							if(Uart0RxCounter==64) 
    012DD 9180 02FA LDS	R24,Uart0RxCounter
    012DF 3480      CPI	R24,0x40
    012E0 F5A1      BNE	0x1315
(1430) 							{
(1431) 								for(i=0;i<32;i++)
    012E1 24AA      CLR	R10
    012E2 C02F      RJMP	0x1312
(1432) 								{
(1433) 									T_dat=Uart0RxData[i*2+1];//高字节
    012E3 EF8C      LDI	R24,0xFC
    012E4 E092      LDI	R25,2
    012E5 2DEA      MOV	R30,R10
    012E6 27FF      CLR	R31
    012E7 0FEE      LSL	R30
    012E8 1FFF      ROL	R31
    012E9 0FE8      ADD	R30,R24
    012EA 1FF9      ADC	R31,R25
    012EB 8020      LD	R2,Z
    012EC 2433      CLR	R3
    012ED 9230 02E2 STS	T_dat+1,R3
    012EF 9220 02E1 STS	T_dat,R2
(1434) 									T_dat<<=8;
    012F1 2C32      MOV	R3,R2
    012F2 2422      CLR	R2
    012F3 9230 02E2 STS	T_dat+1,R3
    012F5 9220 02E1 STS	T_dat,R2
(1435) 									T_dat|=Uart0RxData[i*2+0];//低字节
    012F7 EF8B      LDI	R24,0xFB
    012F8 E092      LDI	R25,2
    012F9 2DEA      MOV	R30,R10
    012FA 27FF      CLR	R31
    012FB 0FEE      LSL	R30
    012FC 1FFF      ROL	R31
    012FD 0FE8      ADD	R30,R24
    012FE 1FF9      ADC	R31,R25
    012FF 8020      LD	R2,Z
    01300 2433      CLR	R3
    01301 9040 02E1 LDS	R4,T_dat
    01303 9050 02E2 LDS	R5,T_dat+1
    01305 2842      OR	R4,R2
    01306 2853      OR	R5,R3
    01307 9250 02E2 STS	T_dat+1,R5
    01309 9240 02E1 STS	T_dat,R4
(1436) 									SendManchester();
    0130B 940E 1B86 CALL	_SendManchester
(1437) 									Delay_ms(20);
    0130D E104      LDI	R16,0x14
    0130E E010      LDI	R17,0
    0130F 940E 05F4 CALL	_Delay_ms
    01311 94A3      INC	R10
    01312 2D8A      MOV	R24,R10
    01313 3280      CPI	R24,0x20
    01314 F270      BCS	0x12E3
(1438) 								}
(1439) 							}		
(1440) 
(1441) 							Uart0TxData[0]=0xE8;
    01315 EE88      LDI	R24,0xE8
    01316 9380 012F STS	Uart0TxData,R24
(1442) 							Uart0TxData[1]=0x40;
    01318 E480      LDI	R24,0x40
    01319 9380 0130 STS	Uart0TxData+1,R24
(1443) 							Uart0TxData[2]=0x87;
    0131B E887      LDI	R24,0x87
    0131C 9380 0131 STS	Uart0TxData+2,R24
(1444) 							Uart0TxData[3]=2;//系数包2
    0131E E082      LDI	R24,2
    0131F 9380 0132 STS	Uart0TxData+3,R24
(1445) 							SendUart0_2(9,4);// 超时32ms	
    01321 E024      LDI	R18,4
    01322 E030      LDI	R19,0
    01323 E009      LDI	R16,0x9
    01324 940E 04EB CALL	_SendUart0_2
(1446) 							if(Uart0RxCounter==64) 
    01326 9180 02FA LDS	R24,Uart0RxCounter
    01328 3480      CPI	R24,0x40
    01329 F5A1      BNE	0x135E
(1447) 							{
(1448) 								for(i=0;i<32;i++)
    0132A 24AA      CLR	R10
    0132B C02F      RJMP	0x135B
(1449) 								{
(1450) 									Delay_ms(20);
    0132C E104      LDI	R16,0x14
    0132D E010      LDI	R17,0
    0132E 940E 05F4 CALL	_Delay_ms
(1451) 									T_dat=Uart0RxData[i*2+1];//高字节
    01330 EF8C      LDI	R24,0xFC
    01331 E092      LDI	R25,2
    01332 2DEA      MOV	R30,R10
    01333 27FF      CLR	R31
    01334 0FEE      LSL	R30
    01335 1FFF      ROL	R31
    01336 0FE8      ADD	R30,R24
    01337 1FF9      ADC	R31,R25
    01338 8020      LD	R2,Z
    01339 2433      CLR	R3
    0133A 9230 02E2 STS	T_dat+1,R3
    0133C 9220 02E1 STS	T_dat,R2
(1452) 									T_dat<<=8;
    0133E 2C32      MOV	R3,R2
    0133F 2422      CLR	R2
    01340 9230 02E2 STS	T_dat+1,R3
    01342 9220 02E1 STS	T_dat,R2
(1453) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01344 EF8B      LDI	R24,0xFB
    01345 E092      LDI	R25,2
    01346 2DEA      MOV	R30,R10
    01347 27FF      CLR	R31
    01348 0FEE      LSL	R30
    01349 1FFF      ROL	R31
    0134A 0FE8      ADD	R30,R24
    0134B 1FF9      ADC	R31,R25
    0134C 8020      LD	R2,Z
    0134D 2433      CLR	R3
    0134E 9040 02E1 LDS	R4,T_dat
    01350 9050 02E2 LDS	R5,T_dat+1
    01352 2842      OR	R4,R2
    01353 2853      OR	R5,R3
    01354 9250 02E2 STS	T_dat+1,R5
    01356 9240 02E1 STS	T_dat,R4
(1454) 									SendManchester();		 
    01358 940E 1B86 CALL	_SendManchester
    0135A 94A3      INC	R10
    0135B 2D8A      MOV	R24,R10
    0135C 3280      CPI	R24,0x20
    0135D F270      BCS	0x132C
(1455) 								}	
(1456) 							}	
(1457) 
(1458) 							Uart0TxData[0]=0xE8;
    0135E EE88      LDI	R24,0xE8
    0135F 9380 012F STS	Uart0TxData,R24
(1459) 							Uart0TxData[1]=0x40;
    01361 E480      LDI	R24,0x40
    01362 9380 0130 STS	Uart0TxData+1,R24
(1460) 							Uart0TxData[2]=0x87;
    01364 E887      LDI	R24,0x87
    01365 9380 0131 STS	Uart0TxData+2,R24
(1461) 							Uart0TxData[3]=3;//系数包3
    01367 E083      LDI	R24,3
    01368 9380 0132 STS	Uart0TxData+3,R24
(1462) 							SendUart0_2(9,4);// 超时32ms	 
    0136A E024      LDI	R18,4
    0136B E030      LDI	R19,0
    0136C E009      LDI	R16,0x9
    0136D 940E 04EB CALL	_SendUart0_2
(1463) 							if(Uart0RxCounter==64) 
    0136F 9180 02FA LDS	R24,Uart0RxCounter
    01371 3480      CPI	R24,0x40
    01372 F011      BEQ	0x1375
    01373 940C 1B79 JMP	0x1B79
(1464) 							{
(1465) 								for(i=0;i<32;i++)
    01375 24AA      CLR	R10
    01376 C02E      RJMP	0x13A5
(1466) 								{
(1467) 									T_dat=Uart0RxData[i*2+1];//高字节
    01377 EF8C      LDI	R24,0xFC
    01378 E092      LDI	R25,2
    01379 2DEA      MOV	R30,R10
    0137A 27FF      CLR	R31
    0137B 0FEE      LSL	R30
    0137C 1FFF      ROL	R31
    0137D 0FE8      ADD	R30,R24
    0137E 1FF9      ADC	R31,R25
    0137F 8020      LD	R2,Z
    01380 2433      CLR	R3
    01381 9230 02E2 STS	T_dat+1,R3
    01383 9220 02E1 STS	T_dat,R2
(1468) 									T_dat<<=8;
    01385 2C32      MOV	R3,R2
    01386 2422      CLR	R2
    01387 9230 02E2 STS	T_dat+1,R3
    01389 9220 02E1 STS	T_dat,R2
(1469) 									T_dat|=Uart0RxData[i*2+0];//低字节
    0138B EF8B      LDI	R24,0xFB
    0138C E092      LDI	R25,2
    0138D 2DEA      MOV	R30,R10
    0138E 27FF      CLR	R31
    0138F 0FEE      LSL	R30
    01390 1FFF      ROL	R31
    01391 0FE8      ADD	R30,R24
    01392 1FF9      ADC	R31,R25
    01393 8020      LD	R2,Z
    01394 2433      CLR	R3
    01395 9040 02E1 LDS	R4,T_dat
    01397 9050 02E2 LDS	R5,T_dat+1
    01399 2842      OR	R4,R2
    0139A 2853      OR	R5,R3
    0139B 9250 02E2 STS	T_dat+1,R5
    0139D 9240 02E1 STS	T_dat,R4
(1470) 									SendManchester();
    0139F D7E6      RCALL	_SendManchester
(1471) 									Delay_ms(20);
    013A0 E104      LDI	R16,0x14
    013A1 E010      LDI	R17,0
    013A2 940E 05F4 CALL	_Delay_ms
    013A4 94A3      INC	R10
    013A5 2D8A      MOV	R24,R10
    013A6 3280      CPI	R24,0x20
    013A7 F278      BCS	0x1377
(1472) 								}
(1473) 							}		
(1474) 						}
    013A8 C7D0      RJMP	0x1B79
(1475) 						else if(R_dat>=0x9a)//设置电机断路电流 
    013A9 9180 02DF LDS	R24,R_dat
    013AB 9190 02E0 LDS	R25,R_dat+1
    013AD 398A      CPI	R24,0x9A
    013AE E0E0      LDI	R30,0
    013AF 079E      CPC	R25,R30
    013B0 F40C      BGE	0x13B2
    013B1 C7C7      RJMP	0x1B79
(1476) 						{
(1477) 							SendUart1(R_dat,4);//32ms超时
    013B2 E024      LDI	R18,4
    013B3 E030      LDI	R19,0
    013B4 018C      MOVW	R16,R24
    013B5 940E 02B3 CALL	_SendUart1
(1478) 						    T_dat=Uart1RxData[0];
    013B7 9020 02F6 LDS	R2,Uart1RxData
    013B9 2433      CLR	R3
    013BA 9230 02E2 STS	T_dat+1,R3
    013BC 9220 02E1 STS	T_dat,R2
(1479) 							SendManchester();
    013BE D7C7      RCALL	_SendManchester
(1480) 						}
(1481) 						 
(1482) 						break;
    013BF C7B9      RJMP	0x1B79
(1483) 
(1484) 					case 0xa0://压力标定系数
(1485) 						if(R_dat==0xa0)//下发全部标定系数，共128字节,20ms/帧，共2560ms   
    013C0 9180 02DF LDS	R24,R_dat
    013C2 9190 02E0 LDS	R25,R_dat+1
    013C4 3A80      CPI	R24,0xA0
    013C5 E0E0      LDI	R30,0
    013C6 079E      CPC	R25,R30
    013C7 F529      BNE	0x13ED
(1486) 							{ 
(1487) 							DataFlag=1;
    013C8 E081      LDI	R24,1
    013C9 E090      LDI	R25,0
    013CA 9390 02C2 STS	DataFlag+1,R25
    013CC 9380 02C1 STS	DataFlag,R24
(1488) 							coeff_len=128;
    013CE E880      LDI	R24,0x80
    013CF 9390 012D STS	coeff_len+1,R25
    013D1 9380 012C STS	coeff_len,R24
(1489) 							coeff_count=0;
    013D3 2422      CLR	R2
    013D4 2433      CLR	R3
    013D5 9230 012B STS	coeff_count+1,R3
    013D7 9220 012A STS	coeff_count,R2
(1490) 							TimeOutFlag=0;
    013D9 9220 02D9 STS	TimeOutFlag,R2
(1491) 							Timer0Counter=1000;//8s定时
    013DB EE88      LDI	R24,0xE8
    013DC E093      LDI	R25,3
    013DD 9390 0346 STS	Timer0Counter+1,R25
    013DF 9380 0345 STS	Timer0Counter,R24
(1492) 							TCNT0=0x06; //8ms
    013E1 E086      LDI	R24,6
    013E2 BF82      OUT	0x32,R24
(1493) 							TCCR0|=0x06;//256分频
    013E3 B783      IN	R24,0x33
    013E4 6086      ORI	R24,6
    013E5 BF83      OUT	0x33,R24
(1494) 							TIFR|=0x01; //清定时器0中断标志
    013E6 B786      IN	R24,0x36
    013E7 6081      ORI	R24,1
    013E8 BF86      OUT	0x36,R24
(1495) 							TIMSK|=0x01;//使能定时器0中断				    
    013E9 B787      IN	R24,0x37
    013EA 6081      ORI	R24,1
    013EB BF87      OUT	0x37,R24
(1496) 						}
    013EC C78C      RJMP	0x1B79
(1497) 						else if(R_dat==0xa1)//上传标定系数,28ms/帧 ，共64帧128字节
    013ED 9180 02DF LDS	R24,R_dat
    013EF 9190 02E0 LDS	R25,R_dat+1
    013F1 3A81      CPI	R24,0xA1
    013F2 E0E0      LDI	R30,0
    013F3 079E      CPC	R25,R30
    013F4 F009      BEQ	0x13F6
    013F5 C783      RJMP	0x1B79
(1498) 						{    
(1499) 							Uart0TxData[0]=0xE8;
    013F6 EE88      LDI	R24,0xE8
    013F7 9380 012F STS	Uart0TxData,R24
(1500) 							Uart0TxData[1]=0x40;
    013F9 E480      LDI	R24,0x40
    013FA 9380 0130 STS	Uart0TxData+1,R24
(1501) 							Uart0TxData[2]=0x87;
    013FC E887      LDI	R24,0x87
    013FD 9380 0131 STS	Uart0TxData+2,R24
(1502) 							Uart0TxData[3]=0;//系数包0
    013FF 2422      CLR	R2
    01400 9220 0132 STS	Uart0TxData+3,R2
(1503) 							SendUart0_2(9,5);// 超时40ms	
    01402 E025      LDI	R18,5
    01403 E030      LDI	R19,0
    01404 E009      LDI	R16,0x9
    01405 940E 04EB CALL	_SendUart0_2
(1504) 							if(Uart0RxCounter==64) 
    01407 9180 02FA LDS	R24,Uart0RxCounter
    01409 3480      CPI	R24,0x40
    0140A F599      BNE	0x143E
(1505) 							{
(1506) 								for(i=0;i<32;i++)
    0140B 24AA      CLR	R10
    0140C C02E      RJMP	0x143B
(1507) 								{
(1508) 									Delay_ms(20);
    0140D E104      LDI	R16,0x14
    0140E E010      LDI	R17,0
    0140F 940E 05F4 CALL	_Delay_ms
(1509) 									T_dat=Uart0RxData[i*2+1];//高字节
    01411 EF8C      LDI	R24,0xFC
    01412 E092      LDI	R25,2
    01413 2DEA      MOV	R30,R10
    01414 27FF      CLR	R31
    01415 0FEE      LSL	R30
    01416 1FFF      ROL	R31
    01417 0FE8      ADD	R30,R24
    01418 1FF9      ADC	R31,R25
    01419 8020      LD	R2,Z
    0141A 2433      CLR	R3
    0141B 9230 02E2 STS	T_dat+1,R3
    0141D 9220 02E1 STS	T_dat,R2
(1510) 									T_dat<<=8;
    0141F 2C32      MOV	R3,R2
    01420 2422      CLR	R2
    01421 9230 02E2 STS	T_dat+1,R3
    01423 9220 02E1 STS	T_dat,R2
(1511) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01425 EF8B      LDI	R24,0xFB
    01426 E092      LDI	R25,2
    01427 2DEA      MOV	R30,R10
    01428 27FF      CLR	R31
    01429 0FEE      LSL	R30
    0142A 1FFF      ROL	R31
    0142B 0FE8      ADD	R30,R24
    0142C 1FF9      ADC	R31,R25
    0142D 8020      LD	R2,Z
    0142E 2433      CLR	R3
    0142F 9040 02E1 LDS	R4,T_dat
    01431 9050 02E2 LDS	R5,T_dat+1
    01433 2842      OR	R4,R2
    01434 2853      OR	R5,R3
    01435 9250 02E2 STS	T_dat+1,R5
    01437 9240 02E1 STS	T_dat,R4
(1512) 									SendManchester();		 
    01439 D74C      RCALL	_SendManchester
    0143A 94A3      INC	R10
    0143B 2D8A      MOV	R24,R10
    0143C 3280      CPI	R24,0x20
    0143D F278      BCS	0x140D
(1513) 								}	
(1514) 							}	
(1515) 
(1516) 							Uart0TxData[0]=0xE8;
    0143E EE88      LDI	R24,0xE8
    0143F 9380 012F STS	Uart0TxData,R24
(1517) 							Uart0TxData[1]=0x40;
    01441 E480      LDI	R24,0x40
    01442 9380 0130 STS	Uart0TxData+1,R24
(1518) 							Uart0TxData[2]=0x87;
    01444 E887      LDI	R24,0x87
    01445 9380 0131 STS	Uart0TxData+2,R24
(1519) 							Uart0TxData[3]=1;//系数包1
    01447 E081      LDI	R24,1
    01448 9380 0132 STS	Uart0TxData+3,R24
(1520) 							SendUart0_2(9,5);// 超时40ms		 
    0144A E025      LDI	R18,5
    0144B E030      LDI	R19,0
    0144C E009      LDI	R16,0x9
    0144D 940E 04EB CALL	_SendUart0_2
(1521) 							if(Uart0RxCounter==64) 
    0144F 9180 02FA LDS	R24,Uart0RxCounter
    01451 3480      CPI	R24,0x40
    01452 F009      BEQ	0x1454
    01453 C725      RJMP	0x1B79
(1522) 							{
(1523) 								for(i=0;i<32;i++)
    01454 24AA      CLR	R10
    01455 C02E      RJMP	0x1484
(1524) 								{
(1525) 									T_dat=Uart0RxData[i*2+1];//高字节
    01456 EF8C      LDI	R24,0xFC
    01457 E092      LDI	R25,2
    01458 2DEA      MOV	R30,R10
    01459 27FF      CLR	R31
    0145A 0FEE      LSL	R30
    0145B 1FFF      ROL	R31
    0145C 0FE8      ADD	R30,R24
    0145D 1FF9      ADC	R31,R25
    0145E 8020      LD	R2,Z
    0145F 2433      CLR	R3
    01460 9230 02E2 STS	T_dat+1,R3
    01462 9220 02E1 STS	T_dat,R2
(1526) 									T_dat<<=8;
    01464 2C32      MOV	R3,R2
    01465 2422      CLR	R2
    01466 9230 02E2 STS	T_dat+1,R3
    01468 9220 02E1 STS	T_dat,R2
(1527) 									T_dat|=Uart0RxData[i*2+0];//低字节
    0146A EF8B      LDI	R24,0xFB
    0146B E092      LDI	R25,2
    0146C 2DEA      MOV	R30,R10
    0146D 27FF      CLR	R31
    0146E 0FEE      LSL	R30
    0146F 1FFF      ROL	R31
    01470 0FE8      ADD	R30,R24
    01471 1FF9      ADC	R31,R25
    01472 8020      LD	R2,Z
    01473 2433      CLR	R3
    01474 9040 02E1 LDS	R4,T_dat
    01476 9050 02E2 LDS	R5,T_dat+1
    01478 2842      OR	R4,R2
    01479 2853      OR	R5,R3
    0147A 9250 02E2 STS	T_dat+1,R5
    0147C 9240 02E1 STS	T_dat,R4
(1528) 									SendManchester();
    0147E D707      RCALL	_SendManchester
(1529) 									Delay_ms(20);
    0147F E104      LDI	R16,0x14
    01480 E010      LDI	R17,0
    01481 940E 05F4 CALL	_Delay_ms
    01483 94A3      INC	R10
    01484 2D8A      MOV	R24,R10
    01485 3280      CPI	R24,0x20
    01486 F278      BCS	0x1456
(1530) 								}
(1531) 							}		
(1532) 						}
(1533) 						break;
    01487 C6F1      RJMP	0x1B79
(1534) 
(1535) 
(1536) 					case 0xB0://流量相关
(1537) 						if(R_dat==0xb0) //下发流量系数
    01488 9180 02DF LDS	R24,R_dat
    0148A 9190 02E0 LDS	R25,R_dat+1
    0148C 3B80      CPI	R24,0xB0
    0148D E0E0      LDI	R30,0
    0148E 079E      CPC	R25,R30
    0148F F529      BNE	0x14B5
(1538) 						{
(1539) 							DataFlag=2;
    01490 E082      LDI	R24,2
    01491 E090      LDI	R25,0
    01492 9390 02C2 STS	DataFlag+1,R25
    01494 9380 02C1 STS	DataFlag,R24
(1540) 							coeff_len=128;
    01496 E880      LDI	R24,0x80
    01497 9390 012D STS	coeff_len+1,R25
    01499 9380 012C STS	coeff_len,R24
(1541) 							coeff_count=0;
    0149B 2422      CLR	R2
    0149C 2433      CLR	R3
    0149D 9230 012B STS	coeff_count+1,R3
    0149F 9220 012A STS	coeff_count,R2
(1542) 							TimeOutFlag=0;
    014A1 9220 02D9 STS	TimeOutFlag,R2
(1543) 							Timer0Counter=1000;//8s定时
    014A3 EE88      LDI	R24,0xE8
    014A4 E093      LDI	R25,3
    014A5 9390 0346 STS	Timer0Counter+1,R25
    014A7 9380 0345 STS	Timer0Counter,R24
(1544) 							TCNT0=0x06; //8ms
    014A9 E086      LDI	R24,6
    014AA BF82      OUT	0x32,R24
(1545) 							TCCR0|=0x06;//256分频
    014AB B783      IN	R24,0x33
    014AC 6086      ORI	R24,6
    014AD BF83      OUT	0x33,R24
(1546) 							TIFR|=0x01; //清定时器0中断标志
    014AE B786      IN	R24,0x36
    014AF 6081      ORI	R24,1
    014B0 BF86      OUT	0x36,R24
(1547) 							TIMSK|=0x01;//使能定时器0中断		
    014B1 B787      IN	R24,0x37
    014B2 6081      ORI	R24,1
    014B3 BF87      OUT	0x37,R24
(1548) 						}
    014B4 C6C4      RJMP	0x1B79
(1549) 						else  if(R_dat==0xb1)//上提流量系数
    014B5 9180 02DF LDS	R24,R_dat
    014B7 9190 02E0 LDS	R25,R_dat+1
    014B9 3B81      CPI	R24,0xB1
    014BA E0E0      LDI	R30,0
    014BB 079E      CPC	R25,R30
    014BC F009      BEQ	0x14BE
    014BD C092      RJMP	0x1550
(1550) 						{
(1551) 							Uart0TxData[0]=0xE8;
    014BE EE88      LDI	R24,0xE8
    014BF 9380 012F STS	Uart0TxData,R24
(1552) 							Uart0TxData[1]=0x40;
    014C1 E480      LDI	R24,0x40
    014C2 9380 0130 STS	Uart0TxData+1,R24
(1553) 							Uart0TxData[2]=0x87;
    014C4 E887      LDI	R24,0x87
    014C5 9380 0131 STS	Uart0TxData+2,R24
(1554) 							Uart0TxData[3]=2;//系数包2
    014C7 E082      LDI	R24,2
    014C8 9380 0132 STS	Uart0TxData+3,R24
(1555) 							SendUart0_2(9,5);// 超时40ms	
    014CA E025      LDI	R18,5
    014CB E030      LDI	R19,0
    014CC E009      LDI	R16,0x9
    014CD 940E 04EB CALL	_SendUart0_2
(1556) 							if(Uart0RxCounter==64) 
    014CF 9180 02FA LDS	R24,Uart0RxCounter
    014D1 3480      CPI	R24,0x40
    014D2 F599      BNE	0x1506
(1557) 							{
(1558) 								for(i=0;i<32;i++)
    014D3 24AA      CLR	R10
    014D4 C02E      RJMP	0x1503
(1559) 								{
(1560) 									Delay_ms(20);
    014D5 E104      LDI	R16,0x14
    014D6 E010      LDI	R17,0
    014D7 940E 05F4 CALL	_Delay_ms
(1561) 									T_dat=Uart0RxData[i*2+1];//高字节
    014D9 EF8C      LDI	R24,0xFC
    014DA E092      LDI	R25,2
    014DB 2DEA      MOV	R30,R10
    014DC 27FF      CLR	R31
    014DD 0FEE      LSL	R30
    014DE 1FFF      ROL	R31
    014DF 0FE8      ADD	R30,R24
    014E0 1FF9      ADC	R31,R25
    014E1 8020      LD	R2,Z
    014E2 2433      CLR	R3
    014E3 9230 02E2 STS	T_dat+1,R3
    014E5 9220 02E1 STS	T_dat,R2
(1562) 									T_dat<<=8;
    014E7 2C32      MOV	R3,R2
    014E8 2422      CLR	R2
    014E9 9230 02E2 STS	T_dat+1,R3
    014EB 9220 02E1 STS	T_dat,R2
(1563) 									T_dat|=Uart0RxData[i*2+0];//低字节
    014ED EF8B      LDI	R24,0xFB
    014EE E092      LDI	R25,2
    014EF 2DEA      MOV	R30,R10
    014F0 27FF      CLR	R31
    014F1 0FEE      LSL	R30
    014F2 1FFF      ROL	R31
    014F3 0FE8      ADD	R30,R24
    014F4 1FF9      ADC	R31,R25
    014F5 8020      LD	R2,Z
    014F6 2433      CLR	R3
    014F7 9040 02E1 LDS	R4,T_dat
    014F9 9050 02E2 LDS	R5,T_dat+1
    014FB 2842      OR	R4,R2
    014FC 2853      OR	R5,R3
    014FD 9250 02E2 STS	T_dat+1,R5
    014FF 9240 02E1 STS	T_dat,R4
(1564) 									SendManchester();		 
    01501 D684      RCALL	_SendManchester
    01502 94A3      INC	R10
    01503 2D8A      MOV	R24,R10
    01504 3280      CPI	R24,0x20
    01505 F278      BCS	0x14D5
(1565) 								}	
(1566) 							}	
(1567) 
(1568) 							Uart0TxData[0]=0xE8;
    01506 EE88      LDI	R24,0xE8
    01507 9380 012F STS	Uart0TxData,R24
(1569) 							Uart0TxData[1]=0x40;
    01509 E480      LDI	R24,0x40
    0150A 9380 0130 STS	Uart0TxData+1,R24
(1570) 							Uart0TxData[2]=0x87;
    0150C E887      LDI	R24,0x87
    0150D 9380 0131 STS	Uart0TxData+2,R24
(1571) 							Uart0TxData[3]=3;//系数包3
    0150F E083      LDI	R24,3
    01510 9380 0132 STS	Uart0TxData+3,R24
(1572) 							SendUart0_2(9,5);// 超时40ms	 
    01512 E025      LDI	R18,5
    01513 E030      LDI	R19,0
    01514 E009      LDI	R16,0x9
    01515 940E 04EB CALL	_SendUart0_2
(1573) 							if(Uart0RxCounter==64) 
    01517 9180 02FA LDS	R24,Uart0RxCounter
    01519 3480      CPI	R24,0x40
    0151A F009      BEQ	0x151C
    0151B C65D      RJMP	0x1B79
(1574) 							{
(1575) 								for(i=0;i<32;i++)
    0151C 24AA      CLR	R10
    0151D C02E      RJMP	0x154C
(1576) 								{
(1577) 									T_dat=Uart0RxData[i*2+1];//高字节
    0151E EF8C      LDI	R24,0xFC
    0151F E092      LDI	R25,2
    01520 2DEA      MOV	R30,R10
    01521 27FF      CLR	R31
    01522 0FEE      LSL	R30
    01523 1FFF      ROL	R31
    01524 0FE8      ADD	R30,R24
    01525 1FF9      ADC	R31,R25
    01526 8020      LD	R2,Z
    01527 2433      CLR	R3
    01528 9230 02E2 STS	T_dat+1,R3
    0152A 9220 02E1 STS	T_dat,R2
(1578) 									T_dat<<=8;
    0152C 2C32      MOV	R3,R2
    0152D 2422      CLR	R2
    0152E 9230 02E2 STS	T_dat+1,R3
    01530 9220 02E1 STS	T_dat,R2
(1579) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01532 EF8B      LDI	R24,0xFB
    01533 E092      LDI	R25,2
    01534 2DEA      MOV	R30,R10
    01535 27FF      CLR	R31
    01536 0FEE      LSL	R30
    01537 1FFF      ROL	R31
    01538 0FE8      ADD	R30,R24
    01539 1FF9      ADC	R31,R25
    0153A 8020      LD	R2,Z
    0153B 2433      CLR	R3
    0153C 9040 02E1 LDS	R4,T_dat
    0153E 9050 02E2 LDS	R5,T_dat+1
    01540 2842      OR	R4,R2
    01541 2853      OR	R5,R3
    01542 9250 02E2 STS	T_dat+1,R5
    01544 9240 02E1 STS	T_dat,R4
(1580) 									SendManchester();
    01546 D63F      RCALL	_SendManchester
(1581) 									Delay_ms(20);
    01547 E104      LDI	R16,0x14
    01548 E010      LDI	R17,0
    01549 940E 05F4 CALL	_Delay_ms
    0154B 94A3      INC	R10
    0154C 2D8A      MOV	R24,R10
    0154D 3280      CPI	R24,0x20
    0154E F278      BCS	0x151E
(1582) 								}
(1583) 							}		
(1584) 						}
    0154F C629      RJMP	0x1B79
(1585) 						else if(R_dat==0xb2)//读参数，包括顺、逆幅和顺、逆阈值，暂只考虑上流量计，共8字节
    01550 9180 02DF LDS	R24,R_dat
    01552 9190 02E0 LDS	R25,R_dat+1
    01554 3B82      CPI	R24,0xB2
    01555 E0E0      LDI	R30,0
    01556 079E      CPC	R25,R30
    01557 F009      BEQ	0x1559
    01558 C054      RJMP	0x15AD
(1586) 						{
(1587) 						    Uart0TxData[0]=0xE8;
    01559 EE88      LDI	R24,0xE8
    0155A 9380 012F STS	Uart0TxData,R24
(1588) 							Uart0TxData[1]=0x40;
    0155C E480      LDI	R24,0x40
    0155D 9380 0130 STS	Uart0TxData+1,R24
(1589) 							Uart0TxData[2]=0xb2;
    0155F EB82      LDI	R24,0xB2
    01560 9380 0131 STS	Uart0TxData+2,R24
(1590) 							SendUart0_2(9,5);// 超时40ms	
    01562 E025      LDI	R18,5
    01563 E030      LDI	R19,0
    01564 E009      LDI	R16,0x9
    01565 940E 04EB CALL	_SendUart0_2
(1591) 							for(k=0;k<8;k+=2)
    01567 2422      CLR	R2
    01568 2433      CLR	R3
    01569 9230 02BC STS	k+1,R3
    0156B 9220 02BB STS	k,R2
    0156D C035      RJMP	0x15A3
(1592) 							{
(1593) 							T_dat=Uart0RxData[k];
    0156E EF8B      LDI	R24,0xFB
    0156F E092      LDI	R25,2
    01570 91E0 02BB LDS	R30,k
    01572 91F0 02BC LDS	R31,k+1
    01574 0FE8      ADD	R30,R24
    01575 1FF9      ADC	R31,R25
    01576 8020      LD	R2,Z
    01577 2433      CLR	R3
    01578 9230 02E2 STS	T_dat+1,R3
    0157A 9220 02E1 STS	T_dat,R2
(1594) 							T_dat<<=8;
    0157C 2C32      MOV	R3,R2
    0157D 2422      CLR	R2
    0157E 9230 02E2 STS	T_dat+1,R3
    01580 9220 02E1 STS	T_dat,R2
(1595) 							T_dat|=Uart0RxData[k+1];
    01582 91E0 02BB LDS	R30,k
    01584 91F0 02BC LDS	R31,k+1
    01586 9631      ADIW	R30,1
    01587 0FE8      ADD	R30,R24
    01588 1FF9      ADC	R31,R25
    01589 8020      LD	R2,Z
    0158A 2433      CLR	R3
    0158B 9040 02E1 LDS	R4,T_dat
    0158D 9050 02E2 LDS	R5,T_dat+1
    0158F 2842      OR	R4,R2
    01590 2853      OR	R5,R3
    01591 9250 02E2 STS	T_dat+1,R5
    01593 9240 02E1 STS	T_dat,R4
(1596) 							SendManchester();
    01595 D5F0      RCALL	_SendManchester
(1597) 							Delay_ms(40);
    01596 E208      LDI	R16,0x28
    01597 E010      LDI	R17,0
    01598 940E 05F4 CALL	_Delay_ms
    0159A 9180 02BB LDS	R24,k
    0159C 9190 02BC LDS	R25,k+1
    0159E 9602      ADIW	R24,2
    0159F 9390 02BC STS	k+1,R25
    015A1 9380 02BB STS	k,R24
    015A3 9180 02BB LDS	R24,k
    015A5 9190 02BC LDS	R25,k+1
    015A7 3088      CPI	R24,0x8
    015A8 E0E0      LDI	R30,0
    015A9 079E      CPC	R25,R30
    015AA F408      BCC	0x15AC
    015AB CFC2      RJMP	0x156E
(1598) 							}
(1599) 						}
    015AC C5CC      RJMP	0x1B79
(1600) 						else  if(R_dat>0xbb)//1800点提取,连续提取流量测试数据，4个通道分别提取，命令为0xBC-0xBF
    015AD EB8B      LDI	R24,0xBB
    015AE E090      LDI	R25,0
    015AF 9020 02DF LDS	R2,R_dat
    015B1 9030 02E0 LDS	R3,R_dat+1
    015B3 1582      CP	R24,R2
    015B4 0593      CPC	R25,R3
    015B5 F00C      BLT	0x15B7
    015B6 C5C2      RJMP	0x1B79
(1601) 						{   
(1602) 							Uart0TxData[0]=0xE8;
    015B7 EE88      LDI	R24,0xE8
    015B8 9380 012F STS	Uart0TxData,R24
(1603) 							Uart0TxData[1]=0x40;
    015BA E480      LDI	R24,0x40
    015BB 9380 0130 STS	Uart0TxData+1,R24
(1604) 							Uart0TxData[2]=R_dat;
    015BD 9220 0131 STS	Uart0TxData+2,R2
(1605) 							SendUart0_2(9,125);// 超时1秒
    015BF E72D      LDI	R18,0x7D
    015C0 E030      LDI	R19,0
    015C1 E009      LDI	R16,0x9
    015C2 940E 04EB CALL	_SendUart0_2
(1606) 							if((Uart0RxCounter==4)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x00)&&(Uart0RxData[2]==R_dat))//流量采样完毕并正确响应了
    015C4 9180 02FA LDS	R24,Uart0RxCounter
    015C6 3084      CPI	R24,4
    015C7 F009      BEQ	0x15C9
    015C8 C5B0      RJMP	0x1B79
    015C9 9180 02FB LDS	R24,Uart0RxData
    015CB 3585      CPI	R24,0x55
    015CC F009      BEQ	0x15CE
    015CD C5AB      RJMP	0x1B79
    015CE 9020 02FC LDS	R2,Uart0RxData+1
    015D0 2022      TST	R2
    015D1 F009      BEQ	0x15D3
    015D2 C5A6      RJMP	0x1B79
    015D3 9020 02DF LDS	R2,R_dat
    015D5 9030 02E0 LDS	R3,R_dat+1
    015D7 9040 02FD LDS	R4,Uart0RxData+2
    015D9 2455      CLR	R5
    015DA 1442      CP	R4,R2
    015DB 0453      CPC	R5,R3
    015DC F009      BEQ	0x15DE
    015DD C59B      RJMP	0x1B79
(1607) 							{
(1608) 							 for(k=0;k<1800;k++)//共1800帧数据，全部提取
    015DE 2422      CLR	R2
    015DF 2433      CLR	R3
    015E0 9230 02BC STS	k+1,R3
    015E2 9220 02BB STS	k,R2
    015E4 C036      RJMP	0x161B
(1609) 							 {
(1610) 							  Uart0TxData[0]=0xE8;
    015E5 EE88      LDI	R24,0xE8
    015E6 9380 012F STS	Uart0TxData,R24
(1611) 							  Uart0TxData[1]=0x40;
    015E8 E480      LDI	R24,0x40
    015E9 9380 0130 STS	Uart0TxData+1,R24
(1612) 							  Uart0TxData[2]=0xbb;//连续提取波形命令
    015EB EB8B      LDI	R24,0xBB
    015EC 9380 0131 STS	Uart0TxData+2,R24
(1613) 							  SendUart0_2(9,4);// 超时32ms 
    015EE E024      LDI	R18,4
    015EF E030      LDI	R19,0
    015F0 E009      LDI	R16,0x9
    015F1 940E 04EB CALL	_SendUart0_2
(1614) 							  T_dat=Uart0RxData[1];//应该返回2字节有效数据
    015F3 9020 02FC LDS	R2,Uart0RxData+1
    015F5 2433      CLR	R3
    015F6 9230 02E2 STS	T_dat+1,R3
    015F8 9220 02E1 STS	T_dat,R2
(1615) 							  T_dat<<=8;
    015FA 9020 02E1 LDS	R2,T_dat
    015FC 9030 02E2 LDS	R3,T_dat+1
    015FE 2C32      MOV	R3,R2
    015FF 2422      CLR	R2
    01600 9230 02E2 STS	T_dat+1,R3
    01602 9220 02E1 STS	T_dat,R2
(1616) 							  T_dat|=Uart0RxData[0];
    01604 9020 02FB LDS	R2,Uart0RxData
    01606 2433      CLR	R3
    01607 9040 02E1 LDS	R4,T_dat
    01609 9050 02E2 LDS	R5,T_dat+1
    0160B 2842      OR	R4,R2
    0160C 2853      OR	R5,R3
    0160D 9250 02E2 STS	T_dat+1,R5
    0160F 9240 02E1 STS	T_dat,R4
(1617) 							  SendManchester();
    01611 D574      RCALL	_SendManchester
    01612 9180 02BB LDS	R24,k
    01614 9190 02BC LDS	R25,k+1
    01616 9601      ADIW	R24,1
    01617 9390 02BC STS	k+1,R25
    01619 9380 02BB STS	k,R24
    0161B 9180 02BB LDS	R24,k
    0161D 9190 02BC LDS	R25,k+1
    0161F 3088      CPI	R24,0x8
    01620 E0E7      LDI	R30,7
    01621 079E      CPC	R25,R30
    01622 F210      BCS	0x15E5
(1618) 							 }
(1619) 						   }
(1620) 						} 
(1621) 						break;
    01623 C555      RJMP	0x1B79
(1622) 
(1623) 					case 0xc0://所有参数全采，上传16字节共8帧
(1624) 						if( (R_dat==0xc0) || (R_dat==0xcf) )
    01624 90C0 02DF LDS	R12,R_dat
    01626 90D0 02E0 LDS	R13,R_dat+1
    01628 01C6      MOVW	R24,R12
    01629 3C80      CPI	R24,0xC0
    0162A E0E0      LDI	R30,0
    0162B 079E      CPC	R25,R30
    0162C F029      BEQ	0x1632
    0162D 3C8F      CPI	R24,0xCF
    0162E E0E0      LDI	R30,0
    0162F 079E      CPC	R25,R30
    01630 F009      BEQ	0x1632
    01631 C374      RJMP	0x19A6
(1625) 						{
(1626) 							Uart0TxData[0]=0xE8;
    01632 EE88      LDI	R24,0xE8
    01633 9380 012F STS	Uart0TxData,R24
(1627) 							Uart0TxData[1]=0x40;
    01635 E480      LDI	R24,0x40
    01636 9380 0130 STS	Uart0TxData+1,R24
(1628) 							Uart0TxData[2]=0x89;
    01638 E889      LDI	R24,0x89
    01639 9380 0131 STS	Uart0TxData+2,R24
(1629) 							Uart0TxData[3]=9;
    0163B E089      LDI	R24,0x9
    0163C 9380 0132 STS	Uart0TxData+3,R24
(1630) 							SendUart0_2(9,50);//流量板直读检测，超时400ms
    0163E E322      LDI	R18,0x32
    0163F E030      LDI	R19,0
    01640 E009      LDI	R16,0x9
    01641 940E 04EB CALL	_SendUart0_2
(1631) 							//if(Uart0RxCounter==64)//成功接收到压力、温度、流量数据，先低字节后高字节
(1632) 							{
(1633) 								
(1634) 								if((Uart0RxCounter==16)&&(Uart0RxData[0]==0x55)&&(Uart0RxData[1]==0x0c)&&(Uart0RxData[2]==0x89))//绝对时间差法流量板，严格按帧格式返回16字节（含12字节有效数据）
    01643 9180 02FA LDS	R24,Uart0RxCounter
    01645 3180      CPI	R24,0x10
    01646 F009      BEQ	0x1648
    01647 C0EE      RJMP	0x1736
    01648 9180 02FB LDS	R24,Uart0RxData
    0164A 3585      CPI	R24,0x55
    0164B F009      BEQ	0x164D
    0164C C0E9      RJMP	0x1736
    0164D 9180 02FC LDS	R24,Uart0RxData+1
    0164F 308C      CPI	R24,0xC
    01650 F009      BEQ	0x1652
    01651 C0E4      RJMP	0x1736
    01652 9180 02FD LDS	R24,Uart0RxData+2
    01654 3889      CPI	R24,0x89
    01655 F009      BEQ	0x1657
    01656 C0DF      RJMP	0x1736
(1635) 								{
(1636) 								T_dat=Uart0RxData[4];
    01657 9020 02FF LDS	R2,Uart0RxData+4
    01659 2433      CLR	R3
    0165A 9230 02E2 STS	T_dat+1,R3
    0165C 9220 02E1 STS	T_dat,R2
(1637) 								T_dat<<=8;
    0165E 9020 02E1 LDS	R2,T_dat
    01660 9030 02E2 LDS	R3,T_dat+1
    01662 2C32      MOV	R3,R2
    01663 2422      CLR	R2
    01664 9230 02E2 STS	T_dat+1,R3
    01666 9220 02E1 STS	T_dat,R2
(1638) 								T_dat|=Uart0RxData[3];
    01668 9020 02FE LDS	R2,Uart0RxData+3
    0166A 2433      CLR	R3
    0166B 9040 02E1 LDS	R4,T_dat
    0166D 9050 02E2 LDS	R5,T_dat+1
    0166F 2842      OR	R4,R2
    01670 2853      OR	R5,R3
    01671 9250 02E2 STS	T_dat+1,R5
    01673 9240 02E1 STS	T_dat,R4
(1639) 								SendManchester();//压力
    01675 D510      RCALL	_SendManchester
(1640) 								crc16array[0]=(unsigned char)(T_dat);
    01676 9020 02E1 LDS	R2,T_dat
    01678 9030 02E2 LDS	R3,T_dat+1
    0167A 9220 0100 STS	crc16array,R2
(1641) 								crc16array[1]=(unsigned char)(T_dat>>8);
    0167C 2C23      MOV	R2,R3
    0167D 2433      CLR	R3
    0167E FC27      SBRC	R2,7
    0167F 9430      COM	R3
    01680 9220 0101 STS	crc16array+1,R2
(1642) 
(1643) 
(1644) 								Delay_ms(30);	
    01682 E10E      LDI	R16,0x1E
    01683 E010      LDI	R17,0
    01684 940E 05F4 CALL	_Delay_ms
(1645) 								T_dat=Uart0RxData[6];
    01686 9020 0301 LDS	R2,Uart0RxData+6
    01688 2433      CLR	R3
    01689 9230 02E2 STS	T_dat+1,R3
    0168B 9220 02E1 STS	T_dat,R2
(1646) 								T_dat<<=8;
    0168D 9020 02E1 LDS	R2,T_dat
    0168F 9030 02E2 LDS	R3,T_dat+1
    01691 2C32      MOV	R3,R2
    01692 2422      CLR	R2
    01693 9230 02E2 STS	T_dat+1,R3
    01695 9220 02E1 STS	T_dat,R2
(1647) 								T_dat|=Uart0RxData[5];
    01697 9020 0300 LDS	R2,Uart0RxData+5
    01699 2433      CLR	R3
    0169A 9040 02E1 LDS	R4,T_dat
    0169C 9050 02E2 LDS	R5,T_dat+1
    0169E 2842      OR	R4,R2
    0169F 2853      OR	R5,R3
    016A0 9250 02E2 STS	T_dat+1,R5
    016A2 9240 02E1 STS	T_dat,R4
(1648) 								SendManchester();//温度
    016A4 D4E1      RCALL	_SendManchester
(1649) 								crc16array[2]=(unsigned char)(T_dat);
    016A5 9020 02E1 LDS	R2,T_dat
    016A7 9030 02E2 LDS	R3,T_dat+1
    016A9 9220 0102 STS	crc16array+2,R2
(1650) 								crc16array[3]=(unsigned char)(T_dat>>8);
    016AB 2C23      MOV	R2,R3
    016AC 2433      CLR	R3
    016AD FC27      SBRC	R2,7
    016AE 9430      COM	R3
    016AF 9220 0103 STS	crc16array+3,R2
(1651) 
(1652) 								Delay_ms(30);	 
    016B1 E10E      LDI	R16,0x1E
    016B2 E010      LDI	R17,0
    016B3 940E 05F4 CALL	_Delay_ms
(1653) 								
(1654) 								//顺流时间，浮点数
(1655) 								myFIB.b[0]=Uart0RxData[7];
    016B5 9020 0302 LDS	R2,Uart0RxData+7
    016B7 9220 0348 STS	myFIB,R2
(1656) 								myFIB.b[1]=Uart0RxData[8];
    016B9 9020 0303 LDS	R2,Uart0RxData+8
    016BB 9220 0349 STS	myFIB+1,R2
(1657) 								myFIB.b[2]=Uart0RxData[9];
    016BD 9020 0304 LDS	R2,Uart0RxData+9
    016BF 9220 034A STS	myFIB+2,R2
(1658) 								myFIB.b[3]=Uart0RxData[10];
    016C1 9020 0305 LDS	R2,Uart0RxData+10
    016C3 9220 034B STS	myFIB+3,R2
(1659) 						 
(1660) 						        T_dat=myFIB.i[1];
    016C5 9020 034A LDS	R2,myFIB+2
    016C7 9030 034B LDS	R3,myFIB+3
    016C9 9230 02E2 STS	T_dat+1,R3
    016CB 9220 02E1 STS	T_dat,R2
(1661) 						        SendManchester();//顺流时间
    016CD D4B8      RCALL	_SendManchester
(1662) 								crc16array[4]=(unsigned char)(T_dat);
    016CE 9020 02E1 LDS	R2,T_dat
    016D0 9030 02E2 LDS	R3,T_dat+1
    016D2 9220 0104 STS	crc16array+4,R2
(1663) 								crc16array[5]=(unsigned char)(T_dat>>8);
    016D4 2C23      MOV	R2,R3
    016D5 2433      CLR	R3
    016D6 FC27      SBRC	R2,7
    016D7 9430      COM	R3
    016D8 9220 0105 STS	crc16array+5,R2
(1664) 
(1665) 								Delay_ms(30);	
    016DA E10E      LDI	R16,0x1E
    016DB E010      LDI	R17,0
    016DC 940E 05F4 CALL	_Delay_ms
(1666) 								T_dat=myFIB.i[0];
    016DE 9020 0348 LDS	R2,myFIB
    016E0 9030 0349 LDS	R3,myFIB+1
    016E2 9230 02E2 STS	T_dat+1,R3
    016E4 9220 02E1 STS	T_dat,R2
(1667) 								SendManchester();//顺流时间
    016E6 D49F      RCALL	_SendManchester
(1668) 								crc16array[6]=(unsigned char)(T_dat);
    016E7 9020 02E1 LDS	R2,T_dat
    016E9 9030 02E2 LDS	R3,T_dat+1
    016EB 9220 0106 STS	crc16array+6,R2
(1669) 								crc16array[7]=(unsigned char)(T_dat>>8);
    016ED 2C23      MOV	R2,R3
    016EE 2433      CLR	R3
    016EF FC27      SBRC	R2,7
    016F0 9430      COM	R3
    016F1 9220 0107 STS	crc16array+7,R2
(1670) 
(1671) 								Delay_ms(30);	
    016F3 E10E      LDI	R16,0x1E
    016F4 E010      LDI	R17,0
    016F5 940E 05F4 CALL	_Delay_ms
(1672) 
(1673) 								//逆流时间，浮点数
(1674) 								myFIB.b[0]=Uart0RxData[11];
    016F7 9020 0306 LDS	R2,Uart0RxData+11
    016F9 9220 0348 STS	myFIB,R2
(1675) 								myFIB.b[1]=Uart0RxData[12];
    016FB 9020 0307 LDS	R2,Uart0RxData+12
    016FD 9220 0349 STS	myFIB+1,R2
(1676) 								myFIB.b[2]=Uart0RxData[13];
    016FF 9020 0308 LDS	R2,Uart0RxData+13
    01701 9220 034A STS	myFIB+2,R2
(1677) 								myFIB.b[3]=Uart0RxData[14];
    01703 9020 0309 LDS	R2,Uart0RxData+14
    01705 9220 034B STS	myFIB+3,R2
(1678) 
(1679) 								T_dat=myFIB.i[1];
    01707 9020 034A LDS	R2,myFIB+2
    01709 9030 034B LDS	R3,myFIB+3
    0170B 9230 02E2 STS	T_dat+1,R3
    0170D 9220 02E1 STS	T_dat,R2
(1680) 								SendManchester();//逆流时间
    0170F D476      RCALL	_SendManchester
(1681) 								crc16array[8]=(unsigned char)(T_dat);
    01710 9020 02E1 LDS	R2,T_dat
    01712 9030 02E2 LDS	R3,T_dat+1
    01714 9220 0108 STS	crc16array+8,R2
(1682) 								crc16array[9]=(unsigned char)(T_dat>>8);
    01716 2C23      MOV	R2,R3
    01717 2433      CLR	R3
    01718 FC27      SBRC	R2,7
    01719 9430      COM	R3
    0171A 9220 0109 STS	crc16array+9,R2
(1683) 
(1684) 
(1685) 								Delay_ms(30);	
    0171C E10E      LDI	R16,0x1E
    0171D E010      LDI	R17,0
    0171E 940E 05F4 CALL	_Delay_ms
(1686) 								T_dat=myFIB.i[0];
    01720 9020 0348 LDS	R2,myFIB
    01722 9030 0349 LDS	R3,myFIB+1
    01724 9230 02E2 STS	T_dat+1,R3
    01726 9220 02E1 STS	T_dat,R2
(1687) 								SendManchester();//逆流时间
    01728 D45D      RCALL	_SendManchester
(1688) 								crc16array[10]=(unsigned char)(T_dat);
    01729 9020 02E1 LDS	R2,T_dat
    0172B 9030 02E2 LDS	R3,T_dat+1
    0172D 9220 010A STS	crc16array+10,R2
(1689) 								crc16array[11]=(unsigned char)(T_dat>>8);
    0172F 2C23      MOV	R2,R3
    01730 2433      CLR	R3
    01731 FC27      SBRC	R2,7
    01732 9430      COM	R3
    01733 9220 010B STS	crc16array+11,R2
(1690) 								}
    01735 C164      RJMP	0x189A
(1691) 						       else//常规流量计
(1692) 							    {
(1693) 								T_dat=Uart0RxData[1];
    01736 9020 02FC LDS	R2,Uart0RxData+1
    01738 2433      CLR	R3
    01739 9230 02E2 STS	T_dat+1,R3
    0173B 9220 02E1 STS	T_dat,R2
(1694) 								T_dat<<=8;
    0173D 9020 02E1 LDS	R2,T_dat
    0173F 9030 02E2 LDS	R3,T_dat+1
    01741 2C32      MOV	R3,R2
    01742 2422      CLR	R2
    01743 9230 02E2 STS	T_dat+1,R3
    01745 9220 02E1 STS	T_dat,R2
(1695) 								T_dat|=Uart0RxData[0];
    01747 9020 02FB LDS	R2,Uart0RxData
    01749 2433      CLR	R3
    0174A 9040 02E1 LDS	R4,T_dat
    0174C 9050 02E2 LDS	R5,T_dat+1
    0174E 2842      OR	R4,R2
    0174F 2853      OR	R5,R3
    01750 9250 02E2 STS	T_dat+1,R5
    01752 9240 02E1 STS	T_dat,R4
(1696) 								SendManchester();//压力
    01754 D431      RCALL	_SendManchester
(1697) 								crc16array[0]=(unsigned char)(T_dat);
    01755 9020 02E1 LDS	R2,T_dat
    01757 9030 02E2 LDS	R3,T_dat+1
    01759 9220 0100 STS	crc16array,R2
(1698) 								crc16array[1]=(unsigned char)(T_dat>>8);
    0175B 2C23      MOV	R2,R3
    0175C 2433      CLR	R3
    0175D FC27      SBRC	R2,7
    0175E 9430      COM	R3
    0175F 9220 0101 STS	crc16array+1,R2
(1699) 
(1700) 
(1701) 								Delay_ms(30);	
    01761 E10E      LDI	R16,0x1E
    01762 E010      LDI	R17,0
    01763 940E 05F4 CALL	_Delay_ms
(1702) 								T_dat=Uart0RxData[3];
    01765 9020 02FE LDS	R2,Uart0RxData+3
    01767 2433      CLR	R3
    01768 9230 02E2 STS	T_dat+1,R3
    0176A 9220 02E1 STS	T_dat,R2
(1703) 								T_dat<<=8;
    0176C 9020 02E1 LDS	R2,T_dat
    0176E 9030 02E2 LDS	R3,T_dat+1
    01770 2C32      MOV	R3,R2
    01771 2422      CLR	R2
    01772 9230 02E2 STS	T_dat+1,R3
    01774 9220 02E1 STS	T_dat,R2
(1704) 								T_dat|=Uart0RxData[2];
    01776 9020 02FD LDS	R2,Uart0RxData+2
    01778 2433      CLR	R3
    01779 9040 02E1 LDS	R4,T_dat
    0177B 9050 02E2 LDS	R5,T_dat+1
    0177D 2842      OR	R4,R2
    0177E 2853      OR	R5,R3
    0177F 9250 02E2 STS	T_dat+1,R5
    01781 9240 02E1 STS	T_dat,R4
(1705) 								SendManchester();//温度
    01783 D402      RCALL	_SendManchester
(1706) 								crc16array[2]=(unsigned char)(T_dat);
    01784 9020 02E1 LDS	R2,T_dat
    01786 9030 02E2 LDS	R3,T_dat+1
    01788 9220 0102 STS	crc16array+2,R2
(1707) 								crc16array[3]=(unsigned char)(T_dat>>8);
    0178A 2C23      MOV	R2,R3
    0178B 2433      CLR	R3
    0178C FC27      SBRC	R2,7
    0178D 9430      COM	R3
    0178E 9220 0103 STS	crc16array+3,R2
(1708) 
(1709) 								Delay_ms(30);	
    01790 E10E      LDI	R16,0x1E
    01791 E010      LDI	R17,0
    01792 940E 05F4 CALL	_Delay_ms
(1710) 								
(1711) 								lfib=Uart0RxData[5];
    01794 9020 0300 LDS	R2,Uart0RxData+5
    01796 2433      CLR	R3
    01797 2444      CLR	R4
    01798 2455      CLR	R5
    01799 9230 0123 STS	lfib+1,R3
    0179B 9220 0122 STS	lfib,R2
    0179D 9250 0125 STS	lfib+3,R5
    0179F 9240 0124 STS	lfib+2,R4
(1712) 								lfib<<=8;
    017A1 E088      LDI	R24,0x8
    017A2 E090      LDI	R25,0
    017A3 9120 0124 LDS	R18,lfib+2
    017A5 9130 0125 LDS	R19,lfib+3
    017A7 9100 0122 LDS	R16,lfib
    017A9 9110 0123 LDS	R17,lfib+1
    017AB 938A      ST	-Y,R24
    017AC 940E 2080 CALL	lsl32
    017AE 9310 0123 STS	lfib+1,R17
    017B0 9300 0122 STS	lfib,R16
    017B2 9330 0125 STS	lfib+3,R19
    017B4 9320 0124 STS	lfib+2,R18
(1713) 								lfib|=Uart0RxData[4];
    017B6 9020 02FF LDS	R2,Uart0RxData+4
    017B8 2433      CLR	R3
    017B9 2444      CLR	R4
    017BA 2455      CLR	R5
    017BB 0138      MOVW	R6,R16
    017BC 0149      MOVW	R8,R18
    017BD 2862      OR	R6,R2
    017BE 2873      OR	R7,R3
    017BF 2884      OR	R8,R4
    017C0 2895      OR	R9,R5
    017C1 9270 0123 STS	lfib+1,R7
    017C3 9260 0122 STS	lfib,R6
    017C5 9290 0125 STS	lfib+3,R9
    017C7 9280 0124 STS	lfib+2,R8
(1714) 								lfib&=0x0000ffff;
    017C9 EF4F      LDI	R20,0xFF
    017CA EF5F      LDI	R21,0xFF
    017CB E060      LDI	R22,0
    017CC E070      LDI	R23,0
    017CD 0113      MOVW	R2,R6
    017CE 0124      MOVW	R4,R8
    017CF 2224      AND	R2,R20
    017D0 2235      AND	R3,R21
    017D1 2246      AND	R4,R22
    017D2 2257      AND	R5,R23
    017D3 9230 0123 STS	lfib+1,R3
    017D5 9220 0122 STS	lfib,R2
    017D7 9250 0125 STS	lfib+3,R5
    017D9 9240 0124 STS	lfib+2,R4
(1715) 								myFIB.f=(unsigned long)lfib; 
    017DB 0181      MOVW	R16,R2
    017DC 0192      MOVW	R18,R4
    017DD 940E 20E2 CALL	ulong2fp
    017DF 9310 0349 STS	myFIB+1,R17
    017E1 9300 0348 STS	myFIB,R16
    017E3 9330 034B STS	myFIB+3,R19
    017E5 9320 034A STS	myFIB+2,R18
(1716) 
(1717) 								T_dat=myFIB.i[1];
    017E7 9020 034A LDS	R2,myFIB+2
    017E9 9030 034B LDS	R3,myFIB+3
    017EB 9230 02E2 STS	T_dat+1,R3
    017ED 9220 02E1 STS	T_dat,R2
(1718) 								SendManchester();//流量-时间1
    017EF D396      RCALL	_SendManchester
(1719) 								crc16array[4]=(unsigned char)(T_dat);
    017F0 9020 02E1 LDS	R2,T_dat
    017F2 9030 02E2 LDS	R3,T_dat+1
    017F4 9220 0104 STS	crc16array+4,R2
(1720) 								crc16array[5]=(unsigned char)(T_dat>>8);
    017F6 2C23      MOV	R2,R3
    017F7 2433      CLR	R3
    017F8 FC27      SBRC	R2,7
    017F9 9430      COM	R3
    017FA 9220 0105 STS	crc16array+5,R2
(1721) 
(1722) 								Delay_ms(30);	
    017FC E10E      LDI	R16,0x1E
    017FD E010      LDI	R17,0
    017FE 940E 05F4 CALL	_Delay_ms
(1723) 								T_dat=myFIB.i[0];
    01800 9020 0348 LDS	R2,myFIB
    01802 9030 0349 LDS	R3,myFIB+1
    01804 9230 02E2 STS	T_dat+1,R3
    01806 9220 02E1 STS	T_dat,R2
(1724) 								SendManchester();//流量-时间2
    01808 D37D      RCALL	_SendManchester
(1725) 								crc16array[6]=(unsigned char)(T_dat);
    01809 9020 02E1 LDS	R2,T_dat
    0180B 9030 02E2 LDS	R3,T_dat+1
    0180D 9220 0106 STS	crc16array+6,R2
(1726) 								crc16array[7]=(unsigned char)(T_dat>>8);
    0180F 2C23      MOV	R2,R3
    01810 2433      CLR	R3
    01811 FC27      SBRC	R2,7
    01812 9430      COM	R3
    01813 9220 0107 STS	crc16array+7,R2
(1727) 
(1728) 								Delay_ms(30);	
    01815 E10E      LDI	R16,0x1E
    01816 E010      LDI	R17,0
    01817 940E 05F4 CALL	_Delay_ms
(1729) 
(1730) 								lfib=Uart0RxData[7];
    01819 9020 0302 LDS	R2,Uart0RxData+7
    0181B 2433      CLR	R3
    0181C 2444      CLR	R4
    0181D 2455      CLR	R5
    0181E 9230 0123 STS	lfib+1,R3
    01820 9220 0122 STS	lfib,R2
    01822 9250 0125 STS	lfib+3,R5
    01824 9240 0124 STS	lfib+2,R4
(1731) 								lfib<<=8;
    01826 E088      LDI	R24,0x8
    01827 E090      LDI	R25,0
    01828 9120 0124 LDS	R18,lfib+2
    0182A 9130 0125 LDS	R19,lfib+3
    0182C 9100 0122 LDS	R16,lfib
    0182E 9110 0123 LDS	R17,lfib+1
    01830 938A      ST	-Y,R24
    01831 940E 2080 CALL	lsl32
    01833 9310 0123 STS	lfib+1,R17
    01835 9300 0122 STS	lfib,R16
    01837 9330 0125 STS	lfib+3,R19
    01839 9320 0124 STS	lfib+2,R18
(1732) 								lfib|=Uart0RxData[6];
    0183B 9020 0301 LDS	R2,Uart0RxData+6
    0183D 2433      CLR	R3
    0183E 2444      CLR	R4
    0183F 2455      CLR	R5
    01840 0138      MOVW	R6,R16
    01841 0149      MOVW	R8,R18
    01842 2862      OR	R6,R2
    01843 2873      OR	R7,R3
    01844 2884      OR	R8,R4
    01845 2895      OR	R9,R5
    01846 9270 0123 STS	lfib+1,R7
    01848 9260 0122 STS	lfib,R6
    0184A 9290 0125 STS	lfib+3,R9
    0184C 9280 0124 STS	lfib+2,R8
(1733) 								lfib&=0x0000ffff;
    0184E EF4F      LDI	R20,0xFF
    0184F EF5F      LDI	R21,0xFF
    01850 E060      LDI	R22,0
    01851 E070      LDI	R23,0
    01852 0113      MOVW	R2,R6
    01853 0124      MOVW	R4,R8
    01854 2224      AND	R2,R20
    01855 2235      AND	R3,R21
    01856 2246      AND	R4,R22
    01857 2257      AND	R5,R23
    01858 9230 0123 STS	lfib+1,R3
    0185A 9220 0122 STS	lfib,R2
    0185C 9250 0125 STS	lfib+3,R5
    0185E 9240 0124 STS	lfib+2,R4
(1734) 								myFIB.f=(unsigned long)lfib; 
    01860 0181      MOVW	R16,R2
    01861 0192      MOVW	R18,R4
    01862 940E 20E2 CALL	ulong2fp
    01864 9310 0349 STS	myFIB+1,R17
    01866 9300 0348 STS	myFIB,R16
    01868 9330 034B STS	myFIB+3,R19
    0186A 9320 034A STS	myFIB+2,R18
(1735) 
(1736) 								T_dat=myFIB.i[1];
    0186C 9020 034A LDS	R2,myFIB+2
    0186E 9030 034B LDS	R3,myFIB+3
    01870 9230 02E2 STS	T_dat+1,R3
    01872 9220 02E1 STS	T_dat,R2
(1737) 								SendManchester();//流量-相位1
    01874 D311      RCALL	_SendManchester
(1738) 								crc16array[8]=(unsigned char)(T_dat);
    01875 9020 02E1 LDS	R2,T_dat
    01877 9030 02E2 LDS	R3,T_dat+1
    01879 9220 0108 STS	crc16array+8,R2
(1739) 								crc16array[9]=(unsigned char)(T_dat>>8);
    0187B 2C23      MOV	R2,R3
    0187C 2433      CLR	R3
    0187D FC27      SBRC	R2,7
    0187E 9430      COM	R3
    0187F 9220 0109 STS	crc16array+9,R2
(1740) 
(1741) 								Delay_ms(30);	
    01881 E10E      LDI	R16,0x1E
    01882 E010      LDI	R17,0
    01883 940E 05F4 CALL	_Delay_ms
(1742) 								T_dat=myFIB.i[0];
    01885 9020 0348 LDS	R2,myFIB
    01887 9030 0349 LDS	R3,myFIB+1
    01889 9230 02E2 STS	T_dat+1,R3
    0188B 9220 02E1 STS	T_dat,R2
(1743) 								SendManchester();//流量-相位2
    0188D D2F8      RCALL	_SendManchester
(1744) 								crc16array[10]=(unsigned char)(T_dat);
    0188E 9020 02E1 LDS	R2,T_dat
    01890 9030 02E2 LDS	R3,T_dat+1
    01892 9220 010A STS	crc16array+10,R2
(1745) 								crc16array[11]=(unsigned char)(T_dat>>8);
    01894 2C23      MOV	R2,R3
    01895 2433      CLR	R3
    01896 FC27      SBRC	R2,7
    01897 9430      COM	R3
    01898 9220 010B STS	crc16array+11,R2
(1746) 								}
(1747) 
(1748) 								 
(1749) 								SendUart1(0x81,4);//电机状态，32ms超时
    0189A E024      LDI	R18,4
    0189B E030      LDI	R19,0
    0189C E801      LDI	R16,0x81
    0189D 940E 02B3 CALL	_SendUart1
(1750) 								
(1751) 							    T_dat=Uart1RxData[1];
    0189F 9020 02F7 LDS	R2,Uart1RxData+1
    018A1 2433      CLR	R3
    018A2 9230 02E2 STS	T_dat+1,R3
    018A4 9220 02E1 STS	T_dat,R2
(1752) 						        T_dat<<=8;
    018A6 9020 02E1 LDS	R2,T_dat
    018A8 9030 02E2 LDS	R3,T_dat+1
    018AA 2C32      MOV	R3,R2
    018AB 2422      CLR	R2
    018AC 9230 02E2 STS	T_dat+1,R3
    018AE 9220 02E1 STS	T_dat,R2
(1753) 						        T_dat|=Uart1RxData[0];						 
    018B0 9020 02F6 LDS	R2,Uart1RxData
    018B2 2433      CLR	R3
    018B3 9040 02E1 LDS	R4,T_dat
    018B5 9050 02E2 LDS	R5,T_dat+1
    018B7 2842      OR	R4,R2
    018B8 2853      OR	R5,R3
    018B9 9250 02E2 STS	T_dat+1,R5
    018BB 9240 02E1 STS	T_dat,R4
(1754) 								SendManchester();//收放电机状态
    018BD D2C8      RCALL	_SendManchester
(1755) 								crc16array[12]=(unsigned char)(T_dat);
    018BE 9020 02E1 LDS	R2,T_dat
    018C0 9030 02E2 LDS	R3,T_dat+1
    018C2 9220 010C STS	crc16array+12,R2
(1756) 								crc16array[13]=(unsigned char)(T_dat>>8);
    018C4 2C23      MOV	R2,R3
    018C5 2433      CLR	R3
    018C6 FC27      SBRC	R2,7
    018C7 9430      COM	R3
    018C8 9220 010D STS	crc16array+13,R2
(1757) 
(1758) 								Delay_ms(30);	 
    018CA E10E      LDI	R16,0x1E
    018CB E010      LDI	R17,0
    018CC 940E 05F4 CALL	_Delay_ms
(1759) 								T_dat=Uart1RxData[3];
    018CE 9020 02F9 LDS	R2,Uart1RxData+3
    018D0 2433      CLR	R3
    018D1 9230 02E2 STS	T_dat+1,R3
    018D3 9220 02E1 STS	T_dat,R2
(1760) 						        T_dat<<=8;
    018D5 9020 02E1 LDS	R2,T_dat
    018D7 9030 02E2 LDS	R3,T_dat+1
    018D9 2C32      MOV	R3,R2
    018DA 2422      CLR	R2
    018DB 9230 02E2 STS	T_dat+1,R3
    018DD 9220 02E1 STS	T_dat,R2
(1761) 						        T_dat|=Uart1RxData[2];
    018DF 9020 02F8 LDS	R2,Uart1RxData+2
    018E1 2433      CLR	R3
    018E2 9040 02E1 LDS	R4,T_dat
    018E4 9050 02E2 LDS	R5,T_dat+1
    018E6 2842      OR	R4,R2
    018E7 2853      OR	R5,R3
    018E8 9250 02E2 STS	T_dat+1,R5
    018EA 9240 02E1 STS	T_dat,R4
(1762) 								SendManchester();//调节电机状态
    018EC D299      RCALL	_SendManchester
(1763) 								crc16array[14]=(unsigned char)(T_dat);
    018ED 9020 02E1 LDS	R2,T_dat
    018EF 9030 02E2 LDS	R3,T_dat+1
    018F1 9220 010E STS	crc16array+14,R2
(1764) 								crc16array[15]=(unsigned char)(T_dat>>8);
    018F3 2C23      MOV	R2,R3
    018F4 2433      CLR	R3
    018F5 FC27      SBRC	R2,7
    018F6 9430      COM	R3
    018F7 9220 010F STS	crc16array+15,R2
(1765) 
(1766) 								Delay_ms(1);	  					
    018F9 E001      LDI	R16,1
    018FA E010      LDI	R17,0
    018FB 940E 05F4 CALL	_Delay_ms
(1767) 						        SendUart1(0x31,4);//读电机电压，32ms超时
    018FD E024      LDI	R18,4
    018FE E030      LDI	R19,0
    018FF E301      LDI	R16,0x31
    01900 940E 02B3 CALL	_SendUart1
(1768) 						        T_dat=Uart1RxData[0];
    01902 9020 02F6 LDS	R2,Uart1RxData
    01904 2433      CLR	R3
    01905 9230 02E2 STS	T_dat+1,R3
    01907 9220 02E1 STS	T_dat,R2
(1769) 								SendManchester();
    01909 D27C      RCALL	_SendManchester
(1770) 								crc16array[16]=(unsigned char)(T_dat);
    0190A 9020 02E1 LDS	R2,T_dat
    0190C 9030 02E2 LDS	R3,T_dat+1
    0190E 9220 0110 STS	crc16array+16,R2
(1771) 								crc16array[17]=(unsigned char)(T_dat>>8);
    01910 2C23      MOV	R2,R3
    01911 2433      CLR	R3
    01912 FC27      SBRC	R2,7
    01913 9430      COM	R3
    01914 9220 0111 STS	crc16array+17,R2
(1772) 
(1773) 								if(R_dat==0xcf)// 采集第2个压力温度的工程量，再多发2帧共4字节
    01916 9180 02DF LDS	R24,R_dat
    01918 9190 02E0 LDS	R25,R_dat+1
    0191A 3C8F      CPI	R24,0xCF
    0191B E0E0      LDI	R30,0
    0191C 079E      CPC	R25,R30
    0191D F009      BEQ	0x191F
    0191E C05E      RJMP	0x197D
(1774) 								{
(1775) 						  		 SampleTPS(R_dat);//正常情况下10ms返回，不挂压力短节的话20*4=80ms超时后返回
    0191F 018C      MOVW	R16,R24
    01920 940E 0455 CALL	_SampleTPS
(1776) 						  
(1777) 						  		 Delay_ms(25);	
    01922 E109      LDI	R16,0x19
    01923 E010      LDI	R17,0
    01924 940E 05F4 CALL	_Delay_ms
(1778) 						  		 T_dat=TPS_PData;
    01926 9020 02DD LDS	R2,TPS_PData
    01928 9030 02DE LDS	R3,TPS_PData+1
    0192A 9230 02E2 STS	T_dat+1,R3
    0192C 9220 02E1 STS	T_dat,R2
(1779) 						  		 SendManchester();//压力
    0192E D257      RCALL	_SendManchester
(1780) 								 crc16array[18]=(unsigned char)(T_dat);
    0192F 9020 02E1 LDS	R2,T_dat
    01931 9030 02E2 LDS	R3,T_dat+1
    01933 9220 0112 STS	crc16array+18,R2
(1781) 								 crc16array[19]=(unsigned char)(T_dat>>8);
    01935 2C23      MOV	R2,R3
    01936 2433      CLR	R3
    01937 FC27      SBRC	R2,7
    01938 9430      COM	R3
    01939 9220 0113 STS	crc16array+19,R2
(1782) 						  
(1783) 						  		 Delay_ms(30);	
    0193B E10E      LDI	R16,0x1E
    0193C E010      LDI	R17,0
    0193D 940E 05F4 CALL	_Delay_ms
(1784) 						  		 T_dat=TPS_TData;
    0193F 9020 02DB LDS	R2,TPS_TData
    01941 9030 02DC LDS	R3,TPS_TData+1
    01943 9230 02E2 STS	T_dat+1,R3
    01945 9220 02E1 STS	T_dat,R2
(1785) 						  		 SendManchester();//温度
    01947 D23E      RCALL	_SendManchester
(1786) 								 crc16array[20]=(unsigned char)(T_dat);
    01948 9020 02E1 LDS	R2,T_dat
    0194A 9030 02E2 LDS	R3,T_dat+1
    0194C 9220 0114 STS	crc16array+20,R2
(1787) 								 crc16array[21]=(unsigned char)(T_dat>>8);
    0194E 2C23      MOV	R2,R3
    0194F 2433      CLR	R3
    01950 FC27      SBRC	R2,7
    01951 9430      COM	R3
    01952 9220 0115 STS	crc16array+21,R2
(1788) 								 
(1789) 								 Delay_ms(30);	
    01954 E10E      LDI	R16,0x1E
    01955 E010      LDI	R17,0
    01956 940E 05F4 CALL	_Delay_ms
(1790) 								 crc16(crc16array,22);//0.75ms
    01958 E126      LDI	R18,0x16
    01959 E030      LDI	R19,0
    0195A E000      LDI	R16,0
    0195B E011      LDI	R17,1
    0195C D671      RCALL	_crc16
(1791) 								 T_dat=crc16hi;
    0195D 9020 0121 LDS	R2,crc16hi
    0195F 2433      CLR	R3
    01960 9230 02E2 STS	T_dat+1,R3
    01962 9220 02E1 STS	T_dat,R2
(1792) 								 T_dat<<=8;
    01964 9020 02E1 LDS	R2,T_dat
    01966 9030 02E2 LDS	R3,T_dat+1
    01968 2C32      MOV	R3,R2
    01969 2422      CLR	R2
    0196A 9230 02E2 STS	T_dat+1,R3
    0196C 9220 02E1 STS	T_dat,R2
(1793) 								 T_dat|=crc16lo;	  
    0196E 9020 0120 LDS	R2,crc16lo
    01970 2433      CLR	R3
    01971 9040 02E1 LDS	R4,T_dat
    01973 9050 02E2 LDS	R5,T_dat+1
    01975 2842      OR	R4,R2
    01976 2853      OR	R5,R3
    01977 9250 02E2 STS	T_dat+1,R5
    01979 9240 02E1 STS	T_dat,R4
(1794) 								 SendManchester();//上传CRC校验共2字节，从收到命令到上传完毕共耗时约850ms
    0197B D20A      RCALL	_SendManchester
(1795) 								}
    0197C C1FC      RJMP	0x1B79
(1796) 								else
(1797) 								{
(1798) 								 Delay_ms(30);	
    0197D E10E      LDI	R16,0x1E
    0197E E010      LDI	R17,0
    0197F 940E 05F4 CALL	_Delay_ms
(1799) 								 crc16(crc16array,18);//0.75ms
    01981 E122      LDI	R18,0x12
    01982 E030      LDI	R19,0
    01983 E000      LDI	R16,0
    01984 E011      LDI	R17,1
    01985 D648      RCALL	_crc16
(1800) 								 T_dat=crc16hi;
    01986 9020 0121 LDS	R2,crc16hi
    01988 2433      CLR	R3
    01989 9230 02E2 STS	T_dat+1,R3
    0198B 9220 02E1 STS	T_dat,R2
(1801) 								 T_dat<<=8;
    0198D 9020 02E1 LDS	R2,T_dat
    0198F 9030 02E2 LDS	R3,T_dat+1
    01991 2C32      MOV	R3,R2
    01992 2422      CLR	R2
    01993 9230 02E2 STS	T_dat+1,R3
    01995 9220 02E1 STS	T_dat,R2
(1802) 								 T_dat|=crc16lo;	  
    01997 9020 0120 LDS	R2,crc16lo
    01999 2433      CLR	R3
    0199A 9040 02E1 LDS	R4,T_dat
    0199C 9050 02E2 LDS	R5,T_dat+1
    0199E 2842      OR	R4,R2
    0199F 2853      OR	R5,R3
    019A0 9250 02E2 STS	T_dat+1,R5
    019A2 9240 02E1 STS	T_dat,R4
(1803) 								 SendManchester();//上传CRC校验共2字节，从收到命令到上传完毕共耗时约760ms
    019A4 D1E1      RCALL	_SendManchester
(1804) 								}
(1805) 							}	
(1806) 						}
    019A5 C1D3      RJMP	0x1B79
(1807) 						else  if(R_dat==0xc5) //读仪器信息,共320字节，分5次从流量板中提取，每包64字节
    019A6 9180 02DF LDS	R24,R_dat
    019A8 9190 02E0 LDS	R25,R_dat+1
    019AA 3C85      CPI	R24,0xC5
    019AB E0E0      LDI	R30,0
    019AC 079E      CPC	R25,R30
    019AD F009      BEQ	0x19AF
    019AE C16A      RJMP	0x1B19
(1808) 						{
(1809) 							Uart0TxData[0]=0xE8;
    019AF EE88      LDI	R24,0xE8
    019B0 9380 012F STS	Uart0TxData,R24
(1810) 							Uart0TxData[1]=0x40;
    019B2 E480      LDI	R24,0x40
    019B3 9380 0130 STS	Uart0TxData+1,R24
(1811) 							Uart0TxData[2]=0x83;
    019B5 E883      LDI	R24,0x83
    019B6 9380 0131 STS	Uart0TxData+2,R24
(1812) 							Uart0TxData[3]=0;//包0
    019B8 2422      CLR	R2
    019B9 9220 0132 STS	Uart0TxData+3,R2
(1813) 							SendUart0_2(9,5);// 超时40ms	
    019BB E025      LDI	R18,5
    019BC E030      LDI	R19,0
    019BD E009      LDI	R16,0x9
    019BE 940E 04EB CALL	_SendUart0_2
(1814) 							if(Uart0RxCounter==64) 
    019C0 9180 02FA LDS	R24,Uart0RxCounter
    019C2 3480      CPI	R24,0x40
    019C3 F599      BNE	0x19F7
(1815) 							{
(1816) 								for(i=0;i<32;i++)
    019C4 24AA      CLR	R10
    019C5 C02E      RJMP	0x19F4
(1817) 								{
(1818) 									Delay_ms(20);
    019C6 E104      LDI	R16,0x14
    019C7 E010      LDI	R17,0
    019C8 940E 05F4 CALL	_Delay_ms
(1819) 									T_dat=Uart0RxData[i*2+1];//高字节
    019CA EF8C      LDI	R24,0xFC
    019CB E092      LDI	R25,2
    019CC 2DEA      MOV	R30,R10
    019CD 27FF      CLR	R31
    019CE 0FEE      LSL	R30
    019CF 1FFF      ROL	R31
    019D0 0FE8      ADD	R30,R24
    019D1 1FF9      ADC	R31,R25
    019D2 8020      LD	R2,Z
    019D3 2433      CLR	R3
    019D4 9230 02E2 STS	T_dat+1,R3
    019D6 9220 02E1 STS	T_dat,R2
(1820) 									T_dat<<=8;
    019D8 2C32      MOV	R3,R2
    019D9 2422      CLR	R2
    019DA 9230 02E2 STS	T_dat+1,R3
    019DC 9220 02E1 STS	T_dat,R2
(1821) 									T_dat|=Uart0RxData[i*2+0];//低字节
    019DE EF8B      LDI	R24,0xFB
    019DF E092      LDI	R25,2
    019E0 2DEA      MOV	R30,R10
    019E1 27FF      CLR	R31
    019E2 0FEE      LSL	R30
    019E3 1FFF      ROL	R31
    019E4 0FE8      ADD	R30,R24
    019E5 1FF9      ADC	R31,R25
    019E6 8020      LD	R2,Z
    019E7 2433      CLR	R3
    019E8 9040 02E1 LDS	R4,T_dat
    019EA 9050 02E2 LDS	R5,T_dat+1
    019EC 2842      OR	R4,R2
    019ED 2853      OR	R5,R3
    019EE 9250 02E2 STS	T_dat+1,R5
    019F0 9240 02E1 STS	T_dat,R4
(1822) 									SendManchester();		 
    019F2 D193      RCALL	_SendManchester
    019F3 94A3      INC	R10
    019F4 2D8A      MOV	R24,R10
    019F5 3280      CPI	R24,0x20
    019F6 F278      BCS	0x19C6
(1823) 								}	
(1824) 							}	
(1825) 
(1826) 							Uart0TxData[0]=0xE8;
    019F7 EE88      LDI	R24,0xE8
    019F8 9380 012F STS	Uart0TxData,R24
(1827) 							Uart0TxData[1]=0x40;
    019FA E480      LDI	R24,0x40
    019FB 9380 0130 STS	Uart0TxData+1,R24
(1828) 							Uart0TxData[2]=0x83;
    019FD E883      LDI	R24,0x83
    019FE 9380 0131 STS	Uart0TxData+2,R24
(1829) 							Uart0TxData[3]=1;//包1
    01A00 E081      LDI	R24,1
    01A01 9380 0132 STS	Uart0TxData+3,R24
(1830) 							SendUart0_2(9,5);// 超时40ms	 
    01A03 E025      LDI	R18,5
    01A04 E030      LDI	R19,0
    01A05 E009      LDI	R16,0x9
    01A06 940E 04EB CALL	_SendUart0_2
(1831) 							if(Uart0RxCounter==64) 
    01A08 9180 02FA LDS	R24,Uart0RxCounter
    01A0A 3480      CPI	R24,0x40
    01A0B F599      BNE	0x1A3F
(1832) 							{
(1833) 								for(i=0;i<32;i++)
    01A0C 24AA      CLR	R10
    01A0D C02E      RJMP	0x1A3C
(1834) 								{
(1835) 									T_dat=Uart0RxData[i*2+1];//高字节
    01A0E EF8C      LDI	R24,0xFC
    01A0F E092      LDI	R25,2
    01A10 2DEA      MOV	R30,R10
    01A11 27FF      CLR	R31
    01A12 0FEE      LSL	R30
    01A13 1FFF      ROL	R31
    01A14 0FE8      ADD	R30,R24
    01A15 1FF9      ADC	R31,R25
    01A16 8020      LD	R2,Z
    01A17 2433      CLR	R3
    01A18 9230 02E2 STS	T_dat+1,R3
    01A1A 9220 02E1 STS	T_dat,R2
(1836) 									T_dat<<=8;
    01A1C 2C32      MOV	R3,R2
    01A1D 2422      CLR	R2
    01A1E 9230 02E2 STS	T_dat+1,R3
    01A20 9220 02E1 STS	T_dat,R2
(1837) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01A22 EF8B      LDI	R24,0xFB
    01A23 E092      LDI	R25,2
    01A24 2DEA      MOV	R30,R10
    01A25 27FF      CLR	R31
    01A26 0FEE      LSL	R30
    01A27 1FFF      ROL	R31
    01A28 0FE8      ADD	R30,R24
    01A29 1FF9      ADC	R31,R25
    01A2A 8020      LD	R2,Z
    01A2B 2433      CLR	R3
    01A2C 9040 02E1 LDS	R4,T_dat
    01A2E 9050 02E2 LDS	R5,T_dat+1
    01A30 2842      OR	R4,R2
    01A31 2853      OR	R5,R3
    01A32 9250 02E2 STS	T_dat+1,R5
    01A34 9240 02E1 STS	T_dat,R4
(1838) 									SendManchester();
    01A36 D14F      RCALL	_SendManchester
(1839) 									Delay_ms(20);
    01A37 E104      LDI	R16,0x14
    01A38 E010      LDI	R17,0
    01A39 940E 05F4 CALL	_Delay_ms
    01A3B 94A3      INC	R10
    01A3C 2D8A      MOV	R24,R10
    01A3D 3280      CPI	R24,0x20
    01A3E F278      BCS	0x1A0E
(1840) 								}
(1841) 							}	
(1842) 
(1843) 							Uart0TxData[0]=0xE8;
    01A3F EE88      LDI	R24,0xE8
    01A40 9380 012F STS	Uart0TxData,R24
(1844) 							Uart0TxData[1]=0x40;
    01A42 E480      LDI	R24,0x40
    01A43 9380 0130 STS	Uart0TxData+1,R24
(1845) 							Uart0TxData[2]=0x83;
    01A45 E883      LDI	R24,0x83
    01A46 9380 0131 STS	Uart0TxData+2,R24
(1846) 							Uart0TxData[3]=2;//包2
    01A48 E082      LDI	R24,2
    01A49 9380 0132 STS	Uart0TxData+3,R24
(1847) 							SendUart0_2(9,5);// 超时40ms	 
    01A4B E025      LDI	R18,5
    01A4C E030      LDI	R19,0
    01A4D E009      LDI	R16,0x9
    01A4E 940E 04EB CALL	_SendUart0_2
(1848) 							if(Uart0RxCounter==64) 
    01A50 9180 02FA LDS	R24,Uart0RxCounter
    01A52 3480      CPI	R24,0x40
    01A53 F599      BNE	0x1A87
(1849) 							{
(1850) 								for(i=0;i<32;i++)
    01A54 24AA      CLR	R10
    01A55 C02E      RJMP	0x1A84
(1851) 								{
(1852) 									T_dat=Uart0RxData[i*2+1];//高字节
    01A56 EF8C      LDI	R24,0xFC
    01A57 E092      LDI	R25,2
    01A58 2DEA      MOV	R30,R10
    01A59 27FF      CLR	R31
    01A5A 0FEE      LSL	R30
    01A5B 1FFF      ROL	R31
    01A5C 0FE8      ADD	R30,R24
    01A5D 1FF9      ADC	R31,R25
    01A5E 8020      LD	R2,Z
    01A5F 2433      CLR	R3
    01A60 9230 02E2 STS	T_dat+1,R3
    01A62 9220 02E1 STS	T_dat,R2
(1853) 									T_dat<<=8;
    01A64 2C32      MOV	R3,R2
    01A65 2422      CLR	R2
    01A66 9230 02E2 STS	T_dat+1,R3
    01A68 9220 02E1 STS	T_dat,R2
(1854) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01A6A EF8B      LDI	R24,0xFB
    01A6B E092      LDI	R25,2
    01A6C 2DEA      MOV	R30,R10
    01A6D 27FF      CLR	R31
    01A6E 0FEE      LSL	R30
    01A6F 1FFF      ROL	R31
    01A70 0FE8      ADD	R30,R24
    01A71 1FF9      ADC	R31,R25
    01A72 8020      LD	R2,Z
    01A73 2433      CLR	R3
    01A74 9040 02E1 LDS	R4,T_dat
    01A76 9050 02E2 LDS	R5,T_dat+1
    01A78 2842      OR	R4,R2
    01A79 2853      OR	R5,R3
    01A7A 9250 02E2 STS	T_dat+1,R5
    01A7C 9240 02E1 STS	T_dat,R4
(1855) 									SendManchester();
    01A7E D107      RCALL	_SendManchester
(1856) 									Delay_ms(20);
    01A7F E104      LDI	R16,0x14
    01A80 E010      LDI	R17,0
    01A81 940E 05F4 CALL	_Delay_ms
    01A83 94A3      INC	R10
    01A84 2D8A      MOV	R24,R10
    01A85 3280      CPI	R24,0x20
    01A86 F278      BCS	0x1A56
(1857) 								}
(1858) 							}	
(1859) 
(1860) 							Uart0TxData[0]=0xE8;
    01A87 EE88      LDI	R24,0xE8
    01A88 9380 012F STS	Uart0TxData,R24
(1861) 							Uart0TxData[1]=0x40;
    01A8A E480      LDI	R24,0x40
    01A8B 9380 0130 STS	Uart0TxData+1,R24
(1862) 							Uart0TxData[2]=0x83;
    01A8D E883      LDI	R24,0x83
    01A8E 9380 0131 STS	Uart0TxData+2,R24
(1863) 							Uart0TxData[3]=3;//包3
    01A90 E083      LDI	R24,3
    01A91 9380 0132 STS	Uart0TxData+3,R24
(1864) 							SendUart0_2(9,5);// 超时40ms	 
    01A93 E025      LDI	R18,5
    01A94 E030      LDI	R19,0
    01A95 E009      LDI	R16,0x9
    01A96 940E 04EB CALL	_SendUart0_2
(1865) 							if(Uart0RxCounter==64) 
    01A98 9180 02FA LDS	R24,Uart0RxCounter
    01A9A 3480      CPI	R24,0x40
    01A9B F599      BNE	0x1ACF
(1866) 							{
(1867) 								for(i=0;i<32;i++)
    01A9C 24AA      CLR	R10
    01A9D C02E      RJMP	0x1ACC
(1868) 								{
(1869) 									T_dat=Uart0RxData[i*2+1];//高字节
    01A9E EF8C      LDI	R24,0xFC
    01A9F E092      LDI	R25,2
    01AA0 2DEA      MOV	R30,R10
    01AA1 27FF      CLR	R31
    01AA2 0FEE      LSL	R30
    01AA3 1FFF      ROL	R31
    01AA4 0FE8      ADD	R30,R24
    01AA5 1FF9      ADC	R31,R25
    01AA6 8020      LD	R2,Z
    01AA7 2433      CLR	R3
    01AA8 9230 02E2 STS	T_dat+1,R3
    01AAA 9220 02E1 STS	T_dat,R2
(1870) 									T_dat<<=8;
    01AAC 2C32      MOV	R3,R2
    01AAD 2422      CLR	R2
    01AAE 9230 02E2 STS	T_dat+1,R3
    01AB0 9220 02E1 STS	T_dat,R2
(1871) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01AB2 EF8B      LDI	R24,0xFB
    01AB3 E092      LDI	R25,2
    01AB4 2DEA      MOV	R30,R10
    01AB5 27FF      CLR	R31
    01AB6 0FEE      LSL	R30
    01AB7 1FFF      ROL	R31
    01AB8 0FE8      ADD	R30,R24
    01AB9 1FF9      ADC	R31,R25
    01ABA 8020      LD	R2,Z
    01ABB 2433      CLR	R3
    01ABC 9040 02E1 LDS	R4,T_dat
    01ABE 9050 02E2 LDS	R5,T_dat+1
    01AC0 2842      OR	R4,R2
    01AC1 2853      OR	R5,R3
    01AC2 9250 02E2 STS	T_dat+1,R5
    01AC4 9240 02E1 STS	T_dat,R4
(1872) 									SendManchester();
    01AC6 D0BF      RCALL	_SendManchester
(1873) 									Delay_ms(20);
    01AC7 E104      LDI	R16,0x14
    01AC8 E010      LDI	R17,0
    01AC9 940E 05F4 CALL	_Delay_ms
    01ACB 94A3      INC	R10
    01ACC 2D8A      MOV	R24,R10
    01ACD 3280      CPI	R24,0x20
    01ACE F278      BCS	0x1A9E
(1874) 								}
(1875) 							}	
(1876) 
(1877) 							Uart0TxData[0]=0xE8;
    01ACF EE88      LDI	R24,0xE8
    01AD0 9380 012F STS	Uart0TxData,R24
(1878) 							Uart0TxData[1]=0x40;
    01AD2 E480      LDI	R24,0x40
    01AD3 9380 0130 STS	Uart0TxData+1,R24
(1879) 							Uart0TxData[2]=0x83;
    01AD5 E883      LDI	R24,0x83
    01AD6 9380 0131 STS	Uart0TxData+2,R24
(1880) 							Uart0TxData[3]=4;//包4
    01AD8 E084      LDI	R24,4
    01AD9 9380 0132 STS	Uart0TxData+3,R24
(1881) 							SendUart0_2(9,5);// 超时40ms	 
    01ADB E025      LDI	R18,5
    01ADC E030      LDI	R19,0
    01ADD E009      LDI	R16,0x9
    01ADE 940E 04EB CALL	_SendUart0_2
(1882) 							if(Uart0RxCounter==64) 
    01AE0 9180 02FA LDS	R24,Uart0RxCounter
    01AE2 3480      CPI	R24,0x40
    01AE3 F009      BEQ	0x1AE5
    01AE4 C094      RJMP	0x1B79
(1883) 							{
(1884) 								for(i=0;i<32;i++)
    01AE5 24AA      CLR	R10
    01AE6 C02E      RJMP	0x1B15
(1885) 								{
(1886) 									T_dat=Uart0RxData[i*2+1];//高字节
    01AE7 EF8C      LDI	R24,0xFC
    01AE8 E092      LDI	R25,2
    01AE9 2DEA      MOV	R30,R10
    01AEA 27FF      CLR	R31
    01AEB 0FEE      LSL	R30
    01AEC 1FFF      ROL	R31
    01AED 0FE8      ADD	R30,R24
    01AEE 1FF9      ADC	R31,R25
    01AEF 8020      LD	R2,Z
    01AF0 2433      CLR	R3
    01AF1 9230 02E2 STS	T_dat+1,R3
    01AF3 9220 02E1 STS	T_dat,R2
(1887) 									T_dat<<=8;
    01AF5 2C32      MOV	R3,R2
    01AF6 2422      CLR	R2
    01AF7 9230 02E2 STS	T_dat+1,R3
    01AF9 9220 02E1 STS	T_dat,R2
(1888) 									T_dat|=Uart0RxData[i*2+0];//低字节
    01AFB EF8B      LDI	R24,0xFB
    01AFC E092      LDI	R25,2
    01AFD 2DEA      MOV	R30,R10
    01AFE 27FF      CLR	R31
    01AFF 0FEE      LSL	R30
    01B00 1FFF      ROL	R31
    01B01 0FE8      ADD	R30,R24
    01B02 1FF9      ADC	R31,R25
    01B03 8020      LD	R2,Z
    01B04 2433      CLR	R3
    01B05 9040 02E1 LDS	R4,T_dat
    01B07 9050 02E2 LDS	R5,T_dat+1
    01B09 2842      OR	R4,R2
    01B0A 2853      OR	R5,R3
    01B0B 9250 02E2 STS	T_dat+1,R5
    01B0D 9240 02E1 STS	T_dat,R4
(1889) 									SendManchester();
    01B0F D076      RCALL	_SendManchester
(1890) 									Delay_ms(20);
    01B10 E104      LDI	R16,0x14
    01B11 E010      LDI	R17,0
    01B12 940E 05F4 CALL	_Delay_ms
    01B14 94A3      INC	R10
    01B15 2D8A      MOV	R24,R10
    01B16 3280      CPI	R24,0x20
    01B17 F278      BCS	0x1AE7
(1891) 								}
(1892) 							}	
(1893) 						}
    01B18 C060      RJMP	0x1B79
(1894) 						else  if(R_dat==0xca) //写仪器信息
    01B19 9180 02DF LDS	R24,R_dat
    01B1B 9190 02E0 LDS	R25,R_dat+1
    01B1D 3C8A      CPI	R24,0xCA
    01B1E E0E0      LDI	R30,0
    01B1F 079E      CPC	R25,R30
    01B20 F009      BEQ	0x1B22
    01B21 C057      RJMP	0x1B79
(1895) 						{
(1896) 							DataFlag=4;
    01B22 E084      LDI	R24,4
    01B23 E090      LDI	R25,0
    01B24 9390 02C2 STS	DataFlag+1,R25
    01B26 9380 02C1 STS	DataFlag,R24
(1897) 							coeff_len=320;
    01B28 E480      LDI	R24,0x40
    01B29 E091      LDI	R25,1
    01B2A 9390 012D STS	coeff_len+1,R25
    01B2C 9380 012C STS	coeff_len,R24
(1898) 							coeff_count=0;
    01B2E 2422      CLR	R2
    01B2F 2433      CLR	R3
    01B30 9230 012B STS	coeff_count+1,R3
    01B32 9220 012A STS	coeff_count,R2
(1899) 							TimeOutFlag=0;
    01B34 9220 02D9 STS	TimeOutFlag,R2
(1900) 							Timer0Counter=2000;//16s定时
    01B36 ED80      LDI	R24,0xD0
    01B37 E097      LDI	R25,7
    01B38 9390 0346 STS	Timer0Counter+1,R25
    01B3A 9380 0345 STS	Timer0Counter,R24
(1901) 							TCNT0=0x06; //8ms
    01B3C E086      LDI	R24,6
    01B3D BF82      OUT	0x32,R24
(1902) 							TCCR0|=0x06;//256分频
    01B3E B783      IN	R24,0x33
    01B3F 6086      ORI	R24,6
    01B40 BF83      OUT	0x33,R24
(1903) 							TIFR|=0x01; //清定时器0中断标志
    01B41 B786      IN	R24,0x36
    01B42 6081      ORI	R24,1
    01B43 BF86      OUT	0x36,R24
(1904) 							TIMSK|=0x01;//使能定时器0中断		
    01B44 B787      IN	R24,0x37
    01B45 6081      ORI	R24,1
    01B46 BF87      OUT	0x37,R24
(1905) 						}
(1906) 						break;
    01B47 C031      RJMP	0x1B79
(1907) 					
(1908) 					case 0xd0://压力板与电机板版本
(1909) 					   if(R_dat==0xdf)//电机板与第2路压力板版本号	
    01B48 9180 02DF LDS	R24,R_dat
    01B4A 9190 02E0 LDS	R25,R_dat+1
    01B4C 3D8F      CPI	R24,0xDF
    01B4D E0E0      LDI	R30,0
    01B4E 079E      CPC	R25,R30
    01B4F F549      BNE	0x1B79
(1910) 					    {			 
(1911) 						  SendUart1(0xdf,3);//电机板
    01B50 E023      LDI	R18,3
    01B51 E030      LDI	R19,0
    01B52 ED0F      LDI	R16,0xDF
    01B53 940E 02B3 CALL	_SendUart1
(1912) 						  T_dat=Uart1RxData[0];
    01B55 9020 02F6 LDS	R2,Uart1RxData
    01B57 2433      CLR	R3
    01B58 9230 02E2 STS	T_dat+1,R3
    01B5A 9220 02E1 STS	T_dat,R2
(1913) 						  T_dat<<=8;
    01B5C 9020 02E1 LDS	R2,T_dat
    01B5E 9030 02E2 LDS	R3,T_dat+1
    01B60 2C32      MOV	R3,R2
    01B61 2422      CLR	R2
    01B62 9230 02E2 STS	T_dat+1,R3
    01B64 9220 02E1 STS	T_dat,R2
(1914) 						  
(1915) 						  SendTPS(0xdf);//第2路压力板
    01B66 ED0F      LDI	R16,0xDF
    01B67 940E 0310 CALL	_SendTPS
(1916) 						  T_dat|=ReceiveTPS();
    01B69 940E 037A CALL	_ReceiveTPS
    01B6B 2EA0      MOV	R10,R16
    01B6C 2C2A      MOV	R2,R10
    01B6D 2433      CLR	R3
    01B6E 9040 02E1 LDS	R4,T_dat
    01B70 9050 02E2 LDS	R5,T_dat+1
    01B72 2842      OR	R4,R2
    01B73 2853      OR	R5,R3
    01B74 9250 02E2 STS	T_dat+1,R5
    01B76 9240 02E1 STS	T_dat,R4
(1917) 						  
(1918) 						  SendManchester();	
    01B78 D00D      RCALL	_SendManchester
(1919) 						}
(1920) 					break;
(1921) 					
(1922) 					default: 
(1923) 						break;	
(1924) 				}
(1925) 			}
(1926) 			
(1927) 		RDataEnd:
(1928) 			IntFlag=0;
    01B79 2422      CLR	R2
    01B7A 9220 02BF STS	IntFlag,R2
(1929) 			EIFR|=0x01;//清INT0中断标志
    01B7C B788      IN	R24,0x38
    01B7D 6081      ORI	R24,1
    01B7E BF88      OUT	0x38,R24
(1930) 			EIMSK|=0x01;//使能INT0中断 
    01B7F B789      IN	R24,0x39
    01B80 6081      ORI	R24,1
    01B81 BF89      OUT	0x39,R24
    01B82 940C 069D JMP	0x69D
    01B84 9629      ADIW	R28,0x9
    01B85 9508      RET
_SendManchester:
  L                    --> R20
    01B86 934A      ST	-Y,R20
(1931) 		}  
(1932) 	}
(1933) }
(1934) 
(1935)  
(1936) 
(1937) void SendManchester(void) //曼码发送程序,总耗时最大约120+560+8400+720=9800us，最小约120+560+5040+720=6440us
(1938) { //每位80us
(1939)  //同步：1高6低
(1940)  //1:    1高2低
(1941)  //0：   1高4低  
(1942)   unsigned char L;
(1943)   SREG&=0x7f;//关总中断 
    01B87 B78F      IN	R24,0x3F
    01B88 778F      ANDI	R24,0x7F
    01B89 BF8F      OUT	0x3F,R24
(1944)   
(1945)     M1_H //先给总线放电，耗时约120us
    01B8A 9180 0065 LDS	R24,0x65
    01B8C 6088      ORI	R24,0x8
    01B8D 9380 0065 STS	0x65,R24
(1946) 	
(1947)   //模拟同步头数据
(1948) 	//4位命令
(1949) 	T_dat_buf[21]=(T_com&0x08)>>3;
    01B8F 9180 02DA LDS	R24,T_com
    01B91 7088      ANDI	R24,0x8
    01B92 9586      LSR	R24
    01B93 9586      LSR	R24
    01B94 9586      LSR	R24
    01B95 9380 02D8 STS	T_dat_buf+21,R24
(1950) 	T_dat_buf[20]=(T_com&0x04)>>2;
    01B97 9180 02DA LDS	R24,T_com
    01B99 7084      ANDI	R24,4
    01B9A 9586      LSR	R24
    01B9B 9586      LSR	R24
    01B9C 9380 02D7 STS	T_dat_buf+20,R24
(1951) 	T_dat_buf[19]=(T_com&0x02)>>1;
    01B9E 9180 02DA LDS	R24,T_com
    01BA0 7082      ANDI	R24,2
    01BA1 9586      LSR	R24
    01BA2 9380 02D6 STS	T_dat_buf+19,R24
(1952) 	T_dat_buf[18]=T_com&0x01;
    01BA4 9180 02DA LDS	R24,T_com
    01BA6 7081      ANDI	R24,1
    01BA7 9380 02D5 STS	T_dat_buf+18,R24
(1953) 	//16位数据
(1954) 	T_dat_buf[17]=(T_dat&0x8000)>>15;
    01BA9 E02F      LDI	R18,0xF
    01BAA E030      LDI	R19,0
    01BAB 9100 02E1 LDS	R16,T_dat
    01BAD 9110 02E2 LDS	R17,T_dat+1
    01BAF 7000      ANDI	R16,0
    01BB0 7810      ANDI	R17,0x80
    01BB1 940E 2092 CALL	lsr16
    01BB3 9300 02D4 STS	T_dat_buf+17,R16
(1955) 	T_dat_buf[16]=(T_dat&0x4000)>>14;
    01BB5 E02E      LDI	R18,0xE
    01BB6 E030      LDI	R19,0
    01BB7 9100 02E1 LDS	R16,T_dat
    01BB9 9110 02E2 LDS	R17,T_dat+1
    01BBB 7000      ANDI	R16,0
    01BBC 7410      ANDI	R17,0x40
    01BBD 940E 2026 CALL	asr16
    01BBF 9300 02D3 STS	T_dat_buf+16,R16
(1956) 	T_dat_buf[15]=(T_dat&0x2000)>>13;
    01BC1 E02D      LDI	R18,0xD
    01BC2 E030      LDI	R19,0
    01BC3 9100 02E1 LDS	R16,T_dat
    01BC5 9110 02E2 LDS	R17,T_dat+1
    01BC7 7000      ANDI	R16,0
    01BC8 7210      ANDI	R17,0x20
    01BC9 940E 2026 CALL	asr16
    01BCB 9300 02D2 STS	T_dat_buf+15,R16
(1957) 	T_dat_buf[14]=(T_dat&0x1000)>>12;
    01BCD E02C      LDI	R18,0xC
    01BCE E030      LDI	R19,0
    01BCF 9100 02E1 LDS	R16,T_dat
    01BD1 9110 02E2 LDS	R17,T_dat+1
    01BD3 7000      ANDI	R16,0
    01BD4 7110      ANDI	R17,0x10
    01BD5 940E 2026 CALL	asr16
    01BD7 9300 02D1 STS	T_dat_buf+14,R16
(1958) 	T_dat_buf[13]=(T_dat&0x0800)>>11;
    01BD9 E02B      LDI	R18,0xB
    01BDA E030      LDI	R19,0
    01BDB 9100 02E1 LDS	R16,T_dat
    01BDD 9110 02E2 LDS	R17,T_dat+1
    01BDF 7000      ANDI	R16,0
    01BE0 7018      ANDI	R17,0x8
    01BE1 940E 2026 CALL	asr16
    01BE3 9300 02D0 STS	T_dat_buf+13,R16
(1959)     T_dat_buf[12]=(T_dat&0x0400)>>10;
    01BE5 E02A      LDI	R18,0xA
    01BE6 E030      LDI	R19,0
    01BE7 9100 02E1 LDS	R16,T_dat
    01BE9 9110 02E2 LDS	R17,T_dat+1
    01BEB 7000      ANDI	R16,0
    01BEC 7014      ANDI	R17,4
    01BED 940E 2026 CALL	asr16
    01BEF 9300 02CF STS	T_dat_buf+12,R16
(1960)     T_dat_buf[11]=(T_dat&0x0200)>>9;
    01BF1 E029      LDI	R18,0x9
    01BF2 E030      LDI	R19,0
    01BF3 9100 02E1 LDS	R16,T_dat
    01BF5 9110 02E2 LDS	R17,T_dat+1
    01BF7 7000      ANDI	R16,0
    01BF8 7012      ANDI	R17,2
    01BF9 940E 2026 CALL	asr16
    01BFB 9300 02CE STS	T_dat_buf+11,R16
(1961) 	T_dat_buf[10]=(T_dat&0x0100)>>8;
    01BFD 9180 02E1 LDS	R24,T_dat
    01BFF 9190 02E2 LDS	R25,T_dat+1
    01C01 7080      ANDI	R24,0
    01C02 7091      ANDI	R25,1
    01C03 011C      MOVW	R2,R24
    01C04 2C23      MOV	R2,R3
    01C05 2433      CLR	R3
    01C06 FC27      SBRC	R2,7
    01C07 9430      COM	R3
    01C08 9220 02CD STS	T_dat_buf+10,R2
(1962) 	T_dat_buf[9]=(T_dat&0x0080)>>7;
    01C0A E027      LDI	R18,7
    01C0B E030      LDI	R19,0
    01C0C 9100 02E1 LDS	R16,T_dat
    01C0E 9110 02E2 LDS	R17,T_dat+1
    01C10 7800      ANDI	R16,0x80
    01C11 7010      ANDI	R17,0
    01C12 940E 2026 CALL	asr16
    01C14 9300 02CC STS	T_dat_buf+9,R16
(1963) 	T_dat_buf[8]=(T_dat&0x0040)>>6;
    01C16 E026      LDI	R18,6
    01C17 E030      LDI	R19,0
    01C18 9100 02E1 LDS	R16,T_dat
    01C1A 9110 02E2 LDS	R17,T_dat+1
    01C1C 7400      ANDI	R16,0x40
    01C1D 7010      ANDI	R17,0
    01C1E 940E 2026 CALL	asr16
    01C20 9300 02CB STS	T_dat_buf+8,R16
(1964) 	T_dat_buf[7]=(T_dat&0x0020)>>5;
    01C22 E025      LDI	R18,5
    01C23 E030      LDI	R19,0
    01C24 9100 02E1 LDS	R16,T_dat
    01C26 9110 02E2 LDS	R17,T_dat+1
    01C28 7200      ANDI	R16,0x20
    01C29 7010      ANDI	R17,0
    01C2A 940E 2026 CALL	asr16
    01C2C 9300 02CA STS	T_dat_buf+7,R16
(1965) 	T_dat_buf[6]=(T_dat&0x0010)>>4;
    01C2E 9180 02E1 LDS	R24,T_dat
    01C30 9190 02E2 LDS	R25,T_dat+1
    01C32 7180      ANDI	R24,0x10
    01C33 7090      ANDI	R25,0
    01C34 011C      MOVW	R2,R24
    01C35 9435      ASR	R3
    01C36 9427      ROR	R2
    01C37 9435      ASR	R3
    01C38 9427      ROR	R2
    01C39 9435      ASR	R3
    01C3A 9427      ROR	R2
    01C3B 9435      ASR	R3
    01C3C 9427      ROR	R2
    01C3D 9220 02C9 STS	T_dat_buf+6,R2
(1966) 	T_dat_buf[5]=(T_dat&0x0008)>>3;
    01C3F 9180 02E1 LDS	R24,T_dat
    01C41 9190 02E2 LDS	R25,T_dat+1
    01C43 7088      ANDI	R24,0x8
    01C44 7090      ANDI	R25,0
    01C45 011C      MOVW	R2,R24
    01C46 9435      ASR	R3
    01C47 9427      ROR	R2
    01C48 9435      ASR	R3
    01C49 9427      ROR	R2
    01C4A 9435      ASR	R3
    01C4B 9427      ROR	R2
    01C4C 9220 02C8 STS	T_dat_buf+5,R2
(1967) 	T_dat_buf[4]=(T_dat&0x0004)>>2;
    01C4E 9180 02E1 LDS	R24,T_dat
    01C50 9190 02E2 LDS	R25,T_dat+1
    01C52 7084      ANDI	R24,4
    01C53 7090      ANDI	R25,0
    01C54 011C      MOVW	R2,R24
    01C55 9435      ASR	R3
    01C56 9427      ROR	R2
    01C57 9435      ASR	R3
    01C58 9427      ROR	R2
    01C59 9220 02C7 STS	T_dat_buf+4,R2
(1968) 	T_dat_buf[3]=(T_dat&0x0002)>>1;
    01C5B 9180 02E1 LDS	R24,T_dat
    01C5D 9190 02E2 LDS	R25,T_dat+1
    01C5F 7082      ANDI	R24,2
    01C60 7090      ANDI	R25,0
    01C61 011C      MOVW	R2,R24
    01C62 9435      ASR	R3
    01C63 9427      ROR	R2
    01C64 9220 02C6 STS	T_dat_buf+3,R2
(1969) 	T_dat_buf[2]=T_dat&0x0001;
    01C66 9180 02E1 LDS	R24,T_dat
    01C68 9190 02E2 LDS	R25,T_dat+1
    01C6A 7081      ANDI	R24,1
    01C6B 7090      ANDI	R25,0
    01C6C 9380 02C5 STS	T_dat_buf+2,R24
(1970) 	//计算校验位，奇校验
(1971) 	T_dat_buf[1]=1;
    01C6E E081      LDI	R24,1
    01C6F 9380 02C4 STS	T_dat_buf+1,R24
(1972)   	for(L=2;L<22;L++)
    01C71 E042      LDI	R20,2
    01C72 C00D      RJMP	0x1C80
(1973) 		{T_dat_buf[1]^=T_dat_buf[L];}
    01C73 EC83      LDI	R24,0xC3
    01C74 E092      LDI	R25,2
    01C75 2FE4      MOV	R30,R20
    01C76 27FF      CLR	R31
    01C77 0FE8      ADD	R30,R24
    01C78 1FF9      ADC	R31,R25
    01C79 8020      LD	R2,Z
    01C7A 9030 02C4 LDS	R3,T_dat_buf+1
    01C7C 2432      EOR	R3,R2
    01C7D 9230 02C4 STS	T_dat_buf+1,R3
    01C7F 9543      INC	R20
    01C80 3146      CPI	R20,0x16
    01C81 F388      BCS	0x1C73
(1974)     DELAY80
    01C82 2422      CLR	R2
    01C83 2433      CLR	R3
    01C84 9230 02BE STS	Tt+1,R3
    01C86 9220 02BD STS	Tt,R2
    01C88 C009      RJMP	0x1C92
    01C89 9180 02BD LDS	R24,Tt
    01C8B 9190 02BE LDS	R25,Tt+1
    01C8D 9601      ADIW	R24,1
    01C8E 9390 02BE STS	Tt+1,R25
    01C90 9380 02BD STS	Tt,R24
    01C92 9180 02BD LDS	R24,Tt
    01C94 9190 02BE LDS	R25,Tt+1
    01C96 3280      CPI	R24,0x20
    01C97 E0E0      LDI	R30,0
    01C98 079E      CPC	R25,R30
    01C99 F378      BCS	0x1C89
(1975)     M1_L
    01C9A 9180 0065 LDS	R24,0x65
    01C9C 7F87      ANDI	R24,0xF7
    01C9D 9380 0065 STS	0x65,R24
(1976) 	DELAY40
    01C9F 2422      CLR	R2
    01CA0 2433      CLR	R3
    01CA1 9230 02BE STS	Tt+1,R3
    01CA3 9220 02BD STS	Tt,R2
    01CA5 C009      RJMP	0x1CAF
    01CA6 9180 02BD LDS	R24,Tt
    01CA8 9190 02BE LDS	R25,Tt+1
    01CAA 9601      ADIW	R24,1
    01CAB 9390 02BE STS	Tt+1,R25
    01CAD 9380 02BD STS	Tt,R24
    01CAF 9180 02BD LDS	R24,Tt
    01CB1 9190 02BE LDS	R25,Tt+1
    01CB3 3180      CPI	R24,0x10
    01CB4 E0E0      LDI	R30,0
    01CB5 079E      CPC	R25,R30
    01CB6 F378      BCS	0x1CA6
(1977)    
(1978)    
(1979) 	//同步头,560us
(1980) 	//充电开始，高80us	 
(1981) 	M2_H 	
    01CB7 9180 0065 LDS	R24,0x65
    01CB9 6180      ORI	R24,0x10
    01CBA 9380 0065 STS	0x65,R24
(1982) 	DELAY80
    01CBC 2422      CLR	R2
    01CBD 2433      CLR	R3
    01CBE 9230 02BE STS	Tt+1,R3
    01CC0 9220 02BD STS	Tt,R2
    01CC2 C009      RJMP	0x1CCC
    01CC3 9180 02BD LDS	R24,Tt
    01CC5 9190 02BE LDS	R25,Tt+1
    01CC7 9601      ADIW	R24,1
    01CC8 9390 02BE STS	Tt+1,R25
    01CCA 9380 02BD STS	Tt,R24
    01CCC 9180 02BD LDS	R24,Tt
    01CCE 9190 02BE LDS	R25,Tt+1
    01CD0 3280      CPI	R24,0x20
    01CD1 E0E0      LDI	R30,0
    01CD2 079E      CPC	R25,R30
    01CD3 F378      BCS	0x1CC3
(1983) 	M2_L   //充电结束	
    01CD4 9180 0065 LDS	R24,0x65
    01CD6 7E8F      ANDI	R24,0xEF
    01CD7 9380 0065 STS	0x65,R24
(1984) 	//放电开始，低80*6=480us
(1985) 	DELAY40
    01CD9 2422      CLR	R2
    01CDA 2433      CLR	R3
    01CDB 9230 02BE STS	Tt+1,R3
    01CDD 9220 02BD STS	Tt,R2
    01CDF C009      RJMP	0x1CE9
    01CE0 9180 02BD LDS	R24,Tt
    01CE2 9190 02BE LDS	R25,Tt+1
    01CE4 9601      ADIW	R24,1
    01CE5 9390 02BE STS	Tt+1,R25
    01CE7 9380 02BD STS	Tt,R24
    01CE9 9180 02BD LDS	R24,Tt
    01CEB 9190 02BE LDS	R25,Tt+1
    01CED 3180      CPI	R24,0x10
    01CEE E0E0      LDI	R30,0
    01CEF 079E      CPC	R25,R30
    01CF0 F378      BCS	0x1CE0
(1986) 	M1_H    
    01CF1 9180 0065 LDS	R24,0x65
    01CF3 6088      ORI	R24,0x8
    01CF4 9380 0065 STS	0x65,R24
(1987)     DELAY80
    01CF6 2422      CLR	R2
    01CF7 2433      CLR	R3
    01CF8 9230 02BE STS	Tt+1,R3
    01CFA 9220 02BD STS	Tt,R2
    01CFC C009      RJMP	0x1D06
    01CFD 9180 02BD LDS	R24,Tt
    01CFF 9190 02BE LDS	R25,Tt+1
    01D01 9601      ADIW	R24,1
    01D02 9390 02BE STS	Tt+1,R25
    01D04 9380 02BD STS	Tt,R24
    01D06 9180 02BD LDS	R24,Tt
    01D08 9190 02BE LDS	R25,Tt+1
    01D0A 3280      CPI	R24,0x20
    01D0B E0E0      LDI	R30,0
    01D0C 079E      CPC	R25,R30
    01D0D F378      BCS	0x1CFD
(1988) 	DELAY80
    01D0E 2422      CLR	R2
    01D0F 2433      CLR	R3
    01D10 9230 02BE STS	Tt+1,R3
    01D12 9220 02BD STS	Tt,R2
    01D14 C009      RJMP	0x1D1E
    01D15 9180 02BD LDS	R24,Tt
    01D17 9190 02BE LDS	R25,Tt+1
    01D19 9601      ADIW	R24,1
    01D1A 9390 02BE STS	Tt+1,R25
    01D1C 9380 02BD STS	Tt,R24
    01D1E 9180 02BD LDS	R24,Tt
    01D20 9190 02BE LDS	R25,Tt+1
    01D22 3280      CPI	R24,0x20
    01D23 E0E0      LDI	R30,0
    01D24 079E      CPC	R25,R30
    01D25 F378      BCS	0x1D15
(1989) 	DELAY80
    01D26 2422      CLR	R2
    01D27 2433      CLR	R3
    01D28 9230 02BE STS	Tt+1,R3
    01D2A 9220 02BD STS	Tt,R2
    01D2C C009      RJMP	0x1D36
    01D2D 9180 02BD LDS	R24,Tt
    01D2F 9190 02BE LDS	R25,Tt+1
    01D31 9601      ADIW	R24,1
    01D32 9390 02BE STS	Tt+1,R25
    01D34 9380 02BD STS	Tt,R24
    01D36 9180 02BD LDS	R24,Tt
    01D38 9190 02BE LDS	R25,Tt+1
    01D3A 3280      CPI	R24,0x20
    01D3B E0E0      LDI	R30,0
    01D3C 079E      CPC	R25,R30
    01D3D F378      BCS	0x1D2D
(1990) 	DELAY80
    01D3E 2422      CLR	R2
    01D3F 2433      CLR	R3
    01D40 9230 02BE STS	Tt+1,R3
    01D42 9220 02BD STS	Tt,R2
    01D44 C009      RJMP	0x1D4E
    01D45 9180 02BD LDS	R24,Tt
    01D47 9190 02BE LDS	R25,Tt+1
    01D49 9601      ADIW	R24,1
    01D4A 9390 02BE STS	Tt+1,R25
    01D4C 9380 02BD STS	Tt,R24
    01D4E 9180 02BD LDS	R24,Tt
    01D50 9190 02BE LDS	R25,Tt+1
    01D52 3280      CPI	R24,0x20
    01D53 E0E0      LDI	R30,0
    01D54 079E      CPC	R25,R30
    01D55 F378      BCS	0x1D45
(1991) 	DELAY80
    01D56 2422      CLR	R2
    01D57 2433      CLR	R3
    01D58 9230 02BE STS	Tt+1,R3
    01D5A 9220 02BD STS	Tt,R2
    01D5C C009      RJMP	0x1D66
    01D5D 9180 02BD LDS	R24,Tt
    01D5F 9190 02BE LDS	R25,Tt+1
    01D61 9601      ADIW	R24,1
    01D62 9390 02BE STS	Tt+1,R25
    01D64 9380 02BD STS	Tt,R24
    01D66 9180 02BD LDS	R24,Tt
    01D68 9190 02BE LDS	R25,Tt+1
    01D6A 3280      CPI	R24,0x20
    01D6B E0E0      LDI	R30,0
    01D6C 079E      CPC	R25,R30
    01D6D F378      BCS	0x1D5D
(1992) 	M1_L    
    01D6E 9180 0065 LDS	R24,0x65
    01D70 7F87      ANDI	R24,0xF7
    01D71 9380 0065 STS	0x65,R24
(1993) 	DELAY40  //放电结束
    01D73 2422      CLR	R2
    01D74 2433      CLR	R3
    01D75 9230 02BE STS	Tt+1,R3
    01D77 9220 02BD STS	Tt,R2
    01D79 C009      RJMP	0x1D83
    01D7A 9180 02BD LDS	R24,Tt
    01D7C 9190 02BE LDS	R25,Tt+1
    01D7E 9601      ADIW	R24,1
    01D7F 9390 02BE STS	Tt+1,R25
    01D81 9380 02BD STS	Tt,R24
    01D83 9180 02BD LDS	R24,Tt
    01D85 9190 02BE LDS	R25,Tt+1
    01D87 3180      CPI	R24,0x10
    01D88 E0E0      LDI	R30,0
    01D89 079E      CPC	R25,R30
    01D8A F378      BCS	0x1D7A
(1994) 	
(1995)      //连续发送 ,全0时每位400us，共8400us，全1时每位240us，共5040us
(1996)  	for(L=21;L>0;L--)
    01D8B E145      LDI	R20,0x15
    01D8C C124      RJMP	0x1EB1
(1997) 	{   
(1998) 	  if(T_dat_buf[L])//1，一高二低
    01D8D EC83      LDI	R24,0xC3
    01D8E E092      LDI	R25,2
    01D8F 2FE4      MOV	R30,R20
    01D90 27FF      CLR	R31
    01D91 0FE8      ADD	R30,R24
    01D92 1FF9      ADC	R31,R25
    01D93 8020      LD	R2,Z
    01D94 2022      TST	R2
    01D95 F409      BNE	0x1D97
    01D96 C075      RJMP	0x1E0C
(1999)         {         	 		
(2000) 	        M2_H 
    01D97 9180 0065 LDS	R24,0x65
    01D99 6180      ORI	R24,0x10
    01D9A 9380 0065 STS	0x65,R24
(2001) 	        DELAY80
    01D9C 2422      CLR	R2
    01D9D 2433      CLR	R3
    01D9E 9230 02BE STS	Tt+1,R3
    01DA0 9220 02BD STS	Tt,R2
    01DA2 C009      RJMP	0x1DAC
    01DA3 9180 02BD LDS	R24,Tt
    01DA5 9190 02BE LDS	R25,Tt+1
    01DA7 9601      ADIW	R24,1
    01DA8 9390 02BE STS	Tt+1,R25
    01DAA 9380 02BD STS	Tt,R24
    01DAC 9180 02BD LDS	R24,Tt
    01DAE 9190 02BE LDS	R25,Tt+1
    01DB0 3280      CPI	R24,0x20
    01DB1 E0E0      LDI	R30,0
    01DB2 079E      CPC	R25,R30
    01DB3 F378      BCS	0x1DA3
(2002) 	        M2_L
    01DB4 9180 0065 LDS	R24,0x65
    01DB6 7E8F      ANDI	R24,0xEF
    01DB7 9380 0065 STS	0x65,R24
(2003) 			DELAY40
    01DB9 2422      CLR	R2
    01DBA 2433      CLR	R3
    01DBB 9230 02BE STS	Tt+1,R3
    01DBD 9220 02BD STS	Tt,R2
    01DBF C009      RJMP	0x1DC9
    01DC0 9180 02BD LDS	R24,Tt
    01DC2 9190 02BE LDS	R25,Tt+1
    01DC4 9601      ADIW	R24,1
    01DC5 9390 02BE STS	Tt+1,R25
    01DC7 9380 02BD STS	Tt,R24
    01DC9 9180 02BD LDS	R24,Tt
    01DCB 9190 02BE LDS	R25,Tt+1
    01DCD 3180      CPI	R24,0x10
    01DCE E0E0      LDI	R30,0
    01DCF 079E      CPC	R25,R30
    01DD0 F378      BCS	0x1DC0
(2004) 	        M1_H       
    01DD1 9180 0065 LDS	R24,0x65
    01DD3 6088      ORI	R24,0x8
    01DD4 9380 0065 STS	0x65,R24
(2005)          	DELAY80
    01DD6 2422      CLR	R2
    01DD7 2433      CLR	R3
    01DD8 9230 02BE STS	Tt+1,R3
    01DDA 9220 02BD STS	Tt,R2
    01DDC C009      RJMP	0x1DE6
    01DDD 9180 02BD LDS	R24,Tt
    01DDF 9190 02BE LDS	R25,Tt+1
    01DE1 9601      ADIW	R24,1
    01DE2 9390 02BE STS	Tt+1,R25
    01DE4 9380 02BD STS	Tt,R24
    01DE6 9180 02BD LDS	R24,Tt
    01DE8 9190 02BE LDS	R25,Tt+1
    01DEA 3280      CPI	R24,0x20
    01DEB E0E0      LDI	R30,0
    01DEC 079E      CPC	R25,R30
    01DED F378      BCS	0x1DDD
(2006) 			M1_L
    01DEE 9180 0065 LDS	R24,0x65
    01DF0 7F87      ANDI	R24,0xF7
    01DF1 9380 0065 STS	0x65,R24
(2007) 			DELAY40
    01DF3 2422      CLR	R2
    01DF4 2433      CLR	R3
    01DF5 9230 02BE STS	Tt+1,R3
    01DF7 9220 02BD STS	Tt,R2
    01DF9 C009      RJMP	0x1E03
    01DFA 9180 02BD LDS	R24,Tt
    01DFC 9190 02BE LDS	R25,Tt+1
    01DFE 9601      ADIW	R24,1
    01DFF 9390 02BE STS	Tt+1,R25
    01E01 9380 02BD STS	Tt,R24
    01E03 9180 02BD LDS	R24,Tt
    01E05 9190 02BE LDS	R25,Tt+1
    01E07 3180      CPI	R24,0x10
    01E08 E0E0      LDI	R30,0
    01E09 079E      CPC	R25,R30
    01E0A F378      BCS	0x1DFA
(2008) 		} 
    01E0B C0A4      RJMP	0x1EB0
(2009)        else 		//0，一高四低 				                
(2010)         {
(2011) 		 	M2_H 
    01E0C 9180 0065 LDS	R24,0x65
    01E0E 6180      ORI	R24,0x10
    01E0F 9380 0065 STS	0x65,R24
(2012) 	        DELAY80
    01E11 2422      CLR	R2
    01E12 2433      CLR	R3
    01E13 9230 02BE STS	Tt+1,R3
    01E15 9220 02BD STS	Tt,R2
    01E17 C009      RJMP	0x1E21
    01E18 9180 02BD LDS	R24,Tt
    01E1A 9190 02BE LDS	R25,Tt+1
    01E1C 9601      ADIW	R24,1
    01E1D 9390 02BE STS	Tt+1,R25
    01E1F 9380 02BD STS	Tt,R24
    01E21 9180 02BD LDS	R24,Tt
    01E23 9190 02BE LDS	R25,Tt+1
    01E25 3280      CPI	R24,0x20
    01E26 E0E0      LDI	R30,0
    01E27 079E      CPC	R25,R30
    01E28 F378      BCS	0x1E18
(2013) 	        M2_L
    01E29 9180 0065 LDS	R24,0x65
    01E2B 7E8F      ANDI	R24,0xEF
    01E2C 9380 0065 STS	0x65,R24
(2014) 			DELAY40
    01E2E 2422      CLR	R2
    01E2F 2433      CLR	R3
    01E30 9230 02BE STS	Tt+1,R3
    01E32 9220 02BD STS	Tt,R2
    01E34 C009      RJMP	0x1E3E
    01E35 9180 02BD LDS	R24,Tt
    01E37 9190 02BE LDS	R25,Tt+1
    01E39 9601      ADIW	R24,1
    01E3A 9390 02BE STS	Tt+1,R25
    01E3C 9380 02BD STS	Tt,R24
    01E3E 9180 02BD LDS	R24,Tt
    01E40 9190 02BE LDS	R25,Tt+1
    01E42 3180      CPI	R24,0x10
    01E43 E0E0      LDI	R30,0
    01E44 079E      CPC	R25,R30
    01E45 F378      BCS	0x1E35
(2015) 	        M1_H       
    01E46 9180 0065 LDS	R24,0x65
    01E48 6088      ORI	R24,0x8
    01E49 9380 0065 STS	0x65,R24
(2016)          	DELAY80
    01E4B 2422      CLR	R2
    01E4C 2433      CLR	R3
    01E4D 9230 02BE STS	Tt+1,R3
    01E4F 9220 02BD STS	Tt,R2
    01E51 C009      RJMP	0x1E5B
    01E52 9180 02BD LDS	R24,Tt
    01E54 9190 02BE LDS	R25,Tt+1
    01E56 9601      ADIW	R24,1
    01E57 9390 02BE STS	Tt+1,R25
    01E59 9380 02BD STS	Tt,R24
    01E5B 9180 02BD LDS	R24,Tt
    01E5D 9190 02BE LDS	R25,Tt+1
    01E5F 3280      CPI	R24,0x20
    01E60 E0E0      LDI	R30,0
    01E61 079E      CPC	R25,R30
    01E62 F378      BCS	0x1E52
(2017) 			DELAY80
    01E63 2422      CLR	R2
    01E64 2433      CLR	R3
    01E65 9230 02BE STS	Tt+1,R3
    01E67 9220 02BD STS	Tt,R2
    01E69 C009      RJMP	0x1E73
    01E6A 9180 02BD LDS	R24,Tt
    01E6C 9190 02BE LDS	R25,Tt+1
    01E6E 9601      ADIW	R24,1
    01E6F 9390 02BE STS	Tt+1,R25
    01E71 9380 02BD STS	Tt,R24
    01E73 9180 02BD LDS	R24,Tt
    01E75 9190 02BE LDS	R25,Tt+1
    01E77 3280      CPI	R24,0x20
    01E78 E0E0      LDI	R30,0
    01E79 079E      CPC	R25,R30
    01E7A F378      BCS	0x1E6A
(2018) 			DELAY80
    01E7B 2422      CLR	R2
    01E7C 2433      CLR	R3
    01E7D 9230 02BE STS	Tt+1,R3
    01E7F 9220 02BD STS	Tt,R2
    01E81 C009      RJMP	0x1E8B
    01E82 9180 02BD LDS	R24,Tt
    01E84 9190 02BE LDS	R25,Tt+1
    01E86 9601      ADIW	R24,1
    01E87 9390 02BE STS	Tt+1,R25
    01E89 9380 02BD STS	Tt,R24
    01E8B 9180 02BD LDS	R24,Tt
    01E8D 9190 02BE LDS	R25,Tt+1
    01E8F 3280      CPI	R24,0x20
    01E90 E0E0      LDI	R30,0
    01E91 079E      CPC	R25,R30
    01E92 F378      BCS	0x1E82
(2019) 			M1_L
    01E93 9180 0065 LDS	R24,0x65
    01E95 7F87      ANDI	R24,0xF7
    01E96 9380 0065 STS	0x65,R24
(2020) 			DELAY40
    01E98 2422      CLR	R2
    01E99 2433      CLR	R3
    01E9A 9230 02BE STS	Tt+1,R3
    01E9C 9220 02BD STS	Tt,R2
    01E9E C009      RJMP	0x1EA8
    01E9F 9180 02BD LDS	R24,Tt
    01EA1 9190 02BE LDS	R25,Tt+1
    01EA3 9601      ADIW	R24,1
    01EA4 9390 02BE STS	Tt+1,R25
    01EA6 9380 02BD STS	Tt,R24
    01EA8 9180 02BD LDS	R24,Tt
    01EAA 9190 02BE LDS	R25,Tt+1
    01EAC 3180      CPI	R24,0x10
    01EAD E0E0      LDI	R30,0
    01EAE 079E      CPC	R25,R30
    01EAF F378      BCS	0x1E9F
    01EB0 954A      DEC	R20
    01EB1 E080      LDI	R24,0
    01EB2 1784      CP	R24,R20
    01EB3 F408      BCC	0x1EB5
    01EB4 CED8      RJMP	0x1D8D
(2021) 		}
(2022)     }	       	   
(2023) 		   //结束位，一高八低，720us
(2024)  	 	    M2_H 
    01EB5 9180 0065 LDS	R24,0x65
    01EB7 6180      ORI	R24,0x10
    01EB8 9380 0065 STS	0x65,R24
(2025) 		    DELAY80
    01EBA 2422      CLR	R2
    01EBB 2433      CLR	R3
    01EBC 9230 02BE STS	Tt+1,R3
    01EBE 9220 02BD STS	Tt,R2
    01EC0 C009      RJMP	0x1ECA
    01EC1 9180 02BD LDS	R24,Tt
    01EC3 9190 02BE LDS	R25,Tt+1
    01EC5 9601      ADIW	R24,1
    01EC6 9390 02BE STS	Tt+1,R25
    01EC8 9380 02BD STS	Tt,R24
    01ECA 9180 02BD LDS	R24,Tt
    01ECC 9190 02BE LDS	R25,Tt+1
    01ECE 3280      CPI	R24,0x20
    01ECF E0E0      LDI	R30,0
    01ED0 079E      CPC	R25,R30
    01ED1 F378      BCS	0x1EC1
(2026) 	        M2_L
    01ED2 9180 0065 LDS	R24,0x65
    01ED4 7E8F      ANDI	R24,0xEF
    01ED5 9380 0065 STS	0x65,R24
(2027) 			DELAY40
    01ED7 2422      CLR	R2
    01ED8 2433      CLR	R3
    01ED9 9230 02BE STS	Tt+1,R3
    01EDB 9220 02BD STS	Tt,R2
    01EDD C009      RJMP	0x1EE7
    01EDE 9180 02BD LDS	R24,Tt
    01EE0 9190 02BE LDS	R25,Tt+1
    01EE2 9601      ADIW	R24,1
    01EE3 9390 02BE STS	Tt+1,R25
    01EE5 9380 02BD STS	Tt,R24
    01EE7 9180 02BD LDS	R24,Tt
    01EE9 9190 02BE LDS	R25,Tt+1
    01EEB 3180      CPI	R24,0x10
    01EEC E0E0      LDI	R30,0
    01EED 079E      CPC	R25,R30
    01EEE F378      BCS	0x1EDE
(2028) 	        M1_H       
    01EEF 9180 0065 LDS	R24,0x65
    01EF1 6088      ORI	R24,0x8
    01EF2 9380 0065 STS	0x65,R24
(2029)          	DELAY80
    01EF4 2422      CLR	R2
    01EF5 2433      CLR	R3
    01EF6 9230 02BE STS	Tt+1,R3
    01EF8 9220 02BD STS	Tt,R2
    01EFA C009      RJMP	0x1F04
    01EFB 9180 02BD LDS	R24,Tt
    01EFD 9190 02BE LDS	R25,Tt+1
    01EFF 9601      ADIW	R24,1
    01F00 9390 02BE STS	Tt+1,R25
    01F02 9380 02BD STS	Tt,R24
    01F04 9180 02BD LDS	R24,Tt
    01F06 9190 02BE LDS	R25,Tt+1
    01F08 3280      CPI	R24,0x20
    01F09 E0E0      LDI	R30,0
    01F0A 079E      CPC	R25,R30
    01F0B F378      BCS	0x1EFB
(2030) 			DELAY80
    01F0C 2422      CLR	R2
    01F0D 2433      CLR	R3
    01F0E 9230 02BE STS	Tt+1,R3
    01F10 9220 02BD STS	Tt,R2
    01F12 C009      RJMP	0x1F1C
    01F13 9180 02BD LDS	R24,Tt
    01F15 9190 02BE LDS	R25,Tt+1
    01F17 9601      ADIW	R24,1
    01F18 9390 02BE STS	Tt+1,R25
    01F1A 9380 02BD STS	Tt,R24
    01F1C 9180 02BD LDS	R24,Tt
    01F1E 9190 02BE LDS	R25,Tt+1
    01F20 3280      CPI	R24,0x20
    01F21 E0E0      LDI	R30,0
    01F22 079E      CPC	R25,R30
    01F23 F378      BCS	0x1F13
(2031) 			DELAY80
    01F24 2422      CLR	R2
    01F25 2433      CLR	R3
    01F26 9230 02BE STS	Tt+1,R3
    01F28 9220 02BD STS	Tt,R2
    01F2A C009      RJMP	0x1F34
    01F2B 9180 02BD LDS	R24,Tt
    01F2D 9190 02BE LDS	R25,Tt+1
    01F2F 9601      ADIW	R24,1
    01F30 9390 02BE STS	Tt+1,R25
    01F32 9380 02BD STS	Tt,R24
    01F34 9180 02BD LDS	R24,Tt
    01F36 9190 02BE LDS	R25,Tt+1
    01F38 3280      CPI	R24,0x20
    01F39 E0E0      LDI	R30,0
    01F3A 079E      CPC	R25,R30
    01F3B F378      BCS	0x1F2B
(2032) 			DELAY80
    01F3C 2422      CLR	R2
    01F3D 2433      CLR	R3
    01F3E 9230 02BE STS	Tt+1,R3
    01F40 9220 02BD STS	Tt,R2
    01F42 C009      RJMP	0x1F4C
    01F43 9180 02BD LDS	R24,Tt
    01F45 9190 02BE LDS	R25,Tt+1
    01F47 9601      ADIW	R24,1
    01F48 9390 02BE STS	Tt+1,R25
    01F4A 9380 02BD STS	Tt,R24
    01F4C 9180 02BD LDS	R24,Tt
    01F4E 9190 02BE LDS	R25,Tt+1
    01F50 3280      CPI	R24,0x20
    01F51 E0E0      LDI	R30,0
    01F52 079E      CPC	R25,R30
    01F53 F378      BCS	0x1F43
(2033) 			DELAY80
    01F54 2422      CLR	R2
    01F55 2433      CLR	R3
    01F56 9230 02BE STS	Tt+1,R3
    01F58 9220 02BD STS	Tt,R2
    01F5A C009      RJMP	0x1F64
    01F5B 9180 02BD LDS	R24,Tt
    01F5D 9190 02BE LDS	R25,Tt+1
    01F5F 9601      ADIW	R24,1
    01F60 9390 02BE STS	Tt+1,R25
    01F62 9380 02BD STS	Tt,R24
    01F64 9180 02BD LDS	R24,Tt
    01F66 9190 02BE LDS	R25,Tt+1
    01F68 3280      CPI	R24,0x20
    01F69 E0E0      LDI	R30,0
    01F6A 079E      CPC	R25,R30
    01F6B F378      BCS	0x1F5B
(2034) 			DELAY80
    01F6C 2422      CLR	R2
    01F6D 2433      CLR	R3
    01F6E 9230 02BE STS	Tt+1,R3
    01F70 9220 02BD STS	Tt,R2
    01F72 C009      RJMP	0x1F7C
    01F73 9180 02BD LDS	R24,Tt
    01F75 9190 02BE LDS	R25,Tt+1
    01F77 9601      ADIW	R24,1
    01F78 9390 02BE STS	Tt+1,R25
    01F7A 9380 02BD STS	Tt,R24
    01F7C 9180 02BD LDS	R24,Tt
    01F7E 9190 02BE LDS	R25,Tt+1
    01F80 3280      CPI	R24,0x20
    01F81 E0E0      LDI	R30,0
    01F82 079E      CPC	R25,R30
    01F83 F378      BCS	0x1F73
(2035) 			DELAY80
    01F84 2422      CLR	R2
    01F85 2433      CLR	R3
    01F86 9230 02BE STS	Tt+1,R3
    01F88 9220 02BD STS	Tt,R2
    01F8A C009      RJMP	0x1F94
    01F8B 9180 02BD LDS	R24,Tt
    01F8D 9190 02BE LDS	R25,Tt+1
    01F8F 9601      ADIW	R24,1
    01F90 9390 02BE STS	Tt+1,R25
    01F92 9380 02BD STS	Tt,R24
    01F94 9180 02BD LDS	R24,Tt
    01F96 9190 02BE LDS	R25,Tt+1
    01F98 3280      CPI	R24,0x20
    01F99 E0E0      LDI	R30,0
    01F9A 079E      CPC	R25,R30
    01F9B F378      BCS	0x1F8B
(2036) 			M1_L
    01F9C 9180 0065 LDS	R24,0x65
    01F9E 7F87      ANDI	R24,0xF7
    01F9F 9380 0065 STS	0x65,R24
(2037) 			DELAY40
    01FA1 2422      CLR	R2
    01FA2 2433      CLR	R3
    01FA3 9230 02BE STS	Tt+1,R3
    01FA5 9220 02BD STS	Tt,R2
    01FA7 C009      RJMP	0x1FB1
    01FA8 9180 02BD LDS	R24,Tt
    01FAA 9190 02BE LDS	R25,Tt+1
    01FAC 9601      ADIW	R24,1
    01FAD 9390 02BE STS	Tt+1,R25
    01FAF 9380 02BD STS	Tt,R24
    01FB1 9180 02BD LDS	R24,Tt
    01FB3 9190 02BE LDS	R25,Tt+1
    01FB5 3180      CPI	R24,0x10
    01FB6 E0E0      LDI	R30,0
    01FB7 079E      CPC	R25,R30
    01FB8 F378      BCS	0x1FA8
(2038) 	
(2039)  	EIFR|=0x08;//清INT3中断标志 
    01FB9 B788      IN	R24,0x38
    01FBA 6088      ORI	R24,0x8
    01FBB BF88      OUT	0x38,R24
(2040)  	SREG|=0x80; //开总中断
    01FBC 9478      BSET	7
    01FBD 9149      LD	R20,Y+
    01FBE 9508      RET
(2041) }
(2042) 
(2043) 
(2044) 
(2045) void EEPROM_write(unsigned int Address,unsigned char Data)  	//内部EEPROM写
(2046) {//时钟频率为1MHz，典型的EEPROM字节写耗时约8.5ms
(2047)     while(EECR&0x02);                   // 等待上一次写操作结束
_EEPROM_write:
  Data                 --> R18
  Address              --> R16
    01FBF 99E1      SBIC	0x1C,1
    01FC0 CFFE      RJMP	_EEPROM_write
(2048)     EEAR=Address;
    01FC1 BB1F      OUT	0x1F,R17
    01FC2 BB0E      OUT	0x1E,R16
(2049)     EEDR=Data;                        	// 设置地址和数据寄存器
    01FC3 BB2D      OUT	0x1D,R18
(2050)     EECR|=0x04;                         //置位EEMWE
    01FC4 9AE2      SBI	0x1C,2
(2051)     EECR|=0x02;                         //置位EEWE 以启动写操作
    01FC5 9AE1      SBI	0x1C,1
    01FC6 9508      RET
(2052) }
(2053) 
(2054) unsigned char EEPROM_read(unsigned int Address)  				//内部EEPROM读
(2055) {
(2056)     while(EECR&0x02);      				//等待上一次操作结束
_EEPROM_read:
  Address              --> R16
    01FC7 99E1      SBIC	0x1C,1
    01FC8 CFFE      RJMP	_EEPROM_read
(2057)     EEAR = Address;                     //设置地址寄存器						
    01FC9 BB1F      OUT	0x1F,R17
    01FCA BB0E      OUT	0x1E,R16
(2058) 	EECR|=0x01;             			//设置EERE 以启动读操作
    01FCB 9AE0      SBI	0x1C,0
(2059)     return EEDR;                   		//自数据寄存器返回数据
    01FCC B30D      IN	R16,0x1D
    01FCD 9508      RET
_crc16:
  ii                   --> R20
  ch                   --> R10
  cl                   --> R22
  savelo               --> R14
  savehi               --> Y,+0
  flag                 --> R12
  length               --> R18
  r_data               --> Y,+11
    01FCE 940E 2021 CALL	push_arg4
    01FD0 940E 204C CALL	push_xgsetF0FC
    01FD2 9721      SBIW	R28,1
(2060) }    
(2061) 
(2062) void crc16(unsigned char r_data[],unsigned int length)
(2063) {
(2064)         unsigned char cl,ch;
(2065)         unsigned char savehi,savelo;
(2066)         int ii,flag;
(2067)         crc16hi=0xFF;
    01FD3 EF8F      LDI	R24,0xFF
    01FD4 9380 0121 STS	crc16hi,R24
(2068)         crc16lo=0xFF;
    01FD6 9380 0120 STS	crc16lo,R24
(2069)         cl=0x1;
    01FD8 E061      LDI	R22,1
(2070)         ch=0xA0;
    01FD9 EA80      LDI	R24,0xA0
    01FDA 2EA8      MOV	R10,R24
(2071)         for (ii=0;ii<length-2;ii++)
    01FDB 2744      CLR	R20
    01FDC 2755      CLR	R21
    01FDD C038      RJMP	0x2016
(2072)         {
(2073)             crc16lo=(crc16lo ^ r_data[ii]);
    01FDE 01FA      MOVW	R30,R20
    01FDF 840B      LDD	R0,Y+11
    01FE0 841C      LDD	R1,Y+12
    01FE1 0DE0      ADD	R30,R0
    01FE2 1DF1      ADC	R31,R1
    01FE3 8020      LD	R2,Z
    01FE4 9030 0120 LDS	R3,crc16lo
    01FE6 2432      EOR	R3,R2
    01FE7 9230 0120 STS	crc16lo,R3
(2074)                 for (flag=0;flag<8;flag++)
    01FE9 24CC      CLR	R12
    01FEA 24DD      CLR	R13
(2075)                 {
(2076)                        savehi=crc16hi;
    01FEB 9020 0121 LDS	R2,crc16hi
    01FED 8228      ST	Y,R2
(2077)                         savelo=crc16lo;
    01FEE 90E0 0120 LDS	R14,crc16lo
(2078)                        crc16hi=(crc16hi>>1);
    01FF0 9426      LSR	R2
    01FF1 9220 0121 STS	crc16hi,R2
(2079)                        crc16lo=(crc16lo>>1);
    01FF3 2C2E      MOV	R2,R14
    01FF4 9426      LSR	R2
    01FF5 9220 0120 STS	crc16lo,R2
(2080)                         if ((savehi & 0x01)==0x01)
    01FF7 8188      LD	R24,Y
    01FF8 7081      ANDI	R24,1
    01FF9 3081      CPI	R24,1
    01FFA F421      BNE	0x1FFF
(2081)                                 crc16lo=(crc16lo | 0x80);
    01FFB 2D82      MOV	R24,R2
    01FFC 6880      ORI	R24,0x80
    01FFD 9380 0120 STS	crc16lo,R24
(2082)                         if        ((savelo & 0x01)==0x01)
    01FFF 2D8E      MOV	R24,R14
    02000 7081      ANDI	R24,1
    02001 3081      CPI	R24,1
    02002 F451      BNE	0x200D
(2083)                         {
(2084)                                 crc16hi = (crc16hi ^ ch);
    02003 9020 0121 LDS	R2,crc16hi
    02005 242A      EOR	R2,R10
    02006 9220 0121 STS	crc16hi,R2
(2085) 								crc16lo = (crc16lo ^ cl);
FILE: <library>
    02008 9020 0120 LDS	R2,crc16lo
    0200A 2626      EOR	R2,R22
    0200B 9220 0120 STS	crc16lo,R2
    0200D 01C6      MOVW	R24,R12
    0200E 9601      ADIW	R24,1
    0200F 016C      MOVW	R12,R24
    02010 3088      CPI	R24,0x8
    02011 E0E0      LDI	R30,0
    02012 079E      CPC	R25,R30
    02013 F2BC      BLT	0x1FEB
    02014 5F4F      SUBI	R20,0xFF
    02015 4F5F      SBCI	R21,0xFF
    02016 01C9      MOVW	R24,R18
    02017 9702      SBIW	R24,2
    02018 1748      CP	R20,R24
    02019 0759      CPC	R21,R25
    0201A F408      BCC	0x201C
    0201B CFC2      RJMP	0x1FDE
    0201C 9621      ADIW	R28,1
    0201D 940E 2041 CALL	pop_xgsetF0FC
    0201F 9624      ADIW	R28,4
    02020 9508      RET
push_arg4:
    02021 933A      ST	-Y,R19
    02022 932A      ST	-Y,R18
push_arg2:
    02023 931A      ST	-Y,R17
    02024 930A      ST	-Y,R16
    02025 9508      RET
asr16:
    02026 2322      TST	R18
    02027 F021      BEQ	0x202C
    02028 9515      ASR	R17
    02029 9507      ROR	R16
    0202A 952A      DEC	R18
    0202B CFFA      RJMP	asr16
    0202C 9508      RET
elpm32:
    0202D 93EA      ST	-Y,R30
    0202E 93FA      ST	-Y,R31
    0202F 920A      ST	-Y,R0
    02030 2FE0      MOV	R30,R16
    02031 2FF1      MOV	R31,R17
    02032 95D8      ELPM
    02033 2D00      MOV	R16,R0
    02034 9631      ADIW	R30,1
    02035 95D8      ELPM
    02036 2D10      MOV	R17,R0
    02037 9631      ADIW	R30,1
    02038 95D8      ELPM
    02039 2D20      MOV	R18,R0
    0203A 9631      ADIW	R30,1
    0203B 95D8      ELPM
    0203C 2D30      MOV	R19,R0
    0203D 9009      LD	R0,Y+
    0203E 91F9      LD	R31,Y+
    0203F 91E9      LD	R30,Y+
    02040 9508      RET
pop_xgsetF0FC:
    02041 90A9      LD	R10,Y+
    02042 90B9      LD	R11,Y+
    02043 90C9      LD	R12,Y+
    02044 90D9      LD	R13,Y+
    02045 90E9      LD	R14,Y+
    02046 90F9      LD	R15,Y+
    02047 9149      LD	R20,Y+
    02048 9159      LD	R21,Y+
    02049 9169      LD	R22,Y+
    0204A 9179      LD	R23,Y+
    0204B 9508      RET
push_xgsetF0FC:
    0204C 937A      ST	-Y,R23
    0204D 936A      ST	-Y,R22
push_xgset30FC:
    0204E 935A      ST	-Y,R21
    0204F 934A      ST	-Y,R20
push_xgset00FC:
    02050 92FA      ST	-Y,R15
    02051 92EA      ST	-Y,R14
push_xgset003C:
    02052 92DA      ST	-Y,R13
    02053 92CA      ST	-Y,R12
    02054 92BA      ST	-Y,R11
    02055 92AA      ST	-Y,R10
    02056 9508      RET
push_xgsetF00C:
    02057 937A      ST	-Y,R23
    02058 936A      ST	-Y,R22
    02059 935A      ST	-Y,R21
    0205A 934A      ST	-Y,R20
    0205B 92BA      ST	-Y,R11
    0205C 92AA      ST	-Y,R10
    0205D 9508      RET
pop_xgsetF00C:
    0205E 90A9      LD	R10,Y+
    0205F 90B9      LD	R11,Y+
    02060 9149      LD	R20,Y+
    02061 9159      LD	R21,Y+
    02062 9169      LD	R22,Y+
    02063 9179      LD	R23,Y+
    02064 9508      RET
push_xgsetF03C:
    02065 937A      ST	-Y,R23
    02066 936A      ST	-Y,R22
    02067 935A      ST	-Y,R21
    02068 934A      ST	-Y,R20
    02069 92DA      ST	-Y,R13
    0206A 92CA      ST	-Y,R12
    0206B 92BA      ST	-Y,R11
    0206C 92AA      ST	-Y,R10
    0206D 9508      RET
pop_xgsetF03C:
    0206E 90A9      LD	R10,Y+
    0206F 90B9      LD	R11,Y+
    02070 90C9      LD	R12,Y+
    02071 90D9      LD	R13,Y+
    02072 9149      LD	R20,Y+
    02073 9159      LD	R21,Y+
    02074 9169      LD	R22,Y+
    02075 9179      LD	R23,Y+
    02076 9508      RET
neg32:
    02077 9500      COM	R16
    02078 9510      COM	R17
    02079 9520      COM	R18
    0207A 9530      COM	R19
    0207B 5F0F      SUBI	R16,0xFF
    0207C 4F1F      SBCI	R17,0xFF
    0207D 4F2F      SBCI	R18,0xFF
    0207E 4F3F      SBCI	R19,0xFF
    0207F 9508      RET
lsl32:
    02080 920F      PUSH	R0
    02081 9009      LD	R0,Y+
    02082 2000      TST	R0
    02083 F031      BEQ	0x208A
    02084 0F00      LSL	R16
    02085 1F11      ROL	R17
    02086 1F22      ROL	R18
    02087 1F33      ROL	R19
    02088 940A      DEC	R0
    02089 CFF8      RJMP	0x2082
    0208A 900F      POP	R0
    0208B 9508      RET
lsl8:
    0208C 2311      TST	R17
    0208D F019      BEQ	0x2091
    0208E 0F00      LSL	R16
    0208F 951A      DEC	R17
    02090 CFFB      RJMP	lsl8
    02091 9508      RET
lsr16:
    02092 2322      TST	R18
    02093 F021      BEQ	0x2098
    02094 9516      LSR	R17
    02095 9507      ROR	R16
    02096 952A      DEC	R18
    02097 CFFA      RJMP	lsr16
    02098 9508      RET
lsr32:
    02099 920F      PUSH	R0
    0209A 9009      LD	R0,Y+
    0209B 2000      TST	R0
    0209C F031      BEQ	0x20A3
    0209D 9536      LSR	R19
    0209E 9527      ROR	R18
    0209F 9517      ROR	R17
    020A0 9507      ROR	R16
    020A1 940A      DEC	R0
    020A2 CFF8      RJMP	0x209B
    020A3 900F      POP	R0
    020A4 9508      RET
fpint:
    020A5 924A      ST	-Y,R4
    020A6 925A      ST	-Y,R5
    020A7 926A      ST	-Y,R6
    020A8 938A      ST	-Y,R24
    020A9 940E 21A5 CALL	unpacku
    020AB F111      BEQ	0x20CE
    020AC 2055      TST	R5
    020AD F0E2      BMI	0x20CA
    020AE E18F      LDI	R24,0x1F
    020AF 1648      CP	R4,R24
    020B0 F4C0      BCC	0x20C9
    020B1 E187      LDI	R24,0x17
    020B2 1648      CP	R4,R24
    020B3 F0D1      BEQ	0x20CE
    020B4 F458      BCC	0x20C0
    020B5 9441      NEG	R4
    020B6 EE89      LDI	R24,0xE9
    020B7 1A48      SUB	R4,R24
    020B8 C005      RJMP	0x20BE
    020B9 9535      ASR	R19
    020BA 9527      ROR	R18
    020BB 9517      ROR	R17
    020BC 9507      ROR	R16
    020BD 944A      DEC	R4
    020BE F7D1      BNE	0x20B9
    020BF C00E      RJMP	0x20CE
    020C0 E187      LDI	R24,0x17
    020C1 1A48      SUB	R4,R24
    020C2 0F00      LSL	R16
    020C3 1F11      ROL	R17
    020C4 1F22      ROL	R18
    020C5 1F33      ROL	R19
    020C6 944A      DEC	R4
    020C7 F7D1      BNE	0x20C2
    020C8 C005      RJMP	0x20CE
    020C9 E73F      LDI	R19,0x7F
    020CA 2F23      MOV	R18,R19
    020CB 2F13      MOV	R17,R19
    020CC 2F03      MOV	R16,R19
    020CD C004      RJMP	0x20D2
    020CE 2066      TST	R6
    020CF F011      BEQ	0x20D2
    020D0 940E 2077 CALL	neg32
    020D2 9189      LD	R24,Y+
    020D3 9069      LD	R6,Y+
    020D4 9059      LD	R5,Y+
    020D5 9049      LD	R4,Y+
    020D6 9508      RET
uint2fp:
    020D7 9468      BSET	6
    020D8 C001      RJMP	0x20DA
int2fp:
    020D9 94E8      BCLR	6
    020DA 2722      CLR	R18
    020DB 2733      CLR	R19
    020DC F046      BRTS	0x20E5
    020DD FD17      SBRC	R17,7
    020DE 9520      COM	R18
    020DF FD17      SBRC	R17,7
    020E0 9530      COM	R19
    020E1 C003      RJMP	0x20E5
ulong2fp:
    020E2 9468      BSET	6
    020E3 C001      RJMP	0x20E5
long2fp:
    020E4 94E8      BCLR	6
    020E5 924A      ST	-Y,R4
    020E6 925A      ST	-Y,R5
    020E7 926A      ST	-Y,R6
    020E8 938A      ST	-Y,R24
    020E9 E187      LDI	R24,0x17
    020EA 2E48      MOV	R4,R24
    020EB 2455      CLR	R5
    020EC 2466      CLR	R6
    020ED F036      BRTS	0x20F4
    020EE 2333      TST	R19
    020EF F422      BPL	0x20F4
    020F0 940E 2077 CALL	neg32
    020F2 E880      LDI	R24,0x80
    020F3 2E68      MOV	R6,R24
    020F4 940E 21BE CALL	normalize_and_pack
    020F6 9189      LD	R24,Y+
    020F7 9069      LD	R6,Y+
    020F8 9059      LD	R5,Y+
    020F9 9049      LD	R4,Y+
    020FA 9508      RET
fpdiv1:
    020FB 93FA      ST	-Y,R31
    020FC 93EA      ST	-Y,R30
    020FD 81EA      LDD	R30,Y+2
    020FE 81FB      LDD	R31,Y+3
    020FF D027      RCALL	0x2127
    02100 91E9      LD	R30,Y+
    02101 91F9      LD	R31,Y+
    02102 9622      ADIW	R28,2
    02103 9508      RET
fpdiv2:
    02104 93FA      ST	-Y,R31
    02105 93EA      ST	-Y,R30
    02106 2FEC      MOV	R30,R28
    02107 2FFD      MOV	R31,R29
    02108 9632      ADIW	R30,2
    02109 D01D      RCALL	0x2127
    0210A 91E9      LD	R30,Y+
    0210B 91F9      LD	R31,Y+
    0210C 9624      ADIW	R28,4
    0210D 9508      RET
fpdiv1x:
    0210E 93FA      ST	-Y,R31
    0210F 93EA      ST	-Y,R30
    02110 81EA      LDD	R30,Y+2
    02111 81FB      LDD	R31,Y+3
    02112 D014      RCALL	0x2127
    02113 91E9      LD	R30,Y+
    02114 91F9      LD	R31,Y+
    02115 8339      STD	Y+1,R19
    02116 8328      ST	Y,R18
    02117 931A      ST	-Y,R17
    02118 930A      ST	-Y,R16
    02119 9508      RET
fpdiv2x:
    0211A 93FA      ST	-Y,R31
    0211B 93EA      ST	-Y,R30
    0211C 2FEC      MOV	R30,R28
    0211D 2FFD      MOV	R31,R29
    0211E 9632      ADIW	R30,2
    0211F D007      RCALL	0x2127
    02120 91E9      LD	R30,Y+
    02121 91F9      LD	R31,Y+
    02122 833B      STD	Y+3,R19
    02123 832A      STD	Y+2,R18
    02124 8319      STD	Y+1,R17
    02125 8308      ST	Y,R16
    02126 9508      RET
    02127 920A      ST	-Y,R0
    02128 921A      ST	-Y,R1
    02129 922A      ST	-Y,R2
    0212A 923A      ST	-Y,R3
    0212B 940E 2203 CALL	saveFPRegs
    0212D 933A      ST	-Y,R19
    0212E 932A      ST	-Y,R18
    0212F 931A      ST	-Y,R17
    02130 930A      ST	-Y,R16
    02131 8100      LD	R16,Z
    02132 8111      LDD	R17,Z+1
    02133 8122      LDD	R18,Z+2
    02134 8133      LDD	R19,Z+3
    02135 940E 21A5 CALL	unpacku
    02137 F409      BNE	0x2139
    02138 C057      RJMP	0x2190
    02139 2CE6      MOV	R14,R6
    0213A 2CD5      MOV	R13,R5
    0213B 2CC4      MOV	R12,R4
    0213C 2EB3      MOV	R11,R19
    0213D 2EA2      MOV	R10,R18
    0213E 2E91      MOV	R9,R17
    0213F 2E80      MOV	R8,R16
    02140 9109      LD	R16,Y+
    02141 9119      LD	R17,Y+
    02142 9129      LD	R18,Y+
    02143 9139      LD	R19,Y+
    02144 940E 21A5 CALL	unpacku
    02146 F1A1      BEQ	0x217B
    02147 246E      EOR	R6,R14
    02148 184C      SUB	R4,R12
    02149 085D      SBC	R5,R13
    0214A E880      LDI	R24,0x80
    0214B 1648      CP	R4,R24
    0214C 0653      CPC	R5,R19
    0214D F00C      BLT	0x214F
    0214E C033      RJMP	0x2182
    0214F E881      LDI	R24,0x81
    02150 1648      CP	R4,R24
    02151 EF8F      LDI	R24,0xFF
    02152 0658      CPC	R5,R24
    02153 F40C      BGE	0x2155
    02154 C036      RJMP	0x218B
    02155 E280      LDI	R24,0x20
    02156 2433      CLR	R3
    02157 2E23      MOV	R2,R19
    02158 2E12      MOV	R1,R18
    02159 2E01      MOV	R0,R17
    0215A 2F30      MOV	R19,R16
    0215B 2722      CLR	R18
    0215C 2711      CLR	R17
    0215D 2700      CLR	R16
    0215E 9426      LSR	R2
    0215F 9417      ROR	R1
    02160 9407      ROR	R0
    02161 9537      ROR	R19
    02162 9527      ROR	R18
    02163 0F00      LSL	R16
    02164 1F11      ROL	R17
    02165 1F22      ROL	R18
    02166 1F33      ROL	R19
    02167 1C00      ROL	R0
    02168 1C11      ROL	R1
    02169 1C22      ROL	R2
    0216A 1C33      ROL	R3
    0216B F028      BCS	0x2171
    0216C 1808      SUB	R0,R8
    0216D 0819      SBC	R1,R9
    0216E 082A      SBC	R2,R10
    0216F 083B      SBC	R3,R11
    02170 C004      RJMP	0x2175
    02171 0C08      ADD	R0,R8
    02172 1C19      ADC	R1,R9
    02173 1C2A      ADC	R2,R10
    02174 1C3B      ADC	R3,R11
    02175 F00A      BMI	0x2177
    02176 6001      ORI	R16,1
    02177 958A      DEC	R24
    02178 F751      BNE	0x2163
    02179 940E 21BE CALL	normalize_and_pack
    0217B 940E 2212 CALL	restoreFPRegs
    0217D 9039      LD	R3,Y+
    0217E 9029      LD	R2,Y+
    0217F 9019      LD	R1,Y+
    02180 9009      LD	R0,Y+
    02181 9508      RET
    02182 EF0F      LDI	R16,0xFF
    02183 2F10      MOV	R17,R16
    02184 E72F      LDI	R18,0x7F
    02185 E73F      LDI	R19,0x7F
    02186 2066      TST	R6
    02187 F399      BEQ	0x217B
    02188 940E 2077 CALL	neg32
    0218A CFF0      RJMP	0x217B
    0218B 2700      CLR	R16
    0218C 2F10      MOV	R17,R16
    0218D 2F20      MOV	R18,R16
    0218E 2F30      MOV	R19,R16
    0218F CFEB      RJMP	0x217B
    02190 9109      LD	R16,Y+
    02191 9119      LD	R17,Y+
    02192 9129      LD	R18,Y+
    02193 9139      LD	R19,Y+
    02194 CFED      RJMP	0x2182
unpacks:
    02195 D00F      RCALL	unpacku
    02196 F029      BEQ	0x219C
    02197 2066      TST	R6
    02198 F011      BEQ	0x219B
    02199 940E 2077 CALL	neg32
    0219B 9498      BCLR	1
    0219C 9508      RET
tstR16_R19:
    0219D 2300      TST	R16
    0219E F429      BNE	0x21A4
    0219F 2311      TST	R17
    021A0 F419      BNE	0x21A4
    021A1 2322      TST	R18
    021A2 F409      BNE	0x21A4
    021A3 2333      TST	R19
    021A4 9508      RET
unpacku:
    021A5 DFF7      RCALL	tstR16_R19
    021A6 F099      BEQ	0x21BA
    021A7 938A      ST	-Y,R24
    021A8 2E63      MOV	R6,R19
    021A9 E880      LDI	R24,0x80
    021AA 2268      AND	R6,R24
    021AB 0F22      LSL	R18
    021AC 1F33      ROL	R19
    021AD 2E43      MOV	R4,R19
    021AE E78F      LDI	R24,0x7F
    021AF 1A48      SUB	R4,R24
    021B0 2455      CLR	R5
    021B1 2788      CLR	R24
    021B2 0A58      SBC	R5,R24
    021B3 9526      LSR	R18
    021B4 E830      LDI	R19,0x80
    021B5 2B23      OR	R18,R19
    021B6 2733      CLR	R19
    021B7 9189      LD	R24,Y+
    021B8 9498      BCLR	1
    021B9 9508      RET
    021BA 2444      CLR	R4
    021BB 2455      CLR	R5
    021BC 2466      CLR	R6
    021BD 9508      RET
normalize_and_pack:
    021BE DFDE      RCALL	tstR16_R19
    021BF F409      BNE	0x21C1
    021C0 9508      RET
    021C1 93AA      ST	-Y,R26
    021C2 93BA      ST	-Y,R27
    021C3 01D2      MOVW	R26,R4
    021C4 939A      ST	-Y,R25
    021C5 938A      ST	-Y,R24
    021C6 E78E      LDI	R24,0x7E
    021C7 E090      LDI	R25,0
    021C8 2333      TST	R19
    021C9 F049      BEQ	0x21D3
    021CA 9536      LSR	R19
    021CB 9527      ROR	R18
    021CC 9517      ROR	R17
    021CD 9507      ROR	R16
    021CE 17A8      CP	R26,R24
    021CF 07B9      CPC	R27,R25
    021D0 F4CC      BGE	0x21EA
    021D1 9611      ADIW	R26,1
    021D2 CFF5      RJMP	0x21C8
    021D3 9580      COM	R24
    021D4 9590      COM	R25
    021D5 9601      ADIW	R24,1
    021D6 2322      TST	R18
    021D7 F0BA      BMI	0x21EF
    021D8 0F00      LSL	R16
    021D9 1F11      ROL	R17
    021DA 1F22      ROL	R18
    021DB 17A8      CP	R26,R24
    021DC 07B9      CPC	R27,R25
    021DD F014      BLT	0x21E0
    021DE 9711      SBIW	R26,1
    021DF CFF6      RJMP	0x21D6
    021E0 2700      CLR	R16
    021E1 2711      CLR	R17
    021E2 2722      CLR	R18
    021E3 2733      CLR	R19
    021E4 9189      LD	R24,Y+
    021E5 9199      LD	R25,Y+
    021E6 012D      MOVW	R4,R26
    021E7 91B9      LD	R27,Y+
    021E8 91A9      LD	R26,Y+
    021E9 9508      RET
    021EA 2733      CLR	R19
    021EB EF0F      LDI	R16,0xFF
    021EC 2F10      MOV	R17,R16
    021ED E72F      LDI	R18,0x7F
    021EE 2F32      MOV	R19,R18
    021EF 9189      LD	R24,Y+
    021F0 9199      LD	R25,Y+
    021F1 012D      MOVW	R4,R26
    021F2 C002      RJMP	0x21F5
pack:
    021F3 93AA      ST	-Y,R26
    021F4 93BA      ST	-Y,R27
    021F5 DFA7      RCALL	tstR16_R19
    021F6 F049      BEQ	0x2200
    021F7 01D2      MOVW	R26,R4
    021F8 58A1      SUBI	R26,0x81
    021F9 4FBF      SBCI	R27,0xFF
    021FA 012D      MOVW	R4,R26
    021FB 2D34      MOV	R19,R4
    021FC 0F22      LSL	R18
    021FD 9536      LSR	R19
    021FE 9527      ROR	R18
    021FF 2936      OR	R19,R6
    02200 91B9      LD	R27,Y+
    02201 91A9      LD	R26,Y+
    02202 9508      RET
saveFPRegs:
    02203 924A      ST	-Y,R4
    02204 925A      ST	-Y,R5
    02205 926A      ST	-Y,R6
    02206 927A      ST	-Y,R7
    02207 928A      ST	-Y,R8
    02208 929A      ST	-Y,R9
    02209 92AA      ST	-Y,R10
    0220A 92BA      ST	-Y,R11
    0220B 92CA      ST	-Y,R12
    0220C 92DA      ST	-Y,R13
    0220D 92EA      ST	-Y,R14
    0220E 92FA      ST	-Y,R15
    0220F 938A      ST	-Y,R24
    02210 939A      ST	-Y,R25
    02211 9508      RET
restoreFPRegs:
    02212 9199      LD	R25,Y+
    02213 9189      LD	R24,Y+
    02214 90F9      LD	R15,Y+
    02215 90E9      LD	R14,Y+
    02216 90D9      LD	R13,Y+
    02217 90C9      LD	R12,Y+
    02218 90B9      LD	R11,Y+
    02219 90A9      LD	R10,Y+
    0221A 9099      LD	R9,Y+
    0221B 9089      LD	R8,Y+
    0221C 9079      LD	R7,Y+
    0221D 9069      LD	R6,Y+
    0221E 9059      LD	R5,Y+
    0221F 9049      LD	R4,Y+
    02220 9508      RET
fpmule:
    02221 940E 2203 CALL	saveFPRegs
    02223 93AA      ST	-Y,R26
    02224 93BA      ST	-Y,R27
    02225 940E 21A5 CALL	unpacku
    02227 F1E1      BEQ	0x2264
    02228 2CE6      MOV	R14,R6
    02229 2CD5      MOV	R13,R5
    0222A 2CC4      MOV	R12,R4
    0222B 2EB3      MOV	R11,R19
    0222C 2EA2      MOV	R10,R18
    0222D 2E91      MOV	R9,R17
    0222E 2E80      MOV	R8,R16
    0222F 8100      LD	R16,Z
    02230 8111      LDD	R17,Z+1
    02231 8122      LDD	R18,Z+2
    02232 8133      LDD	R19,Z+3
    02233 940E 21A5 CALL	unpacku
    02235 F171      BEQ	0x2264
    02236 246E      EOR	R6,R14
    02237 0C4C      ADD	R4,R12
    02238 1C5D      ADC	R5,R13
    02239 E880      LDI	R24,0x80
    0223A 1648      CP	R4,R24
    0223B 0653      CPC	R5,R19
    0223C F564      BGE	0x2269
    0223D E881      LDI	R24,0x81
    0223E 1648      CP	R4,R24
    0223F EF8F      LDI	R24,0xFF
    02240 0658      CPC	R5,R24
    02241 F16C      BLT	0x226F
    02242 9EA2      MUL	R10,R18
    02243 2DB1      MOV	R27,R1
    02244 2DA0      MOV	R26,R0
    02245 9E91      MUL	R9,R17
    02246 2D91      MOV	R25,R1
    02247 2D80      MOV	R24,R0
    02248 9EA0      MUL	R10,R16
    02249 0D80      ADD	R24,R0
    0224A 1D91      ADC	R25,R1
    0224B 1FA3      ADC	R26,R19
    0224C 1FB3      ADC	R27,R19
    0224D 9E82      MUL	R8,R18
    0224E 0D80      ADD	R24,R0
    0224F 1D91      ADC	R25,R1
    02250 1FA3      ADC	R26,R19
    02251 1FB3      ADC	R27,R19
    02252 9E92      MUL	R9,R18
    02253 0D90      ADD	R25,R0
    02254 1DA1      ADC	R26,R1
    02255 1FB3      ADC	R27,R19
    02256 9EA1      MUL	R10,R17
    02257 0D90      ADD	R25,R0
    02258 1DA1      ADC	R26,R1
    02259 1FB3      ADC	R27,R19
    0225A 2F2B      MOV	R18,R27
    0225B 2F1A      MOV	R17,R26
    0225C 2F09      MOV	R16,R25
    0225D 0F88      LSL	R24
    0225E 1F00      ROL	R16
    0225F 1F11      ROL	R17
    02260 1F22      ROL	R18
    02261 1F33      ROL	R19
    02262 940E 21BE CALL	normalize_and_pack
    02264 91B9      LD	R27,Y+
    02265 91A9      LD	R26,Y+
    02266 940E 2212 CALL	restoreFPRegs
    02268 9508      RET
    02269 EF0F      LDI	R16,0xFF
    0226A 2F10      MOV	R17,R16
    0226B E72F      LDI	R18,0x7F
    0226C E78F      LDI	R24,0x7F
    0226D 2E48      MOV	R4,R24
    0226E CFF5      RJMP	0x2264
    0226F 2700      CLR	R16
    02270 2F10      MOV	R17,R16
    02271 2F20      MOV	R18,R16
    02272 2F30      MOV	R19,R16
    02273 CFF0      RJMP	0x2264
fpmule1:
    02274 93FA      ST	-Y,R31
    02275 93EA      ST	-Y,R30
    02276 81EA      LDD	R30,Y+2
    02277 81FB      LDD	R31,Y+3
    02278 940E 2221 CALL	fpmule
    0227A 91E9      LD	R30,Y+
    0227B 91F9      LD	R31,Y+
    0227C 9622      ADIW	R28,2
    0227D 9508      RET
