/**************************************************
SZTA-5
//0718:
1、改堵转时间判断为1000次
2、单片机内部自行判断水嘴是否对接,从而是否拒绝收放或调节
3、有电机转动时不进行磁定位线圈供电，但仍采样，保证数据帧上传时间上基本一致。
//0722
1、取消电机动作前的离合传感器采样值判断
2、修正电机状态显示错误
**************************************************/
#include <iom128v.h>								   	
#include <macros.h>
#include <stdio.h>

#define  BB     0x30        //固件版本号

#define M1_L    PORTC&=0xfe;//C0口为M1，其他引脚电平不变
#define M1_H    PORTC|=0x01;
#define M2_L    PORTC&=0xfd;//C1口为M2，其他引脚电平不变
#define M2_H    PORTC|=0x02;

#define DIR_H   PORTA|=0x20;
#define DIR_L   PORTA&=0xdf;
#define PWM_H   PORTA|=0x10;
#define PWM_L   PORTA&=0Xef;

#define BREAK_OFF PORTA|=0x08; PORTA&=0xdf;
#define BREAK_ON PORTA&=0xf7;

#define CCL_ON PORTE|=0x20;
#define CCL_OFF PORTB&=0xdf;

#define SHSCL_L PORTD&=0xbf;
#define SHSCL_H PORTD|=0x40;
#define SHSDA_L PORTD&=0x7f;
#define SHSDA_H PORTD|=0x80;


#define DELAY5 for(Tt=0;Tt<2;Tt++);
#define DELAY50 for(Tt=0;Tt<21;Tt++); //50uS延迟
#define DELAY20 for(Tt=0;Tt<8;Tt++); 
#define DELAY40 for(Tt=0;Tt<16;Tt++); 
#define DELAY400 for(Tt=0;Tt<168;Tt++);
#define DELAY397 for(Tt=0;Tt<165;Tt++);
#define DELAY367 for(Tt=0;Tt<141;Tt++);
#define DELAY300 for(Tt=0;Tt<126;Tt++);
#define DELAY298 for(Tt=0;Tt<125;Tt++);
#define DELAY288 for(Tt=0;Tt<121;Tt++);
#define DELAY268 for(Tt=0;Tt<113;Tt++);
#define DELAY100 for(Tt=0;Tt<42;Tt++); 
#define DELAY89 for(Tt=0;Tt<36;Tt++); 
#define DELAY10 for(Tt=0;Tt<4;Tt++); 
#define DELAY150 for(Tt=0;Tt<63;Tt++);
#define DELAY200 for(Tt=0;Tt<84;Tt++);
#define DELAY190 for(Tt=0;Tt<80;Tt++);
#define DELAY170 for(Tt=0;Tt<72;Tt++);
#define DELAY198 for(Tt=0;Tt<84;Tt++);

 
#define DBG 0

unsigned char T_Flag,MT_Flag,E_flag,MotorON,MotorDir;//调试/异常标志
unsigned int Timer0Counter;//定时器0超过4ms时的计数
unsigned int Timer2Counter;//定时器2超过8s时的计数
unsigned char Uart0RxData[16],Uart1RxData[16],AdData[514],EE[216];//串口接收数据缓存，AD采样数据缓存
unsigned char Rx[18];//解码接收9位共18个半位
unsigned int  T_dat,R_dat;//曼码发送数据
unsigned char T_com;//曼码发送命令
unsigned char TimeOutFlag;//发送超时标志
unsigned char T_dat_buf[22];//曼码发送缓冲 
unsigned int dat2;//电机状态缓存，堵转标志
unsigned char dat1; //接受命令缓存
unsigned int DataFlag;//下发标定系数开始标志
unsigned Int_count;
unsigned IntFlag;//接收帧状态
unsigned char Uart0RxCounter;Uart1RxCounter;
unsigned int AdCounter;
unsigned char RxBit[2];
unsigned int MotorData;
unsigned int Tt,k; 
unsigned int XYData;
unsigned char zf=0;
long ADSDataAdd0,ADSDataAdd1;
int  ADSDataAvr,p;

unsigned char EEPAdd,coeff_len,coeff_count;//接收系数存放地址索引，接收系数长度，接收系数计数
unsigned int CompCounter,Int1Counter;
unsigned int ta,tb;

char flash_buf[128]; //FALSH页缓冲区,M16的一个Flash页为128字节 
unsigned int address = 0; 
unsigned char shift=0;
 unsigned int LHmax,LHmin,LH;
unsigned char Motor1StopFlag,Motor2StopFlag;//电机上次停止方式
unsigned char MotorRunIndex;//电机转位索引，1-调节电机，2-收放电机，０-没有电机运转
unsigned char Motor1Dir;//调节电机转位方向,0－正转，１－反转　
unsigned char Motor2Dir;//收放电机转位方向,0－正转，１－反转
unsigned char Motor1ParaFlag,Motor2ParaFlag;//电机转位方式，０－自由转位，１－带参数转位
unsigned char MF;


void Start(void);
void SendManchester(void); 
void EEPROM_write(unsigned int Address,unsigned char Data);
unsigned char EEPROM_read(unsigned int Address);
//extern void MD5_coeff(void);//标定系数的MD5校验
/*
#pragma abs_address:0x1fc00
//Boot Loader起始地址0x7e00字节，此段代码必须放在Boot Loader区  刘杰
//通过spm指令实现FLASH页擦除/页写，需时[3.7,4.5]ms
//擦除(code=0x03)和写入(code=0x05)一个Flash页 
void boot_page_ew(long p_address,char code) 
{ 
    asm("mov r30,r16\n" 
        "mov r31,r17\n" 
        "out 0x3b,r18\n");            //将页地址放入Z寄存器和RAMPZ的Bit0中 
    SPMCSR = code;                	  //寄存器SPMCSR中为操作码 
    asm("spm\n");                    //对指定Flash页进行操作 
}         
//填充Flash缓冲页中的一个字 
void boot_page_fill(unsigned int address,int data) 
{ 
    asm("mov r30,r16\n" 
        "mov r31,r17\n"             //Z寄存器中为填冲页内地址 
        "mov r0,r18\n" 
        "mov r1,r19\n");            //R0R1中为一个指令字 
    SPMCSR = 0x01; 
    asm("spm\n"); 
} 
//等待一个Flash页的写完成 
void wait_page_rw_ok(void) 
{ 
      while(SPMCSR & 0x40) 
     { 
         while(SPMCSR & 0x01); 
         SPMCSR = 0x11; 
         asm("spm\n"); 
     } 
} 
//更新一个Flash页的完整处理 
void write_one_page(void) 
{ 
    int i; 
	boot_page_fill(shift,ADSDataAvr);
    boot_page_ew(address,0x05);                    //将缓冲页数据写入一个Flash页 
    wait_page_rw_ok();                            //等待写入完成 
} 

void EraseAll(void)
{//压力温度标定数据存储在FLASH区[0x5e00,0x7dff]
   for(address=0x5e00;address<0x7e00;address+=256)//0x7e00-0x5e00=0x19000字节=字节=点*4  刘杰
	    {boot_page_ew(address,0x03);              //擦除一个Flash页 
         wait_page_rw_ok();                       //等待擦除完成 
		}   
}
    
#pragma end_abs_address
*/

void InitialIO(void)
{//1输出，0输入
 
 PORTA=0x18;//PWM,BRAKE=1
 DDRA=0x38; //BRAKE、PWM、DIR输出，其余输入

 PORTB=0x00; 
 DDRB=0x02; //SCK输出，其余输入
 
 PORTC=0x00;
 DDRC=0x03;//M1、M2输出，其余输入
 
 PORTD=0x00; 
 DDRD=0xC8;//T输出，其余输入
 
 PORTE=0x00; 
 DDRE=0x30;//K、K_CCL输出，其余输入
 
 PORTF=0x00; 
 DDRF=0x00;//全部输入
 
 PORTG=0x00; 
 DDRG=0x00;//全部输入
}



void init_USART0(void)  //USART0 初始化
{
	UCSR0B=0X00;
	UCSR0A=0X20;
	UCSR0C=0X06;
	UBRR0L=0X0C;
	UBRR0H=0X00;
	UCSR0B=0X18;
}

void SendUart0(unsigned char c,unsigned int s)   //串口发送数据
{//要求流量板在s个8ms内通过串口返回数据
unsigned char t; 	
while(!(UCSR0A&(1<<UDRE0)));   // 等待发送缓冲器为空
UDR0=c;                      // 将数据放入缓冲器，发送数据

 //超时设定
TimeOutFlag=0; //超时标志置0
Timer0Counter=s; //8ms定时循环次数
TCNT0=0x6;//定时8ms
TCCR0|=0x06;//256分频
Uart0RxCounter=0; //清串口接受计数
TIFR|=0x01; //清定时器0中断标志
if(s>0)
{
TIMSK|=0x01;//使能定时器0中断
t=UDR0;//开串口接收中断前读空缓存
UCSR0B|=0x80;//开串口接收中断
}
}

void init_USART1(void)  //USART0 初始化
{
	UCSR1B=0X00;
	UCSR1A=0X20;
	UCSR1C=0X06;
	UBRR1L=0X33;
	UBRR1H=0X00;
	UCSR1B=0X18;
}

void SendUart1(unsigned char c,unsigned int s)   //串口发送数据
{//要求流量板在s个8ms内通过串口返回数据
unsigned char t; 	
while(!(UCSR1A&(1<<UDRE1)));   // 等待发送缓冲器为空
UDR1=c;                      // 将数据放入缓冲器，发送数据

 //超时设定
TimeOutFlag=0; //超时标志置0
Timer0Counter=s; //8ms定时循环次数
TCNT0=0x6;//定时8ms
TCCR0|=0x06;//256分频
Uart1RxCounter=0; //清串口接受计数
TIFR|=0x01; //清定时器0中断标志
if(s>0)
{
TIMSK|=0x01;//使能定时器0中断
t=UDR1;//开串口接收中断前读空缓存
UCSR1B|=0x80;//开串口接收中断
}
}


char sh_write(unsigned char value)
{
  unsigned char i;
  for (i=0x80;i>0;i/=2)
  {
  if(i & value)
    {
    SHSDA_H
    }
  else 
    {
    SHSDA_L
    }  
  SHSCL_H
  DELAY5
  SHSCL_L  
  DELAY5
  }
  SHSDA_L
  SHSCL_H
  DELAY5
  SHSCL_L
  DELAY5   
}


char sh_read(unsigned char ack)
{
  unsigned char i,val=0;
  DDRD&=0x7F;
  DELAY5  
  for (i=0x80;i>0;i/=2)
  {
  SHSCL_H
  DELAY5
  if ((PIND&0x80)==0x80)
  val=(val|i);
  SHSCL_L
  DELAY5
  }
  DDRD|=0x80;
  SHSDA_L
  SHSCL_H  
  DELAY5
  SHSCL_L
  DELAY5
  //SHSDA_H
  DDRD|=0x80;
  return val;
   
}


void sh_start(void)
{
  SHSDA_H
  DELAY5
  SHSCL_L
  DELAY5
  SHSCL_H
  DELAY5
  SHSDA_L
  DELAY5
  SHSCL_L
  DELAY5
  SHSCL_H
  DELAY5
  SHSDA_H
  DELAY5
  SHSCL_L
  DELAY5  
}

void sh_reset(void)
{
  unsigned char i;
  SHSDA_H
  DELAY5
  SHSCL_L
  DELAY5
  for (i=0;i<9;i++)
  {
  SHSCL_H
  DELAY5
  SHSCL_L
  DELAY5
  }
  sh_start();
}  

void watchdog_init(void)
{
    WDR(); //this prevents a timout on enabling
    WDTCR |= (1<<WDCE) | (1<<WDE);
    WDTCR = 0x08; //WATCHDOG ENABLED - dont forget to issue WDRs
}


void WDT_off(void)
{
    //置位WDCE 和 WDE
    WDTCR = (1<<WDCE) | (1<<WDE);
    //关闭WDT
    WDTCR = 0x00;
}


void Start(void)
{
 InitialIO();
 #if !DBG
 init_USART0();
 init_USART1();
 #endif 
 IntFlag=0;//无接收帧中断
 DataFlag=0;//无标定系数下发 
 coeff_len=0;//标定系数长度为0
 coeff_count=0;//标定系数计数
 dat2=0;
 dat1=0xf0;
 MotorRunIndex=0;

 
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
  DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 DELAY100
 
 //TCNT1=0;//计数器１上电清零
 
 ADMUX=0xC0;//选择ADC0单端输入通道
 ADCSRA|=0xE3;//ADC使能，ADC开始转换，ADC自动触发使能（连续转换模式），8分频 

 ACSR=0x03;//开模拟比较器
 //TCCR1A=0x00;
 //TIFR|=0x10;//清定时器1A中断标志
 //TIMSK|=0x10;//开定时器1A中断	
 //TCCR1B=0xcf;//噪声抑制,CTC模式，上升沿驱动,计数器1外部驱动
 
 //Enable1_L//关收放电机
 //Enable2_L//关调节电机
 
 EICRA|=0x03; //INT0上升沿触发 
 SREG=0x80;//总中断使能
 EIFR=0x01;//清INT0中断标志
 EIMSK=0x01;//使能INT0中断 
}

void main(void)
{ 
unsigned char i;
unsigned int add,at;
unsigned long l,ccl;

Motor1StopFlag=0;//调节电机按命令停止
Motor2StopFlag=0;//收放电机按命令停止
Start();
 
#if DBG
IntFlag=1;
R_dat=0x88;
#endif

 for(i=0;i<2;i++) 
 { for(k=0;k<10000;k++)//延迟1s
  DELAY100}

   LHmin=EEPROM_read(1019);
   LHmin<<=8;
   LHmin|=EEPROM_read(1018);
   
   LHmax=EEPROM_read(1021);
   LHmax<<=8;
   LHmax|=EEPROM_read(1020);
   
//采集总线电压，判断是否进入存储状态
 	 /* AdCounter=0;
	  ADMUX=0xC3;//选择ADC0单端输入通道
	  ADCSRA|=0x10;//清AD中断标志
	  ADCSRA|=0x08;//AD转换中断使能
	  while((AdCounter<514));
	  l=0;
	  for(k=2;k<514;k+=2)//256次值取平均
	  {
	  T_dat=AdData[k+1];
	  T_dat<<=8;
	  T_dat|=AdData[k];
	  l+=T_dat;
	  }
	  T_dat=(l>>8);
	  add=EEPROM_read(1022);
	  add<<=8;
	  add+=EEPROM_read(1023);
	  p=0;

	 if( (T_dat<400) && (add<0x1fe00) && (add>=0))//Cable端的电压低于31.3V，低电压且总点数在存储容量内 
	  {	ADCSRA&=0xF7;//关AD中断
        ADCSRA|=0x10;//清AD中断标志

	    SendUart0(0x60,0); //让流量板进入IDLE模式，以节省压力温度标检时的电流消耗，进而降低电路板自身发热对标检的影响
		
		 for(i=0;i<2;i++) 
         { for(k=0;k<10000;k++)//延迟1s
          DELAY100}
		EEPROM_write(1024,0);
		#asm(" jmp 0xf000")
  
		while(add<0x1fe00)
		{ 
		  address=(add&0xff00)+0x5e00;
		  ADSDataAdd0=0;
		  ADSDataAdd1=0;		  
		  for(i=0;i<5;i++)//共5s
		  {  
		  Uart0RxData[0]=0x00;//流量板无响应时压力赋值0x00
		  Uart0RxData[1]=0x00;
		  SendUart0(0x20,18);//144ms定时
		  while(TimeOutFlag==0);
          TIMSK&=0xFE;//关定时器0中断
		  ADSDataAdd0+=(Uart0RxData[0]*256+Uart0RxData[1]);
		  Uart0RxData[0]=0x00;//流量板无响应时压力赋值0x00
		  Uart0RxData[1]=0x00;
		  SendUart0(0x30,18);//144ms定时
		  while(TimeOutFlag==0);
          TIMSK&=0xFE;//关定时器0中断
		  ADSDataAdd1+=(Uart0RxData[0]*256+Uart0RxData[1]);
		  for(k=0;k<6000;k++)//延迟0.6s
           DELAY100
		  }	 
		 
		  ADSDataAvr=ADSDataAdd0/5;
		  ADSDataAvr=0x1234;
		  if( ((ADSDataAvr-p)<5) && ((ADSDataAvr-p)>-5) )
		  {
		  p=ADSDataAvr;
	      shift=(add&0x00ff);
		  //write_one_page();
		  
		  ADSDataAvr=ADSDataAdd1/5;
		  ADSDataAvr=0x5678;
		  shift=(add&0x00ff)+2;
		  //write_one_page(); 
		  
		  add+=4;
		  EEPROM_write(1022,add>>8);//总字节数存放在EEPROM的最后两个单元
		  EEPROM_write(1023,add);//Atmega32L的EEPROM大小为1024字节
		  }
		  else
		   {p=ADSDataAvr;}	
		}		 
	  while(1);	   //若点数已满，则进入while死循环
	  
  }*/
	  
while(1)//若Cable端为高电压，则进入正常的通讯状态
{ 
   if(IntFlag==2)//校验位错误处理程序
   { 
    T_com=0x0f;
    T_dat=R_dat|(Rx[1]<<8)|(Rx[0]<<12);
    for(k=0;k<8500;k++);
     SendManchester();
	IntFlag=0;//无命令帧
	EIFR=0x01;//清INT0中断标志
    EIMSK=0x01;//使能INT0中断
   }
   else if(IntFlag==1)//接收到了正常命令帧
   {
	if(DataFlag)//下发标定系数程序
    { 	  
	  EEPROM_write(EEPAdd++,R_dat);
	  coeff_count++;	  
	  if(coeff_count==coeff_len)
	  {
		DataFlag=0;
		coeff_len=0;
   	    T_com=0x0B;
   	    T_dat=0x0000;
   	    for(k=0;k<8500;k++);
   	    SendManchester();
	  }
	}
	//*******************************************************
	else//若不是下发标定系数，则进入以下各个命令的子语句
	{ 
    switch(R_dat&0xf0)
     {
	  case 0x00://井下仪软复位
	  if(R_dat==0x00)
	  {
	  T_com=0x00;
	  Start(); 
		Uart0RxData[0]=0x00;//流量板无响应时片载温度传感器赋值0x00
		Uart0RxData[1]=0x00;
		SendUart0(0x00,4);//32ms定时，实际27ms左右返回数据
		while(TimeOutFlag==0);
        TIMSK&=0xFE;//关定时器0中断
		T_dat=Uart0RxData[0];
		T_dat<<=8;
		T_dat|=Uart0RxData[1];
		SendManchester();
	  }
	  else if( (R_dat==0x05)||(R_dat==0x0a) )//换能器放大倍数调节,0x05减小，0x0A增大
	  {SendUart0(R_dat,0); 
	  T_com=0x00;
	  T_dat=R_dat;
   	  for(k=0;k<8500;k++); 
	  SendManchester();
	  }
	  else if( (R_dat==0x06)||(R_dat==0x0b) )//换能器放大倍数调节,0x05减小，0x0A增大
	  {SendUart0(R_dat,0); 
	  T_com=0x00;
	  T_dat=R_dat;
   	  for(k=0;k<8500;k++); 
	  SendManchester();
	  }
	  else
	  {goto E;}
	  break;
	
      case 0x10:
	  if(R_dat==0x11)//马笼头电压
	  {
	  for(k=0;k<300;k++)//延迟30ms
       DELAY100 
	  T_com=0x01;
	  AdCounter=0;
	  ADMUX=0xC3;//选择ADC3单端输入通道
	  ADCSRA|=0x10;//清AD中断标志
	  ADCSRA|=0x08;//AD转换中断使能
	  while((AdCounter<514));
	  l=0;
	  for(k=2;k<514;k+=2)//256次值取平均
	  {
	  T_dat=AdData[k+1];
	  T_dat<<=8;
	  T_dat|=AdData[k];
	  l+=T_dat;
	  }
	  T_dat=(l>>8);
	  SendManchester();
	  }	
	  
	  else if(R_dat==0x12)//+51V电压
	  {
	  for(k=0;k<300;k++)//延迟30ms
       DELAY100 
	  T_com=0x01;
	  AdCounter=0;
	  ADMUX=0xC5;//选择ADC5单端输入通道
	  ADCSRA|=0x10;//清AD中断标志
	  ADCSRA|=0x08;//AD转换中断使能
	  while((AdCounter<514));
	  l=0;
	  for(k=2;k<514;k+=2)//256次值取平均
	  {
	  T_dat=AdData[k+1];
	  T_dat<<=8;
	  T_dat|=AdData[k];
	  l+=T_dat;
	  }
	  T_dat=(l>>8);
	  SendManchester();
	  }
	  
	   else if (R_dat==0x13)//写入湿度寄存器状态并读取状态值
	   {
	   T_com=0x01;	   
	   sh_start();
	   sh_write(0x06);
	   sh_write(0x00);	   
       DELAY300
	   sh_reset();
	   sh_write(0x07);	   
       DELAY300
	   T_dat=sh_read(1);
	   SendManchester();
	   }
	  	  
	   else if (R_dat==0x14)//读温度2
	   {
	   T_com=0x01;	
	      for (k=0;k<4;k+=2) 
		  {
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;	      
		  }
		  SendUart1(0x14,2);		   
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断		
		  for (k=0;k<4;k+=2) 
		  {  
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();		
		  }  	
	   }
	   else if (R_dat==0x15)//读湿度2
	   {
	   T_com=0x01;	     
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
	      SendUart1(0x17,40);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断		  
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();		  	
	   }
	   
	    else if (R_dat==0x18)//读角度
	   {
	   T_com=0x01;
	     for(k=0;k<6;k+=2)
		 {
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
		  }
	      SendUart1(0x18,2);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<6;k+=2)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }	
	 }	 	      
	   	  	    
	  else if(R_dat==0x1A)
	  {
C1:  
      if((PINA&0x08)==0x00)//某电机正在转
	   {CCL_OFF}
	  else
	   {CCL_ON}
	  for(k=0;k<200;k++)//延迟20ms
       DELAY100 
	  T_com=0x01;
	  AdCounter=0;
	  ADMUX=0xC4;//选择ADC4单端输入通道
	  ADCSRA|=0x10;//清AD中断标志
	  ADCSRA|=0x08;//AD转换中断使能
	  while((AdCounter<514));//耗时5ms
	  CCL_OFF
	  ccl=0;
	  for(k=2;k<514;k+=2)//256次值取平均
	  {
	  T_dat=AdData[k+1];
	  T_dat<<=8;
	  T_dat|=AdData[k];
	  ccl+=T_dat;
	  }
	  T_dat=(ccl>>8);   
	  T_dat=1024-T_dat;
	  SendManchester();
	  if(zf) goto C2;
	  }
	  else
	  {goto E;}
	  break;
	  
	  case 0x20://获取井下压力  
	     if(R_dat==0x22)
		 {
Y1:
		 T_com=0x02;
		Uart0RxData[0]=0x00;//流量板无响应时压力赋值0x00
		Uart0RxData[1]=0x00;
		SendUart0(0x20,18);//144ms定时
		while(TimeOutFlag==0);
        TIMSK&=0xFE;//关定时器0中断
		T_dat=Uart0RxData[0];
		T_dat<<=8;
		T_dat|=Uart0RxData[1];
		SendManchester();
	    if(zf) goto Y2;
		  }
	   else
	    {goto E;}
	break;
	
	case 0x30://获取井下温湿度
	     if(R_dat==0x33)
		 {
W1: 
		T_com=0x03;
		Uart0RxData[0]=0x00;//流量板无响应时温度赋值0x00
		Uart0RxData[1]=0x00;
		SendUart0(0x30,18);//144ms定时
		while(TimeOutFlag==0);
        TIMSK&=0xFE;//关定时器0中断
		T_dat=Uart0RxData[0];
		T_dat<<=8;
		T_dat|=Uart0RxData[1];
		SendManchester();
		if(zf) goto W2;
		 }
	   else if (R_dat==0x34)//写入湿度寄存器状态并读取状态值
	   {
	   T_com=0x03;	   
	   sh_start();
	   sh_write(0x06);
	   sh_write(0x01);
	   for(k=0;k<3;k++)//延迟300
       DELAY100
	   sh_reset();
	   sh_write(0x07);
	   for(k=0;k<3;k++)//延迟300
       DELAY100
	   T_dat=sh_read(1);
	   SendManchester();
	   }
	   /*else if (R_dat==0x35)//读温度
	   {
	   unsigned char val;
	   T_com=0x03;
	   sh_reset();
	   sh_write(0x03);
	   for(k=0;k<4000;k++)//
       DELAY100	      
	   T_dat=sh_read(1);
	   T_dat<<=8; 
	   val=sh_read(1);
	   T_dat|=val;
	   SendManchester();  
	   }
	   else if (R_dat==0x36)//读湿度
	   {
	   unsigned char val;
	   T_com=0x03;
	   sh_reset();
	   sh_write(0x05);
	   for(k=0;k<4000;k++)//
       DELAY100	      
	   T_dat=sh_read(1);
	   T_dat<<=8; 
	   val=sh_read(1);
	   T_dat|=val;
	   SendManchester();  
	   }*/
	   else if (R_dat==0x37)//读角度
	   {
	   T_com=0x03;
	     for(k=0;k<3;k++)
		 {Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;}
	      SendUart1(0x37,18);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<3;k++)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }	
	   }
	   else if (R_dat==0x38)//读离合
	   {
	   T_com=0x03;
	     for(k=0;k<3;k++)
		 {Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;}
	      SendUart1(0x37,18);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<3;k++)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }	
	   }
	  /* else if (R_dat==0x39)//读湿度2
	   {
	   T_com=0x03;	 
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
	      SendUart1(0x37,40);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断		  
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();		  	
	   }
	   else if (R_dat==0x3A)//读温度2
	   {
	   T_com=0x03;	     
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
	      SendUart1(0x37,40);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断		  
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();		  	
	   }*/
	   else
	    {goto E;}
	break;
	
	case 0x40://流量采样
	    if(R_dat==0x4f)
		{ 
       L1: 
		T_com=0x04;
		 for(k=0;k<16;k+=2)//流量板无响应时应赋值0x0000
		  {Uart0RxData[k]=0x12;
		  Uart0RxData[k+1]=0x34;}
		SendUart0(0x4f,2);//16ms定时,实际上5ms内可以返回
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<16;k+=2)
		  {
		  T_dat=Uart0RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart0RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }
		 if(zf) goto L2;
		 }
	   else
	    {
		 T_com=0x04; 
		 for(k=0;k<8;k+=2)//流量板无响应时应赋值0x0000
		  {Uart0RxData[k]=0x00;
		  Uart0RxData[k+1]=0x00;}
		SendUart0(R_dat,1);//8ms定时
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<8;k+=2)
		  {
		  T_dat=Uart0RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart0RxData[k+1];
		  for(Tt=0;Tt<9000;Tt++); 
		  SendManchester();
		  }
		}
		
	   {goto E;}
	break;
	
	case 0x50://井下仪固件版本号
	  if(R_dat==0x55)
		 {
		T_com=0x05;
		Uart0RxData[0]=0xff;//流量板无响应时版本号赋值0x00
		SendUart0(0x50,3);//24ms定时
		while(TimeOutFlag==0);
        TIMSK&=0xFE;//关定时器0中断
		T_dat=Uart0RxData[0];
		T_dat<<=8;
		T_dat|=BB;
		SendManchester();	
		}
	  else
	  {goto E;}
	break;

	case 0x60: //上传压力温度标定数据,47ms/帧,共2048帧，计96秒
	  if(R_dat==0x66)
	  { 
	    EEPROM_write(1024,0x60);
		watchdog_init();	    
		for(k=0;k<42000;k++);	
		T_com=0x60;
		T_dat=0x1111;
		SendManchester();
		
		/*T_com=0x06;
	    T_dat=EEPROM_read(1022);
		T_dat<<=8;
		T_dat+=EEPROM_read(1023);
		at=T_dat+0x5e00;
		T_dat>>=2;//把字节数变成点数并发送
		for(k=0;k<15000;k++);//太快上传压力温度数据，会导致总线电压不正常
	    SendManchester();
		for(address=0x5e00;address<at;address+=2)
	    {  T_dat = *(const unsigned char *)(address+1); 
		   T_dat<<=8;
		   T_dat += *(const unsigned char *)(address); 
	       for(k=0;k<15000;k++);  //太快上传压力温度数据，会导致总线电压不正常
		   SendManchester();
		}*/		 
	  }
	  else
	  {goto E;}
	break;
	
	case 0x70://收放电机转位,电机启动需100ms左右,电压被拉低到35V左右
	   T_com=0x07;
	   
	   //检测离合传感器
		/*{
          AdCounter=0;
	      ADMUX=0xC3;//选择ADC3单端输入通道
	      ADCSRA|=0x10;//清AD中断标志
	      ADCSRA|=0x08;//AD转换中断使能
	      while((AdCounter<514));
	      l=0;
	     for(k=2;k<514;k+=2)//256次值取平均
	      {
	       T_dat=AdData[k+1];
	       T_dat<<=8;
	       T_dat|=AdData[k];
	       l+=T_dat;
	      }
	     LH=(l>>8);
		 T_dat=0;
		 if(LH<=LHmin)
		  LH=LHmin;
		 else if(LH>=LHmax)
		  LH=LHmax;
		 
		 {
		   	ta=LHmax-LH;
		    tb=LHmax-LHmin;
		    T_dat=ta*100;
		    T_dat=T_dat/tb;   
		 }
		   
		  if( T_dat>=50 )//有水嘴对接,不能收放
		  { for(k=0;k<300;k++)//延迟30ms
            DELAY100 
		    T_dat=7;
			SendManchester();
	        break;
		  }
		}*/
		
	    if((R_dat&0x08)==0x08)//命令要求遇堵反转
		 MF=1;
		else
		 MF=0;
		
		  
	   MotorDir=0;
	   MotorON=0;
	   TimeOutFlag=0;
	   Timer0Counter=50; //400ms定时循环次数
       TCNT0=0x06;//定时8ms
       TCCR0|=0x06;//256分频
	   TIFR|=0x01; //清定时器0中断标志
       TIMSK|=0x01;//使能定时器0中断
       CompCounter=0;
	   Int1Counter=0;
	  
    if((PINA&0x08)==0x00)//某电机正在转
	  { if(MotorRunIndex==2)
	     {
	     MotorON=1;
	     if((R_dat&0x04)==0x04)//正转命令
		   {
		    if((PINA&0x20)==0x20)//正在正转
		     MotorDir=1;//同向
			else
			 MotorDir=0;//反向
		   }
		 else               //反转命令
		 {
		   if((PINA&0x20)==0x00)//正在反转
		     MotorDir=1;
			else
			 MotorDir=0;
		  }
		 }
		 else//调节电机正在转
		 {
		  MotorON=1;//有某个电机正在转位
	      MotorDir=0;
		 }
	  }
	  else                 //二个电机都是停止状态
	  { MotorON=0; 
	    T_dat=0x0000;     //假设电机启动成功   
		
		ACSR&=0xf7;//关模拟比较器中断 
		ACSR|=0x10;//清模拟比较器中断标志
		
		MotorRunIndex=2;//电机转位索引，1-调节电机，2-收放电机，０-没有电机运转 

		  if((R_dat&0x04)==0x04)//命令要求正转
		   { 
		      Motor2Dir=0;//正转
		      DIR_L
		    }
		  else                //命令要求反转
		   { 
		     Motor2Dir=1;//反转
		      DIR_H
		    }
		Motor2StopFlag=0xff;	
		
		BREAK_ON
		
		
		for(Tt=0;Tt<20;Tt++)//延迟200ms
		   for(k=0;k<4200;k++);
		 
		EIMSK=0x02;//使能INT1中断 
		E_flag=0; 
		  
		if((R_dat&0x02)==0x00)//正常启动，给电机200ms的启动时间（无电流监测）
		  { ACSR|=0x10;//清模拟比较器中断标志	    
		    ACSR|=0x08;//开模拟比较器中断  
		  }     
		else                 //强制启动，给电机800ms的启动时间（无电流监测）
	      {  ACSR|=0x10;//清模拟比较器中断标志  
		  }   
		}

		while(TimeOutFlag==0);
		TimeOutFlag=0;
		   
		if(MotorON==1)//有某个电机正在转位
		{
		  if(MotorDir==1)//命令要求的电机与目前正在转位的电机相同，且转位方向也相同	     
		     T_dat=0x0004;//该电机已启动(收放电机已启动)
		  else
		     T_dat=0x0003;//电机未停止，不能换相或启动另一个电机
		 }
		else
		  {if( (Motor2StopFlag==0x01) )//200ms后堵转并产生中断
		     {E_flag=1;  
			  T_dat=0x0001; 
		     }
		   ACSR|=0x08;//开模拟比较器中断 
		  }
		  
		if(E_flag==0) 
		    { if( Motor2StopFlag==0x01)   
			   {ACSR|=0x10;//清模拟比较器中断标志
			   T_dat=0x0002;//400ms后堵转
			   }
		    }
	    if(T_dat==0)//启动成功
		 {
		  if((R_dat&0x01)==0x00)        //自由转位
	 		  {
	 		    Motor2ParaFlag=0;
			  }
		  else                         //按参数转位
	 		  {
                TCCR2 = 0x00; //stop
 			    TCNT2 = 0x00; //setup?
 			    OCR2  = 0x00;//定时器2中断
 			    TCCR2 = 0x05; //32.8ms，1024预分频
				TIFR|=0x40; //清定时器2中断标志
			    TIMSK|=0x40;//开定时器2中断
				Timer2Counter=280;//290个32.8ms，共9.184s 
	  			Motor2ParaFlag=1;
				}
		 }
		
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms	
		CompCounter=0;
        Int1Counter=0;
		if(Motor2StopFlag==5)//欠压堵转，启动失败
		 {T_dat=0x0005;
		 } 
		SendManchester();
		
	break;
	
	case 0x80://调节电机转位,电机启动需100ms左右,电压被拉低到35V左右
	   T_com=0x08;

	   //检测离合传感器
		/*{
          AdCounter=0;
	      ADMUX=0xC3;//选择ADC3单端输入通道
	      ADCSRA|=0x10;//清AD中断标志
	      ADCSRA|=0x08;//AD转换中断使能
	      while((AdCounter<514));
	      l=0;
	     for(k=2;k<514;k+=2)//256次值取平均
	      {
	       T_dat=AdData[k+1];
	       T_dat<<=8;
	       T_dat|=AdData[k];
	       l+=T_dat;
	      }
	     LH=(l>>8);
		 T_dat=0;
		 if(LH<=LHmin)
		  LH=LHmin;
		 else if(LH>=LHmax)
		  LH=LHmax;
		 
		 {
		   	ta=LHmax-LH;
		    tb=LHmax-LHmin;
		    T_dat=ta*100;
		    T_dat=T_dat/tb;   
		 }
		   
		  if( T_dat<50 )//无水嘴对接,不能调节
		  { for(k=0;k<300;k++)//延迟30ms
            DELAY100 
		    T_dat=7;
			SendManchester();
	        break;
		  }
		}*/
		
	   	if((R_dat&0x08)==0x08)//命令要求遇堵反转
		 MF=1;
		else
		 MF=0;
		  
	   MotorDir=0;
	   MotorON=0;
	   TimeOutFlag=0;
	   Timer0Counter=50; //400ms定时循环次数
       TCNT0=0x06;//定时8ms
       TCCR0|=0x06;//256分频
	   TIFR|=0x01; //清定时器0中断标志
       TIMSK|=0x01;//使能定时器0中断
       CompCounter=0;
	   Int1Counter=0;
	   
    if((PINA&0x08)==0x00)//某电机正在转
	  { if(MotorRunIndex==1)
	     {
	     MotorON=1;
	     if((R_dat&0x04)==0x04)//正转命令
		   {
		    if((PINA&0x20)==0x20)//正在正转
		     MotorDir=1;//同向
			else
			 MotorDir=0;//反向
		   }
		 else               //反转命令
		 {
		   if((PINC&0x20)==0x00)//正在反转
		     MotorDir=1;
			else
			 MotorDir=0;
		  }
		 }
		 else//调节电机正在转
		 {
		  MotorON=1;//有某个电机正在转位
	      MotorDir=0;
		 }
	  }
	  else                 //二个电机都是停止状态
	  { MotorON=0; 
	    T_dat=0x0000;     //假设电机启动成功   
		
		ACSR&=0xf7;//关模拟比较器中断 
		ACSR|=0x10;//清模拟比较器中断标志

		 MotorRunIndex=1;
		 
		  if((R_dat&0x01)==0x00)        //自由转位
	 		  {TIMSK&=0xef;//关定时器1A比较中断	
                TIFR|=0x10;//清计数器1A中断标志 
	 		    Motor1ParaFlag=0;
			  }
		  else                         //按参数转位
	 		  {
	  			Motor1ParaFlag=1;
			  }
		    
		  if((R_dat&0x04)==0x04)//命令要求正转
		  { 
		    Motor1Dir=0;
		    DIR_L
		   }
		  else                //命令要求反转
		   { 
		    Motor1Dir=1;
		    DIR_H
		    }
		
		  Motor1StopFlag=0xff;
		  
		  BREAK_ON
		 
		
		for(Tt=0;Tt<20;Tt++)//延迟200ms
		   for(k=0;k<4200;k++);
		
		EIMSK=0x02;//使能INT1中断 
		E_flag=0;  
			 
		if((R_dat&0x02)==0x00)//正常启动
		  { ACSR|=0x10;//清模拟比较器中断标志
		    ACSR|=0x08;//开模拟比较器中断  
		  }     
		else                 //强制启动
	      {  ACSR|=0x10;//清模拟比较器中断标志  
		  } 	    
		}

		while(TimeOutFlag==0);
		TimeOutFlag=0;
		   
		if(MotorON==1)//有某个电机正在转位
		 {
		  if(MotorDir==1)//命令要求的电机与目前正在转位的电机相同，且转位方向也相同
		     T_dat=0x0004;//该电机已启动(调节电机)
		  else
		     T_dat=0x0003;//电机未停止，不能换相或启动另一个电机
		  }
		 else
		  {if( ((Motor1StopFlag)==0x01) )//200ms后堵转并产生中断
		     {E_flag=1;  
			  T_dat=0x0001; 
		     }
		    ACSR|=0x08;//开模拟比较器中断 
		  }
		  
		if(E_flag==0) 
		    { if( ((Motor1StopFlag)==0x01))   
			   {ACSR|=0x10;//清中断标志
			   T_dat=0x0002;//400ms后堵转
			   }
		    }
		
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms
		for(k=0;k<42000;k++);	//100ms
		CompCounter=0;
        Int1Counter=0;
		if(Motor1StopFlag==5)//欠压堵转，启动失败
		 {T_dat=0x0005;
		 }
		SendManchester();
		
		if( ((R_dat&0x01)==0x01) && (Motor1StopFlag==0xff) )//命令要求调节电机按参数转动
		   { 
		     BREAK_OFF
			 Motor1StopFlag=2;//调节电机按参数停止
		   }
	  SendManchester();
	break;
		
    case 0x90://电机状态	 
		if(R_dat==0x99)//获取电机状态	
		{ D1:
		  T_com=0x09;
		  T_dat=0x0000;
		
		  if( ((PINA&0x08)==0x00) && (MotorRunIndex==1) )//判断调节电机是否转动
		  {  
		      T_dat|=(1<<15); //正在转动
		  
		    if(Motor1Dir==0)//判断正反转
		      T_dat|=(1<<14);//正在正转
		    if((Motor1ParaFlag)==1)//带参数转动
		      T_dat|=(1<<13);
		  }
		  else
		  {
		    if(Motor1StopFlag==1)//过流堵转停止
		      T_dat|=(1<<13);
		    else if(Motor1StopFlag==2)//按参数停止
		      T_dat|=(1<<14);
		    else if(Motor1StopFlag==5)//欠压堵转停止
		     {T_dat|=(1<<13); 
			  T_dat|=(1<<14);}
		  }
		 
		  if( ((PINA&0x08)==0x00) && (MotorRunIndex==2) )//判断收放电机是否转动
		  {   
		        T_dat|=(1<<12);
				
		   if(Motor2Dir==0)//判断正反转
		     T_dat|=(1<<11);//正转
		   if((Motor2ParaFlag)==1)//带参数转动
		     T_dat|=(1<<10);
	      }
		  else
		  {
		   if(Motor2StopFlag==1)//过流堵转停止
		     T_dat|=(1<<10);
		   else if(Motor2StopFlag==2)//按参数停止
		     T_dat|=(1<<11);
		   else if(Motor2StopFlag==5)//欠压堵转停止
		     {T_dat|=(1<<10);
			  T_dat|=(1<<11);}
		  }
		 
	  for(k=0;k<300;k++)//延迟30ms
       DELAY100 
	  dat2=T_dat;
	  AdCounter=0;
	  ADMUX=0xC2;//选择ADC6单端输入通道
	  ADCSRA|=0x10;//清AD中断标志
	  ADCSRA|=0x08;//AD转换中断使能
	  while((AdCounter<514));
	  l=0;
	  for(k=2;k<514;k+=2)//256次值取平均
	  {
	  T_dat=AdData[k+1];
	  T_dat<<=8;
	  T_dat|=AdData[k];
	  l+=T_dat;
	  }
	  T_dat=(l>>8);
	  T_dat&=0x03ff;
	  dat2&=0xfc00;
	  T_dat|=dat2;
	  SendManchester();
	  if(zf) goto D2;
		}
		else
	     {goto E;}
   
	break;
	
	  case 0xA0://电机停止
	    if(R_dat==0xAA)
		{
		T_dat=0x0000;
		T_com=0x0A;
		for(k=0;k<8500;k++);//20ms
		SendManchester();
		for(k=0;k<10000;k++);//20ms
        BREAK_OFF
		if(MotorRunIndex==1)
   			Motor1StopFlag=0;//调节电机按命令停止
        else if(MotorRunIndex==2)
            Motor2StopFlag=0;//收放电机按命令停止
		MotorRunIndex=0;
		}
		
	    else if (R_dat==0xA1)//读离合
	   {
	   T_com=0x0A;
	     for(k=0;k<6;k+=2)//流量板无响应时应赋值0x0000
		  {Uart1RxData[k]=0x56;
		  Uart1RxData[k+1]=0x78;}
		SendUart1(0xA1,2);//16ms定时,实际上5ms内可以返回
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断		        
		  
		  for(k=0;k<6;k+=2)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }	
	   }	   
	  
	   else if(R_dat==0xA2)//采样并存储离合传感器0%值
	   {
	     T_com=0x0A;	  	  
	      for(k=0;k<3;k++)
		 {
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
		  }
	      SendUart1(0xA1,18);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<3;k++)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  EEPROM_write(1016+2*k,T_dat);
		  EEPROM_write(1017+2*k,T_dat>>8);
		  }	
		  
		 
		 LHmax=T_dat;	 
	
	   }
	   else if(R_dat==0xA3)//采样并存储离合传感器100%值
	   {
	    T_com=0x0A;
	  	   for(k=0;k<3;k++)
		 {
		  Uart1RxData[k]=0x00;
		  Uart1RxData[k+1]=0x00;
		  }
	      SendUart1(0xA1,18);
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<3;k++)
		  {
		  T_dat=Uart1RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart1RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  EEPROM_write(1010+2*k,T_dat);
		  EEPROM_write(1011+2*k,T_dat>>8);
		  }	
		 
		 LHmin=T_dat;
	   }
	   else if(R_dat==0xA4)//获取调节臂状态
		 {
T1:
		  T_com=0x0A;
	  	  for(k=0;k<300;k++)//延迟30ms
            DELAY100 
	      AdCounter=0;
	      ADMUX=0xC3;//选择ADC3单端输入通道
	      ADCSRA|=0x10;//清AD中断标志
	      ADCSRA|=0x08;//AD转换中断使能
	      while((AdCounter<514));
	      l=0;
	     for(k=2;k<514;k+=2)//256次值取平均
	      {
	       T_dat=AdData[k+1];
	       T_dat<<=8;
	       T_dat|=AdData[k];
	       l+=T_dat;
	      }
	     LH=(l>>8);
		 T_dat=0;
		 if(LH<=LHmin)
		  LH=LHmin;
		 else if(LH>=LHmax)
		  LH=LHmax;
		 
		 {
		   	ta=LHmax-LH;
		    tb=LHmax-LHmin;
		    T_dat=ta*100;
		    T_dat=T_dat/tb;
		   
		 }
		  
	     SendManchester();
		   if(zf) goto T2;
		 }
	  else
	  {goto E;}
	   break;
	
	case 0xB0://下发标定系数,42ms/帧，共9072ms  2011062  刘杰
	   if(R_dat==0xBB)//下发全部标定系数，共216字节
	   { 
	     EEPAdd=0;
		 DataFlag=1;
		 coeff_len=216;
		 coeff_count=0;
		 TimeOutFlag=0;
		 Timer0Counter=2500;
	     TCNT0=0x44; //15s定时
	     TCCR0|=0x06;//256分频*/
	     TIFR|=0x01; //清定时器0中断标志
         TIMSK|=0x01;//使能定时器0中断		 
	   }
	  else
	  {goto E;}
	break;
	
	case 0xC0: //上传标定系数,47ms/帧,共5076ms
	  if(R_dat==0xCC)
	  { 
	     T_com=0x0C;
		// MD5_coeff();//进行标定系数的MD5校验
		 for(i=0;i<216;)
		 {		 
		 T_dat=EEPROM_read(i);
		 T_dat<<=8;
		 i++;		 
		 T_dat|=EEPROM_read(i);
		 i++;
		 for(k=0;k<15000;k++);
		 SendManchester();
		 }		 
		T_dat=0x0000;
		for(k=0;k<15000;k++);
	    SendManchester();
	  }
	  else
	  {goto E;}
	break;
	
	case 0xD0: //清空标定数据
	  if(R_dat==0xDD)
	   { 
	  	
	    EEPROM_write(1024,0xD0);
		watchdog_init();
		for(k=0;k<42000;k++);
		T_com=0xD0;
		T_dat=0x1111;
		SendManchester();
		
		/*
		T_com=0x0D;
		T_dat=0x0000;
		EraseAll(); //清空FLASH中的[5e00,7dff]区域，共8192/128=64页
		EEPROM_write(1022,0);//清除总字节数
		EEPROM_write(1023,0);
		for(k=0;k<8500;k++);
	    SendManchester();//发送反馈帧*/
	  }
	  else
	  {goto E;}
	break;
	
	case 0xE0://读幅值
	    if(R_dat==0xEE)
		{
		T_com=0x0E;
		SendUart0(0xE0,6);//48ms定时
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<8;k+=2)
		  {
		  T_dat=Uart0RxData[k];
		  T_dat<<=8;
		  T_dat|=Uart0RxData[k+1];
		  for(Tt=0;Tt<10000;Tt++); 
		  SendManchester();
		  }
		  }
		else if(R_dat==0xEA)//总返回780ms
		 {zf=1;
		  goto Y1;//压力,160ms
		  Y2:zf=0;
		  
		  zf=1;
		  goto W1;//温度,160ms
		  W2:zf=0;
		  
		  zf=1;
		  goto L1;//流量,38*8=300ms
		  L2:zf=0;
		  
		  zf=1;
		  goto D1;//电机状态,50ms
		  D2:zf=0;
		  
		  zf=1;
		  goto C1;//磁定位,70ms
		  C2:zf=0;
		  
          zf=1;
		  goto T1;//调节臂状态,50ms
		  T2:zf=0;
		 }
	  else
	  {goto E;}
	break;

  case 0xF0: //连续提取流量测试数据，4个通道分别提取，命令为0xF1-0xF4
        if((R_dat>0xf0) && (R_dat<0xf5) )
          SendUart0(R_dat,15);//120ms定时
		else
		  goto E;
		while(TimeOutFlag==0);
		TIMSK&=0xFE;//关定时器0中断
		  for(k=0;k<1800;k++)//共1800帧数据，全部提取
		  {T_com=0x0F;
		   SendUart0(0xFF,8);//64ms定时
		   while(TimeOutFlag==0);
		   TIMSK&=0xFE;//关定时器0中断
		  T_dat=Uart0RxData[0];
		  T_dat<<=8;
		  T_dat|=Uart0RxData[1];
		 // for(Tt=0;Tt<5000;Tt++); 
		  SendManchester();
		  }
    break;
	
    default://非法命令
E:
         //T_com=0x0f; 
	     //T_dat=0x0000|R_dat;//若遇到非法命令，则将该命令当作数据原样返回
	     //for(k=0;k<8500;k++);
	     //SendManchester();//20ms
    break;	
   }
 }

	IntFlag=0;
    EIFR=0x01;//清INT0中断标志
    EIMSK=0x01;//使能INT0中断 
 }
}
}

#pragma interrupt_handler E_comp:24
void E_comp(void)  //模拟比较器中断,AIN0/AIN1作为比较器的正负输入端，其中AIN1电压为3V
{unsigned char i;
 //过流堵转
 CompCounter++;
 
 if(CompCounter>1000)
 {
  BREAK_OFF  //关电机
 
  ACSR&=0xf7;//关模拟比较器中断 
  ACSR|=0x10;//清模拟比较器中断标志
  EIMSK=0xfd;//关INT1  
  EIFR=0x02;//清INT1中断标志
 
 

 if(MotorRunIndex==1)
   { Motor1StopFlag=1;//调节电机过流堵转停止
    if(MF)
     { 
    for(i=0;i<8;i++) 
	 {for(k=0;k<42000;k++);}	//100ms
	 
    if(Motor1Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
      for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	 BREAK_OFF
	 }
   }
 else if(MotorRunIndex==2)
    {Motor2StopFlag=1;//收放电机过流堵转停止
	  if(MF)
     { 
	 for(i=0;i<8;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	  
    if(Motor2Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
      for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	  BREAK_OFF
	  }
	 }
  

  MotorRunIndex=0;  
  CompCounter=0;
  Int1Counter=0;
  
  ACSR&=0xf7;//关模拟比较器中断 
  ACSR|=0x10;//清模拟比较器中断标志
  EIMSK&=0xfd;//关INT1
  EIFR|=0x02;//清INT1中断标志
  }
}

#pragma interrupt_handler int1_isr:3
void int1_isr(void)
{unsigned char i;
 //欠压堵转
  Int1Counter++;
   
 
 
  if(EIFR&0x02)
    {CompCounter++;
	 EIFR|=0x02;//通过写入1清INT1中断标志
	 }

  if( (Int1Counter>1000)  )//总线电压被拉低到28.5V后再延迟100ms
 {
   BREAK_OFF  //关电机
  
  ACSR&=0xf7;//关模拟比较器中断 
  ACSR|=0x10;//清模拟比较器中断标志
  EIMSK&=0xfd;//关INT1
  EIFR|=0x02;//清INT1中断标志
  
	
  if(MotorRunIndex==1)
    {Motor1StopFlag=5;//调节电机欠压堵转停止
	  if(MF)
 {  
	for(i=0;i<8;i++) 
	{for(k=0;k<42000;k++);}	//100ms
	
    if(Motor1Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
     for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	 BREAK_OFF
	 }
	 }
  else if(MotorRunIndex==2)
    {Motor2StopFlag=5;//收放电机欠压堵转停止
	    if(MF)
     { 
	for(i=0;i<8;i++) 
	 {for(k=0;k<42000;k++);}	//100ms
	 
    if(Motor2Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
      for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	 BREAK_OFF
	 }
	 }


  MotorRunIndex=0;
  CompCounter=0;
  Int1Counter=0;
  }
  else if((CompCounter>100))
  {
   BREAK_OFF  //关电机
  
  ACSR&=0xf7;//关模拟比较器中断 
  ACSR|=0x10;//清模拟比较器中断标志
  EIMSK&=0xfd;//关INT1
  EIFR|=0x02;//清INT1中断标志
  	
 if(MotorRunIndex==1)
   { Motor1StopFlag=1;//调节电机过流堵转停止
   
    for(i=0;i<8;i++) 
	 {for(k=0;k<42000;k++);}	//100ms
	 
    if(Motor1Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
      for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	 BREAK_OFF
   }
 else if(MotorRunIndex==2)
    {Motor2StopFlag=1;//收放电机过流堵转停止
	
	 for(i=0;i<8;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	  
    if(Motor2Dir==0)
	 {DIR_H}
	 else
	  {DIR_L}
	  
	 BREAK_ON
      for(i=0;i<6;i++) 
	  {for(k=0;k<42000;k++);}	//100ms
	 BREAK_OFF
	 }

  MotorRunIndex=0;
  CompCounter=0;
  Int1Counter=0;
  
   ACSR&=0xf7;//关模拟比较器中断 
  ACSR|=0x10;//清模拟比较器中断标志
  EIMSK&=0xfd;//关INT1
  EIFR|=0x02;//清INT1中断标志
  }
}

#pragma interrupt_handler usart0_isr:19
void usart0_isr(void) //串口接收中断
{
Uart0RxData[Uart0RxCounter]=UDR0;//接收串口数据,同时清空串口接收中断标志
 	Uart0RxCounter++;
}

#pragma interrupt_handler usart1_isr:31
void usart1_isr(void) //串口接收中断
{
    //int i;
Uart1RxData[Uart1RxCounter]=UDR1;//接收串口数据,同时清空串口接收中断标志
 	Uart1RxCounter++;
	//CLI();               
    //UCSR1B&=~(1<<RXCIE1);
	//for (i=0;i<6;i++)	
	//Uart1RxData[i]=Vx();
}

#pragma interrupt_handler timer0_ovf_isr:17
void timer0_ovf_isr(void)  //定时器0中断
{//定时多少个8ms 
if(Timer0Counter)
  Timer0Counter--;
  
if(Timer0Counter)
   {//定时8ms
   TCNT0=0x06;
   TCCR0|=0x06;//256分频 
   }
else
  {
  TIMSK&=0xFE;//关定时器0中断
  TimeOutFlag=1;//超时标志置位
  DataFlag=0;  
  }			
}

#pragma interrupt_handler timer2_ovf_isr:14
void timer2_ovf_isr(void)
{
 if(Timer2Counter)
  Timer2Counter--;
  
 if(Timer2Counter==0)
  {
  TCCR2 = 0x00; //stop
  TIMSK&=0xbf;//关定时器2中断
  if( (MotorRunIndex==2) && (Motor2ParaFlag==1) )//收放电机正在按参数转
   { BREAK_OFF   //关收放电机
     Motor2StopFlag=2;//收放电机按参数停止
     MotorRunIndex=0;
   }
  }  
  TIFR|=0x40; //清定时器2中断标志
}

#pragma interrupt_handler ad_isr:22
void ad_isr(void)  //ad转换中断
{
AdData[AdCounter]=ADCL;//读AD转换结果
AdCounter++;
AdData[AdCounter]=ADCH;
AdCounter++;
if(AdCounter==514)
{ 
ADCSRA&=0xF7;//关AD中断
ADCSRA|=0x10;//清AD中断标志
}
}

#pragma interrupt_handler int0_isr:2
void int0_isr(void)//外部中断0
{ 
  unsigned int r;
  EIMSK&=0xFE;//关INT0
  
  DELAY50  
  if((PIND&0x01)==0x00)//1
  goto End;
  
  DELAY100
  if((PIND&0x01)==0x01)//0
  //goto End;
  r=r;
  
  DELAY100
  if((PIND&0x01)==0x01)//0
  goto End;
  
  DELAY100
  if((PIND&0x01)==0x00)//1
  goto End;
  
  DELAY100
  if((PIND&0x01)==0x01)//0
  //goto End;
  r=r;
  
  DELAY100
  if((PIND&0x01)==0x01)//0
  goto End;

   
  DELAY100   
  for(Int_count=9;Int_count>0;Int_count--)
  {
  if((PIND&0x01)==0x01)
    Rx[Int_count]=1;
  else
    Rx[Int_count]=0;
  DELAY397
  }   
   
    R_dat=0;
    if(Rx[2])
          R_dat|=0x01;
    if(Rx[3])
          R_dat|=0x02;
    if(Rx[4])
          R_dat|=0x04;
    if(Rx[5])
          R_dat|=0x08;
    if(Rx[6])
          R_dat|=0x10;
    if(Rx[7])
          R_dat|=0x20;
    if(Rx[8])
          R_dat|=0x40;
    if(Rx[9])
          R_dat|=0x80;
	
	Rx[0]=1;  
	for(r=2;r<10;r++)  
       Rx[0]^=Rx[r];  
	   
	if(Rx[0]==Rx[1])//接收帧正常	
		IntFlag=1;
	else           //接收帧校验错
		IntFlag=2;
		  
   goto End1;//只要接收到正常的同步头，不管校验位是对是错，都暂时不开放INT0中断
     
End:
    EIFR=0x01;//清INT0中断标志
    EIMSK=0x01;//使能INT0中断
End1:
   ;
}

void SendManchester(void) //曼码发送程序
{   
  unsigned int L;
  SREG=0x00;//关总中断 

  //模拟同步头数据
	//4位命令
	T_dat_buf[21]=(T_com&0x08)>>3;
	T_dat_buf[20]=(T_com&0x04)>>2;
	T_dat_buf[19]=(T_com&0x02)>>1;
	T_dat_buf[18]=T_com&0x01;
	//16位数据
	T_dat_buf[17]=(T_dat&0x8000)>>15;
	T_dat_buf[16]=(T_dat&0x4000)>>14;
	T_dat_buf[15]=(T_dat&0x2000)>>13;
	T_dat_buf[14]=(T_dat&0x1000)>>12;
	T_dat_buf[13]=(T_dat&0x0800)>>11;
    T_dat_buf[12]=(T_dat&0x0400)>>10;
    T_dat_buf[11]=(T_dat&0x0200)>>9;
	T_dat_buf[10]=(T_dat&0x0100)>>8;
	T_dat_buf[9]=(T_dat&0x0080)>>7;
	T_dat_buf[8]=(T_dat&0x0040)>>6;
	T_dat_buf[7]=(T_dat&0x0020)>>5;
	T_dat_buf[6]=(T_dat&0x0010)>>4;
	T_dat_buf[5]=(T_dat&0x0008)>>3;
	T_dat_buf[4]=(T_dat&0x0004)>>2;
	T_dat_buf[3]=(T_dat&0x0002)>>1;
	T_dat_buf[2]=T_dat&0x0001;
	
	
	//计算校验位，奇校验
	T_dat_buf[1]=1;
  	for(L=2;L<22;L++)
		{T_dat_buf[1]^=T_dat_buf[L];}

	//同步头
	M1_L
	M2_H 		 
	DELAY89//高100us
	M2_L
	DELAY40
	M1_H 
	DELAY170
	M1_L
	M2_H 
	DELAY89//高100us
	M2_L
	DELAY40
	M1_H    
    //DELAY200//低200us
	for(Tt=0;Tt<68;Tt++);

     //连续发送16位,每位400us
 	for(L=21;L>0;L--)
	{   
	  if(T_dat_buf[L])//1
        {         	 		
         	M1_L
	        M2_H 
	        DELAY89//高100us
	        M2_L
			DELAY40
	        M1_H       
         	DELAY268//低300us
		} 
       else 		//0 				                
        DELAY397//低400us	
    }
 DELAY400
 DELAY400
 DELAY400
 DELAY400
 DELAY400    
 EIFR|=0x01;//清INT0中断标志
 SREG=0x80; //开总中断*/
 M1_L
}


void EEPROM_write(unsigned int Address,unsigned char Data)  	//内部EEPROM写
{//时钟频率为1MHz，典型的EEPROM字节写耗时约8.5ms
    while(EECR&0x02);                   // 等待上一次写操作结束
    EEAR=Address;
    EEDR=Data;                        	// 设置地址和数据寄存器
    EECR|=0x04;                         //置位EEMWE
    EECR|=0x02;                         //置位EEWE 以启动写操作
}

unsigned char EEPROM_read(unsigned int Address)  				//内部EEPROM读
{
    while(EECR&0x02);      				//等待上一次操作结束
    EEAR = Address;                     //设置地址寄存器						
	EECR|=0x01;             			//设置EERE 以启动读操作
    return EEDR;                   		//自数据寄存器返回数据
}    

